
const MrsXenova = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var transformers_min_exports = {};
  __export(transformers_min_exports, {
    ASTFeatureExtractor: () => __webpack_exports__ASTFeatureExtractor,
    ASTForAudioClassification: () => __webpack_exports__ASTForAudioClassification,
    ASTModel: () => __webpack_exports__ASTModel,
    ASTPreTrainedModel: () => __webpack_exports__ASTPreTrainedModel,
    AlbertForMaskedLM: () => __webpack_exports__AlbertForMaskedLM,
    AlbertForQuestionAnswering: () => __webpack_exports__AlbertForQuestionAnswering,
    AlbertForSequenceClassification: () => __webpack_exports__AlbertForSequenceClassification,
    AlbertModel: () => __webpack_exports__AlbertModel,
    AlbertPreTrainedModel: () => __webpack_exports__AlbertPreTrainedModel,
    AlbertTokenizer: () => __webpack_exports__AlbertTokenizer,
    AudioClassificationPipeline: () => __webpack_exports__AudioClassificationPipeline,
    AutoConfig: () => __webpack_exports__AutoConfig,
    AutoModel: () => __webpack_exports__AutoModel,
    AutoModelForAudioClassification: () => __webpack_exports__AutoModelForAudioClassification,
    AutoModelForAudioFrameClassification: () => __webpack_exports__AutoModelForAudioFrameClassification,
    AutoModelForCTC: () => __webpack_exports__AutoModelForCTC,
    AutoModelForCausalLM: () => __webpack_exports__AutoModelForCausalLM,
    AutoModelForDepthEstimation: () => __webpack_exports__AutoModelForDepthEstimation,
    AutoModelForDocumentQuestionAnswering: () => __webpack_exports__AutoModelForDocumentQuestionAnswering,
    AutoModelForImageClassification: () => __webpack_exports__AutoModelForImageClassification,
    AutoModelForImageFeatureExtraction: () => __webpack_exports__AutoModelForImageFeatureExtraction,
    AutoModelForImageMatting: () => __webpack_exports__AutoModelForImageMatting,
    AutoModelForImageSegmentation: () => __webpack_exports__AutoModelForImageSegmentation,
    AutoModelForImageToImage: () => __webpack_exports__AutoModelForImageToImage,
    AutoModelForMaskGeneration: () => __webpack_exports__AutoModelForMaskGeneration,
    AutoModelForMaskedLM: () => __webpack_exports__AutoModelForMaskedLM,
    AutoModelForObjectDetection: () => __webpack_exports__AutoModelForObjectDetection,
    AutoModelForQuestionAnswering: () => __webpack_exports__AutoModelForQuestionAnswering,
    AutoModelForSemanticSegmentation: () => __webpack_exports__AutoModelForSemanticSegmentation,
    AutoModelForSeq2SeqLM: () => __webpack_exports__AutoModelForSeq2SeqLM,
    AutoModelForSequenceClassification: () => __webpack_exports__AutoModelForSequenceClassification,
    AutoModelForSpeechSeq2Seq: () => __webpack_exports__AutoModelForSpeechSeq2Seq,
    AutoModelForTextToSpectrogram: () => __webpack_exports__AutoModelForTextToSpectrogram,
    AutoModelForTextToWaveform: () => __webpack_exports__AutoModelForTextToWaveform,
    AutoModelForTokenClassification: () => __webpack_exports__AutoModelForTokenClassification,
    AutoModelForVision2Seq: () => __webpack_exports__AutoModelForVision2Seq,
    AutoModelForXVector: () => __webpack_exports__AutoModelForXVector,
    AutoModelForZeroShotObjectDetection: () => __webpack_exports__AutoModelForZeroShotObjectDetection,
    AutoProcessor: () => __webpack_exports__AutoProcessor,
    AutoTokenizer: () => __webpack_exports__AutoTokenizer,
    AutomaticSpeechRecognitionPipeline: () => __webpack_exports__AutomaticSpeechRecognitionPipeline,
    BartForConditionalGeneration: () => __webpack_exports__BartForConditionalGeneration,
    BartForSequenceClassification: () => __webpack_exports__BartForSequenceClassification,
    BartModel: () => __webpack_exports__BartModel,
    BartPretrainedModel: () => __webpack_exports__BartPretrainedModel,
    BartTokenizer: () => __webpack_exports__BartTokenizer,
    BaseModelOutput: () => __webpack_exports__BaseModelOutput,
    BeitFeatureExtractor: () => __webpack_exports__BeitFeatureExtractor,
    BeitForImageClassification: () => __webpack_exports__BeitForImageClassification,
    BeitModel: () => __webpack_exports__BeitModel,
    BeitPreTrainedModel: () => __webpack_exports__BeitPreTrainedModel,
    BertForMaskedLM: () => __webpack_exports__BertForMaskedLM,
    BertForQuestionAnswering: () => __webpack_exports__BertForQuestionAnswering,
    BertForSequenceClassification: () => __webpack_exports__BertForSequenceClassification,
    BertForTokenClassification: () => __webpack_exports__BertForTokenClassification,
    BertModel: () => __webpack_exports__BertModel,
    BertPreTrainedModel: () => __webpack_exports__BertPreTrainedModel,
    BertTokenizer: () => __webpack_exports__BertTokenizer,
    BitImageProcessor: () => __webpack_exports__BitImageProcessor,
    BlenderbotForConditionalGeneration: () => __webpack_exports__BlenderbotForConditionalGeneration,
    BlenderbotModel: () => __webpack_exports__BlenderbotModel,
    BlenderbotPreTrainedModel: () => __webpack_exports__BlenderbotPreTrainedModel,
    BlenderbotSmallForConditionalGeneration: () => __webpack_exports__BlenderbotSmallForConditionalGeneration,
    BlenderbotSmallModel: () => __webpack_exports__BlenderbotSmallModel,
    BlenderbotSmallPreTrainedModel: () => __webpack_exports__BlenderbotSmallPreTrainedModel,
    BlenderbotSmallTokenizer: () => __webpack_exports__BlenderbotSmallTokenizer,
    BlenderbotTokenizer: () => __webpack_exports__BlenderbotTokenizer,
    BloomForCausalLM: () => __webpack_exports__BloomForCausalLM,
    BloomModel: () => __webpack_exports__BloomModel,
    BloomPreTrainedModel: () => __webpack_exports__BloomPreTrainedModel,
    BloomTokenizer: () => __webpack_exports__BloomTokenizer,
    CLIPFeatureExtractor: () => __webpack_exports__CLIPFeatureExtractor,
    CLIPModel: () => __webpack_exports__CLIPModel,
    CLIPPreTrainedModel: () => __webpack_exports__CLIPPreTrainedModel,
    CLIPSegForImageSegmentation: () => __webpack_exports__CLIPSegForImageSegmentation,
    CLIPSegModel: () => __webpack_exports__CLIPSegModel,
    CLIPSegPreTrainedModel: () => __webpack_exports__CLIPSegPreTrainedModel,
    CLIPTextModelWithProjection: () => __webpack_exports__CLIPTextModelWithProjection,
    CLIPTokenizer: () => __webpack_exports__CLIPTokenizer,
    CLIPVisionModelWithProjection: () => __webpack_exports__CLIPVisionModelWithProjection,
    CamembertForMaskedLM: () => __webpack_exports__CamembertForMaskedLM,
    CamembertForQuestionAnswering: () => __webpack_exports__CamembertForQuestionAnswering,
    CamembertForSequenceClassification: () => __webpack_exports__CamembertForSequenceClassification,
    CamembertForTokenClassification: () => __webpack_exports__CamembertForTokenClassification,
    CamembertModel: () => __webpack_exports__CamembertModel,
    CamembertPreTrainedModel: () => __webpack_exports__CamembertPreTrainedModel,
    CamembertTokenizer: () => __webpack_exports__CamembertTokenizer,
    CausalLMOutput: () => __webpack_exports__CausalLMOutput,
    CausalLMOutputWithPast: () => __webpack_exports__CausalLMOutputWithPast,
    ChineseCLIPFeatureExtractor: () => __webpack_exports__ChineseCLIPFeatureExtractor,
    ChineseCLIPModel: () => __webpack_exports__ChineseCLIPModel,
    ChineseCLIPPreTrainedModel: () => __webpack_exports__ChineseCLIPPreTrainedModel,
    ClapAudioModelWithProjection: () => __webpack_exports__ClapAudioModelWithProjection,
    ClapFeatureExtractor: () => __webpack_exports__ClapFeatureExtractor,
    ClapModel: () => __webpack_exports__ClapModel,
    ClapPreTrainedModel: () => __webpack_exports__ClapPreTrainedModel,
    ClapTextModelWithProjection: () => __webpack_exports__ClapTextModelWithProjection,
    CodeGenForCausalLM: () => __webpack_exports__CodeGenForCausalLM,
    CodeGenModel: () => __webpack_exports__CodeGenModel,
    CodeGenPreTrainedModel: () => __webpack_exports__CodeGenPreTrainedModel,
    CodeGenTokenizer: () => __webpack_exports__CodeGenTokenizer,
    CodeLlamaTokenizer: () => __webpack_exports__CodeLlamaTokenizer,
    CohereTokenizer: () => __webpack_exports__CohereTokenizer,
    ConvBertForMaskedLM: () => __webpack_exports__ConvBertForMaskedLM,
    ConvBertForQuestionAnswering: () => __webpack_exports__ConvBertForQuestionAnswering,
    ConvBertForSequenceClassification: () => __webpack_exports__ConvBertForSequenceClassification,
    ConvBertForTokenClassification: () => __webpack_exports__ConvBertForTokenClassification,
    ConvBertModel: () => __webpack_exports__ConvBertModel,
    ConvBertPreTrainedModel: () => __webpack_exports__ConvBertPreTrainedModel,
    ConvBertTokenizer: () => __webpack_exports__ConvBertTokenizer,
    ConvNextFeatureExtractor: () => __webpack_exports__ConvNextFeatureExtractor,
    ConvNextForImageClassification: () => __webpack_exports__ConvNextForImageClassification,
    ConvNextImageProcessor: () => __webpack_exports__ConvNextImageProcessor,
    ConvNextModel: () => __webpack_exports__ConvNextModel,
    ConvNextPreTrainedModel: () => __webpack_exports__ConvNextPreTrainedModel,
    ConvNextV2ForImageClassification: () => __webpack_exports__ConvNextV2ForImageClassification,
    ConvNextV2Model: () => __webpack_exports__ConvNextV2Model,
    ConvNextV2PreTrainedModel: () => __webpack_exports__ConvNextV2PreTrainedModel,
    DPTFeatureExtractor: () => __webpack_exports__DPTFeatureExtractor,
    DPTForDepthEstimation: () => __webpack_exports__DPTForDepthEstimation,
    DPTImageProcessor: () => __webpack_exports__DPTImageProcessor,
    DPTModel: () => __webpack_exports__DPTModel,
    DPTPreTrainedModel: () => __webpack_exports__DPTPreTrainedModel,
    DebertaForMaskedLM: () => __webpack_exports__DebertaForMaskedLM,
    DebertaForQuestionAnswering: () => __webpack_exports__DebertaForQuestionAnswering,
    DebertaForSequenceClassification: () => __webpack_exports__DebertaForSequenceClassification,
    DebertaForTokenClassification: () => __webpack_exports__DebertaForTokenClassification,
    DebertaModel: () => __webpack_exports__DebertaModel,
    DebertaPreTrainedModel: () => __webpack_exports__DebertaPreTrainedModel,
    DebertaTokenizer: () => __webpack_exports__DebertaTokenizer,
    DebertaV2ForMaskedLM: () => __webpack_exports__DebertaV2ForMaskedLM,
    DebertaV2ForQuestionAnswering: () => __webpack_exports__DebertaV2ForQuestionAnswering,
    DebertaV2ForSequenceClassification: () => __webpack_exports__DebertaV2ForSequenceClassification,
    DebertaV2ForTokenClassification: () => __webpack_exports__DebertaV2ForTokenClassification,
    DebertaV2Model: () => __webpack_exports__DebertaV2Model,
    DebertaV2PreTrainedModel: () => __webpack_exports__DebertaV2PreTrainedModel,
    DebertaV2Tokenizer: () => __webpack_exports__DebertaV2Tokenizer,
    DeiTFeatureExtractor: () => __webpack_exports__DeiTFeatureExtractor,
    DeiTForImageClassification: () => __webpack_exports__DeiTForImageClassification,
    DeiTModel: () => __webpack_exports__DeiTModel,
    DeiTPreTrainedModel: () => __webpack_exports__DeiTPreTrainedModel,
    DepthAnythingForDepthEstimation: () => __webpack_exports__DepthAnythingForDepthEstimation,
    DepthAnythingPreTrainedModel: () => __webpack_exports__DepthAnythingPreTrainedModel,
    DepthEstimationPipeline: () => __webpack_exports__DepthEstimationPipeline,
    DetrFeatureExtractor: () => __webpack_exports__DetrFeatureExtractor,
    DetrForObjectDetection: () => __webpack_exports__DetrForObjectDetection,
    DetrForSegmentation: () => __webpack_exports__DetrForSegmentation,
    DetrModel: () => __webpack_exports__DetrModel,
    DetrObjectDetectionOutput: () => __webpack_exports__DetrObjectDetectionOutput,
    DetrPreTrainedModel: () => __webpack_exports__DetrPreTrainedModel,
    DetrSegmentationOutput: () => __webpack_exports__DetrSegmentationOutput,
    Dinov2ForImageClassification: () => __webpack_exports__Dinov2ForImageClassification,
    Dinov2Model: () => __webpack_exports__Dinov2Model,
    Dinov2PreTrainedModel: () => __webpack_exports__Dinov2PreTrainedModel,
    DistilBertForMaskedLM: () => __webpack_exports__DistilBertForMaskedLM,
    DistilBertForQuestionAnswering: () => __webpack_exports__DistilBertForQuestionAnswering,
    DistilBertForSequenceClassification: () => __webpack_exports__DistilBertForSequenceClassification,
    DistilBertForTokenClassification: () => __webpack_exports__DistilBertForTokenClassification,
    DistilBertModel: () => __webpack_exports__DistilBertModel,
    DistilBertPreTrainedModel: () => __webpack_exports__DistilBertPreTrainedModel,
    DistilBertTokenizer: () => __webpack_exports__DistilBertTokenizer,
    DocumentQuestionAnsweringPipeline: () => __webpack_exports__DocumentQuestionAnsweringPipeline,
    DonutFeatureExtractor: () => __webpack_exports__DonutFeatureExtractor,
    DonutSwinModel: () => __webpack_exports__DonutSwinModel,
    DonutSwinPreTrainedModel: () => __webpack_exports__DonutSwinPreTrainedModel,
    EfficientNetForImageClassification: () => __webpack_exports__EfficientNetForImageClassification,
    EfficientNetImageProcessor: () => __webpack_exports__EfficientNetImageProcessor,
    EfficientNetModel: () => __webpack_exports__EfficientNetModel,
    EfficientNetPreTrainedModel: () => __webpack_exports__EfficientNetPreTrainedModel,
    ElectraForMaskedLM: () => __webpack_exports__ElectraForMaskedLM,
    ElectraForQuestionAnswering: () => __webpack_exports__ElectraForQuestionAnswering,
    ElectraForSequenceClassification: () => __webpack_exports__ElectraForSequenceClassification,
    ElectraForTokenClassification: () => __webpack_exports__ElectraForTokenClassification,
    ElectraModel: () => __webpack_exports__ElectraModel,
    ElectraPreTrainedModel: () => __webpack_exports__ElectraPreTrainedModel,
    ElectraTokenizer: () => __webpack_exports__ElectraTokenizer,
    EsmForMaskedLM: () => __webpack_exports__EsmForMaskedLM,
    EsmForSequenceClassification: () => __webpack_exports__EsmForSequenceClassification,
    EsmForTokenClassification: () => __webpack_exports__EsmForTokenClassification,
    EsmModel: () => __webpack_exports__EsmModel,
    EsmPreTrainedModel: () => __webpack_exports__EsmPreTrainedModel,
    EsmTokenizer: () => __webpack_exports__EsmTokenizer,
    FFT: () => __webpack_exports__FFT,
    FalconForCausalLM: () => __webpack_exports__FalconForCausalLM,
    FalconModel: () => __webpack_exports__FalconModel,
    FalconPreTrainedModel: () => __webpack_exports__FalconPreTrainedModel,
    FalconTokenizer: () => __webpack_exports__FalconTokenizer,
    FeatureExtractionPipeline: () => __webpack_exports__FeatureExtractionPipeline,
    FeatureExtractor: () => __webpack_exports__FeatureExtractor,
    FillMaskPipeline: () => __webpack_exports__FillMaskPipeline,
    GLPNFeatureExtractor: () => __webpack_exports__GLPNFeatureExtractor,
    GLPNForDepthEstimation: () => __webpack_exports__GLPNForDepthEstimation,
    GLPNModel: () => __webpack_exports__GLPNModel,
    GLPNPreTrainedModel: () => __webpack_exports__GLPNPreTrainedModel,
    GPT2LMHeadModel: () => __webpack_exports__GPT2LMHeadModel,
    GPT2Model: () => __webpack_exports__GPT2Model,
    GPT2PreTrainedModel: () => __webpack_exports__GPT2PreTrainedModel,
    GPT2Tokenizer: () => __webpack_exports__GPT2Tokenizer,
    GPTBigCodeForCausalLM: () => __webpack_exports__GPTBigCodeForCausalLM,
    GPTBigCodeModel: () => __webpack_exports__GPTBigCodeModel,
    GPTBigCodePreTrainedModel: () => __webpack_exports__GPTBigCodePreTrainedModel,
    GPTJForCausalLM: () => __webpack_exports__GPTJForCausalLM,
    GPTJModel: () => __webpack_exports__GPTJModel,
    GPTJPreTrainedModel: () => __webpack_exports__GPTJPreTrainedModel,
    GPTNeoForCausalLM: () => __webpack_exports__GPTNeoForCausalLM,
    GPTNeoModel: () => __webpack_exports__GPTNeoModel,
    GPTNeoPreTrainedModel: () => __webpack_exports__GPTNeoPreTrainedModel,
    GPTNeoXForCausalLM: () => __webpack_exports__GPTNeoXForCausalLM,
    GPTNeoXModel: () => __webpack_exports__GPTNeoXModel,
    GPTNeoXPreTrainedModel: () => __webpack_exports__GPTNeoXPreTrainedModel,
    GPTNeoXTokenizer: () => __webpack_exports__GPTNeoXTokenizer,
    GemmaTokenizer: () => __webpack_exports__GemmaTokenizer,
    Grok1Tokenizer: () => __webpack_exports__Grok1Tokenizer,
    HerbertTokenizer: () => __webpack_exports__HerbertTokenizer,
    HubertForCTC: () => __webpack_exports__HubertForCTC,
    HubertForSequenceClassification: () => __webpack_exports__HubertForSequenceClassification,
    HubertModel: () => __webpack_exports__HubertModel,
    HubertPreTrainedModel: () => __webpack_exports__HubertPreTrainedModel,
    ImageClassificationPipeline: () => __webpack_exports__ImageClassificationPipeline,
    ImageFeatureExtractionPipeline: () => __webpack_exports__ImageFeatureExtractionPipeline,
    ImageFeatureExtractor: () => __webpack_exports__ImageFeatureExtractor,
    ImageMattingOutput: () => __webpack_exports__ImageMattingOutput,
    ImageSegmentationPipeline: () => __webpack_exports__ImageSegmentationPipeline,
    ImageToImagePipeline: () => __webpack_exports__ImageToImagePipeline,
    ImageToTextPipeline: () => __webpack_exports__ImageToTextPipeline,
    LlamaForCausalLM: () => __webpack_exports__LlamaForCausalLM,
    LlamaModel: () => __webpack_exports__LlamaModel,
    LlamaPreTrainedModel: () => __webpack_exports__LlamaPreTrainedModel,
    LlamaTokenizer: () => __webpack_exports__LlamaTokenizer,
    LongT5ForConditionalGeneration: () => __webpack_exports__LongT5ForConditionalGeneration,
    LongT5Model: () => __webpack_exports__LongT5Model,
    LongT5PreTrainedModel: () => __webpack_exports__LongT5PreTrainedModel,
    M2M100ForConditionalGeneration: () => __webpack_exports__M2M100ForConditionalGeneration,
    M2M100Model: () => __webpack_exports__M2M100Model,
    M2M100PreTrainedModel: () => __webpack_exports__M2M100PreTrainedModel,
    M2M100Tokenizer: () => __webpack_exports__M2M100Tokenizer,
    MBart50Tokenizer: () => __webpack_exports__MBart50Tokenizer,
    MBartForCausalLM: () => __webpack_exports__MBartForCausalLM,
    MBartForConditionalGeneration: () => __webpack_exports__MBartForConditionalGeneration,
    MBartForSequenceClassification: () => __webpack_exports__MBartForSequenceClassification,
    MBartModel: () => __webpack_exports__MBartModel,
    MBartPreTrainedModel: () => __webpack_exports__MBartPreTrainedModel,
    MBartTokenizer: () => __webpack_exports__MBartTokenizer,
    MPNetForMaskedLM: () => __webpack_exports__MPNetForMaskedLM,
    MPNetForQuestionAnswering: () => __webpack_exports__MPNetForQuestionAnswering,
    MPNetForSequenceClassification: () => __webpack_exports__MPNetForSequenceClassification,
    MPNetForTokenClassification: () => __webpack_exports__MPNetForTokenClassification,
    MPNetModel: () => __webpack_exports__MPNetModel,
    MPNetPreTrainedModel: () => __webpack_exports__MPNetPreTrainedModel,
    MPNetTokenizer: () => __webpack_exports__MPNetTokenizer,
    MT5ForConditionalGeneration: () => __webpack_exports__MT5ForConditionalGeneration,
    MT5Model: () => __webpack_exports__MT5Model,
    MT5PreTrainedModel: () => __webpack_exports__MT5PreTrainedModel,
    MarianMTModel: () => __webpack_exports__MarianMTModel,
    MarianModel: () => __webpack_exports__MarianModel,
    MarianPreTrainedModel: () => __webpack_exports__MarianPreTrainedModel,
    MarianTokenizer: () => __webpack_exports__MarianTokenizer,
    MaskedLMOutput: () => __webpack_exports__MaskedLMOutput,
    MistralForCausalLM: () => __webpack_exports__MistralForCausalLM,
    MistralModel: () => __webpack_exports__MistralModel,
    MistralPreTrainedModel: () => __webpack_exports__MistralPreTrainedModel,
    MobileBertForMaskedLM: () => __webpack_exports__MobileBertForMaskedLM,
    MobileBertForQuestionAnswering: () => __webpack_exports__MobileBertForQuestionAnswering,
    MobileBertForSequenceClassification: () => __webpack_exports__MobileBertForSequenceClassification,
    MobileBertModel: () => __webpack_exports__MobileBertModel,
    MobileBertPreTrainedModel: () => __webpack_exports__MobileBertPreTrainedModel,
    MobileBertTokenizer: () => __webpack_exports__MobileBertTokenizer,
    MobileViTFeatureExtractor: () => __webpack_exports__MobileViTFeatureExtractor,
    MobileViTForImageClassification: () => __webpack_exports__MobileViTForImageClassification,
    MobileViTModel: () => __webpack_exports__MobileViTModel,
    MobileViTPreTrainedModel: () => __webpack_exports__MobileViTPreTrainedModel,
    ModelOutput: () => __webpack_exports__ModelOutput,
    MptForCausalLM: () => __webpack_exports__MptForCausalLM,
    MptModel: () => __webpack_exports__MptModel,
    MptPreTrainedModel: () => __webpack_exports__MptPreTrainedModel,
    NllbTokenizer: () => __webpack_exports__NllbTokenizer,
    NomicBertModel: () => __webpack_exports__NomicBertModel,
    NomicBertPreTrainedModel: () => __webpack_exports__NomicBertPreTrainedModel,
    NougatImageProcessor: () => __webpack_exports__NougatImageProcessor,
    NougatTokenizer: () => __webpack_exports__NougatTokenizer,
    OPTForCausalLM: () => __webpack_exports__OPTForCausalLM,
    OPTModel: () => __webpack_exports__OPTModel,
    OPTPreTrainedModel: () => __webpack_exports__OPTPreTrainedModel,
    ObjectDetectionPipeline: () => __webpack_exports__ObjectDetectionPipeline,
    OwlViTFeatureExtractor: () => __webpack_exports__OwlViTFeatureExtractor,
    OwlViTForObjectDetection: () => __webpack_exports__OwlViTForObjectDetection,
    OwlViTModel: () => __webpack_exports__OwlViTModel,
    OwlViTPreTrainedModel: () => __webpack_exports__OwlViTPreTrainedModel,
    OwlViTProcessor: () => __webpack_exports__OwlViTProcessor,
    Owlv2ForObjectDetection: () => __webpack_exports__Owlv2ForObjectDetection,
    Owlv2ImageProcessor: () => __webpack_exports__Owlv2ImageProcessor,
    Owlv2Model: () => __webpack_exports__Owlv2Model,
    Owlv2PreTrainedModel: () => __webpack_exports__Owlv2PreTrainedModel,
    PhiForCausalLM: () => __webpack_exports__PhiForCausalLM,
    PhiModel: () => __webpack_exports__PhiModel,
    PhiPreTrainedModel: () => __webpack_exports__PhiPreTrainedModel,
    Pipeline: () => __webpack_exports__Pipeline,
    PreTrainedModel: () => __webpack_exports__PreTrainedModel,
    PreTrainedTokenizer: () => __webpack_exports__PreTrainedTokenizer,
    PretrainedConfig: () => __webpack_exports__PretrainedConfig,
    PretrainedMixin: () => __webpack_exports__PretrainedMixin,
    Processor: () => __webpack_exports__Processor,
    QuestionAnsweringModelOutput: () => __webpack_exports__QuestionAnsweringModelOutput,
    QuestionAnsweringPipeline: () => __webpack_exports__QuestionAnsweringPipeline,
    Qwen2ForCausalLM: () => __webpack_exports__Qwen2ForCausalLM,
    Qwen2Model: () => __webpack_exports__Qwen2Model,
    Qwen2PreTrainedModel: () => __webpack_exports__Qwen2PreTrainedModel,
    Qwen2Tokenizer: () => __webpack_exports__Qwen2Tokenizer,
    RawImage: () => __webpack_exports__RawImage,
    ResNetForImageClassification: () => __webpack_exports__ResNetForImageClassification,
    ResNetModel: () => __webpack_exports__ResNetModel,
    ResNetPreTrainedModel: () => __webpack_exports__ResNetPreTrainedModel,
    RoFormerForMaskedLM: () => __webpack_exports__RoFormerForMaskedLM,
    RoFormerForQuestionAnswering: () => __webpack_exports__RoFormerForQuestionAnswering,
    RoFormerForSequenceClassification: () => __webpack_exports__RoFormerForSequenceClassification,
    RoFormerForTokenClassification: () => __webpack_exports__RoFormerForTokenClassification,
    RoFormerModel: () => __webpack_exports__RoFormerModel,
    RoFormerPreTrainedModel: () => __webpack_exports__RoFormerPreTrainedModel,
    RoFormerTokenizer: () => __webpack_exports__RoFormerTokenizer,
    RobertaForMaskedLM: () => __webpack_exports__RobertaForMaskedLM,
    RobertaForQuestionAnswering: () => __webpack_exports__RobertaForQuestionAnswering,
    RobertaForSequenceClassification: () => __webpack_exports__RobertaForSequenceClassification,
    RobertaForTokenClassification: () => __webpack_exports__RobertaForTokenClassification,
    RobertaModel: () => __webpack_exports__RobertaModel,
    RobertaPreTrainedModel: () => __webpack_exports__RobertaPreTrainedModel,
    RobertaTokenizer: () => __webpack_exports__RobertaTokenizer,
    SamImageProcessor: () => __webpack_exports__SamImageProcessor,
    SamImageSegmentationOutput: () => __webpack_exports__SamImageSegmentationOutput,
    SamModel: () => __webpack_exports__SamModel,
    SamPreTrainedModel: () => __webpack_exports__SamPreTrainedModel,
    SamProcessor: () => __webpack_exports__SamProcessor,
    SeamlessM4TFeatureExtractor: () => __webpack_exports__SeamlessM4TFeatureExtractor,
    SegformerFeatureExtractor: () => __webpack_exports__SegformerFeatureExtractor,
    SegformerForImageClassification: () => __webpack_exports__SegformerForImageClassification,
    SegformerForSemanticSegmentation: () => __webpack_exports__SegformerForSemanticSegmentation,
    SegformerModel: () => __webpack_exports__SegformerModel,
    SegformerPreTrainedModel: () => __webpack_exports__SegformerPreTrainedModel,
    Seq2SeqLMOutput: () => __webpack_exports__Seq2SeqLMOutput,
    SequenceClassifierOutput: () => __webpack_exports__SequenceClassifierOutput,
    SiglipImageProcessor: () => __webpack_exports__SiglipImageProcessor,
    SiglipModel: () => __webpack_exports__SiglipModel,
    SiglipPreTrainedModel: () => __webpack_exports__SiglipPreTrainedModel,
    SiglipTextModel: () => __webpack_exports__SiglipTextModel,
    SiglipTokenizer: () => __webpack_exports__SiglipTokenizer,
    SiglipVisionModel: () => __webpack_exports__SiglipVisionModel,
    SpeechT5FeatureExtractor: () => __webpack_exports__SpeechT5FeatureExtractor,
    SpeechT5ForSpeechToText: () => __webpack_exports__SpeechT5ForSpeechToText,
    SpeechT5ForTextToSpeech: () => __webpack_exports__SpeechT5ForTextToSpeech,
    SpeechT5HifiGan: () => __webpack_exports__SpeechT5HifiGan,
    SpeechT5Model: () => __webpack_exports__SpeechT5Model,
    SpeechT5PreTrainedModel: () => __webpack_exports__SpeechT5PreTrainedModel,
    SpeechT5Processor: () => __webpack_exports__SpeechT5Processor,
    SpeechT5Tokenizer: () => __webpack_exports__SpeechT5Tokenizer,
    SqueezeBertForMaskedLM: () => __webpack_exports__SqueezeBertForMaskedLM,
    SqueezeBertForQuestionAnswering: () => __webpack_exports__SqueezeBertForQuestionAnswering,
    SqueezeBertForSequenceClassification: () => __webpack_exports__SqueezeBertForSequenceClassification,
    SqueezeBertModel: () => __webpack_exports__SqueezeBertModel,
    SqueezeBertPreTrainedModel: () => __webpack_exports__SqueezeBertPreTrainedModel,
    SqueezeBertTokenizer: () => __webpack_exports__SqueezeBertTokenizer,
    StableLmForCausalLM: () => __webpack_exports__StableLmForCausalLM,
    StableLmModel: () => __webpack_exports__StableLmModel,
    StableLmPreTrainedModel: () => __webpack_exports__StableLmPreTrainedModel,
    Starcoder2ForCausalLM: () => __webpack_exports__Starcoder2ForCausalLM,
    Starcoder2Model: () => __webpack_exports__Starcoder2Model,
    Starcoder2PreTrainedModel: () => __webpack_exports__Starcoder2PreTrainedModel,
    SummarizationPipeline: () => __webpack_exports__SummarizationPipeline,
    Swin2SRForImageSuperResolution: () => __webpack_exports__Swin2SRForImageSuperResolution,
    Swin2SRImageProcessor: () => __webpack_exports__Swin2SRImageProcessor,
    Swin2SRModel: () => __webpack_exports__Swin2SRModel,
    Swin2SRPreTrainedModel: () => __webpack_exports__Swin2SRPreTrainedModel,
    SwinForImageClassification: () => __webpack_exports__SwinForImageClassification,
    SwinModel: () => __webpack_exports__SwinModel,
    SwinPreTrainedModel: () => __webpack_exports__SwinPreTrainedModel,
    T5ForConditionalGeneration: () => __webpack_exports__T5ForConditionalGeneration,
    T5Model: () => __webpack_exports__T5Model,
    T5PreTrainedModel: () => __webpack_exports__T5PreTrainedModel,
    T5Tokenizer: () => __webpack_exports__T5Tokenizer,
    TableTransformerForObjectDetection: () => __webpack_exports__TableTransformerForObjectDetection,
    TableTransformerModel: () => __webpack_exports__TableTransformerModel,
    TableTransformerObjectDetectionOutput: () => __webpack_exports__TableTransformerObjectDetectionOutput,
    TableTransformerPreTrainedModel: () => __webpack_exports__TableTransformerPreTrainedModel,
    Tensor: () => __webpack_exports__Tensor,
    Text2TextGenerationPipeline: () => __webpack_exports__Text2TextGenerationPipeline,
    TextClassificationPipeline: () => __webpack_exports__TextClassificationPipeline,
    TextGenerationPipeline: () => __webpack_exports__TextGenerationPipeline,
    TextToAudioPipeline: () => __webpack_exports__TextToAudioPipeline,
    TokenClassificationPipeline: () => __webpack_exports__TokenClassificationPipeline,
    TokenClassifierOutput: () => __webpack_exports__TokenClassifierOutput,
    TokenizerModel: () => __webpack_exports__TokenizerModel,
    TrOCRForCausalLM: () => __webpack_exports__TrOCRForCausalLM,
    TrOCRPreTrainedModel: () => __webpack_exports__TrOCRPreTrainedModel,
    TranslationPipeline: () => __webpack_exports__TranslationPipeline,
    UniSpeechForCTC: () => __webpack_exports__UniSpeechForCTC,
    UniSpeechForSequenceClassification: () => __webpack_exports__UniSpeechForSequenceClassification,
    UniSpeechModel: () => __webpack_exports__UniSpeechModel,
    UniSpeechPreTrainedModel: () => __webpack_exports__UniSpeechPreTrainedModel,
    UniSpeechSatForAudioFrameClassification: () => __webpack_exports__UniSpeechSatForAudioFrameClassification,
    UniSpeechSatForCTC: () => __webpack_exports__UniSpeechSatForCTC,
    UniSpeechSatForSequenceClassification: () => __webpack_exports__UniSpeechSatForSequenceClassification,
    UniSpeechSatModel: () => __webpack_exports__UniSpeechSatModel,
    UniSpeechSatPreTrainedModel: () => __webpack_exports__UniSpeechSatPreTrainedModel,
    ViTFeatureExtractor: () => __webpack_exports__ViTFeatureExtractor,
    ViTForImageClassification: () => __webpack_exports__ViTForImageClassification,
    ViTImageProcessor: () => __webpack_exports__ViTImageProcessor,
    ViTModel: () => __webpack_exports__ViTModel,
    ViTPreTrainedModel: () => __webpack_exports__ViTPreTrainedModel,
    VisionEncoderDecoderModel: () => __webpack_exports__VisionEncoderDecoderModel,
    VitMatteForImageMatting: () => __webpack_exports__VitMatteForImageMatting,
    VitMatteImageProcessor: () => __webpack_exports__VitMatteImageProcessor,
    VitMattePreTrainedModel: () => __webpack_exports__VitMattePreTrainedModel,
    VitsModel: () => __webpack_exports__VitsModel,
    VitsModelOutput: () => __webpack_exports__VitsModelOutput,
    VitsPreTrainedModel: () => __webpack_exports__VitsPreTrainedModel,
    VitsTokenizer: () => __webpack_exports__VitsTokenizer,
    Wav2Vec2BertForCTC: () => __webpack_exports__Wav2Vec2BertForCTC,
    Wav2Vec2BertForSequenceClassification: () => __webpack_exports__Wav2Vec2BertForSequenceClassification,
    Wav2Vec2BertModel: () => __webpack_exports__Wav2Vec2BertModel,
    Wav2Vec2BertPreTrainedModel: () => __webpack_exports__Wav2Vec2BertPreTrainedModel,
    Wav2Vec2CTCTokenizer: () => __webpack_exports__Wav2Vec2CTCTokenizer,
    Wav2Vec2FeatureExtractor: () => __webpack_exports__Wav2Vec2FeatureExtractor,
    Wav2Vec2ForAudioFrameClassification: () => __webpack_exports__Wav2Vec2ForAudioFrameClassification,
    Wav2Vec2ForCTC: () => __webpack_exports__Wav2Vec2ForCTC,
    Wav2Vec2ForSequenceClassification: () => __webpack_exports__Wav2Vec2ForSequenceClassification,
    Wav2Vec2Model: () => __webpack_exports__Wav2Vec2Model,
    Wav2Vec2PreTrainedModel: () => __webpack_exports__Wav2Vec2PreTrainedModel,
    Wav2Vec2ProcessorWithLM: () => __webpack_exports__Wav2Vec2ProcessorWithLM,
    WavLMForAudioFrameClassification: () => __webpack_exports__WavLMForAudioFrameClassification,
    WavLMForCTC: () => __webpack_exports__WavLMForCTC,
    WavLMForSequenceClassification: () => __webpack_exports__WavLMForSequenceClassification,
    WavLMForXVector: () => __webpack_exports__WavLMForXVector,
    WavLMModel: () => __webpack_exports__WavLMModel,
    WavLMPreTrainedModel: () => __webpack_exports__WavLMPreTrainedModel,
    WhisperFeatureExtractor: () => __webpack_exports__WhisperFeatureExtractor,
    WhisperForConditionalGeneration: () => __webpack_exports__WhisperForConditionalGeneration,
    WhisperModel: () => __webpack_exports__WhisperModel,
    WhisperPreTrainedModel: () => __webpack_exports__WhisperPreTrainedModel,
    WhisperProcessor: () => __webpack_exports__WhisperProcessor,
    WhisperTokenizer: () => __webpack_exports__WhisperTokenizer,
    XLMForQuestionAnswering: () => __webpack_exports__XLMForQuestionAnswering,
    XLMForSequenceClassification: () => __webpack_exports__XLMForSequenceClassification,
    XLMForTokenClassification: () => __webpack_exports__XLMForTokenClassification,
    XLMModel: () => __webpack_exports__XLMModel,
    XLMPreTrainedModel: () => __webpack_exports__XLMPreTrainedModel,
    XLMRobertaForMaskedLM: () => __webpack_exports__XLMRobertaForMaskedLM,
    XLMRobertaForQuestionAnswering: () => __webpack_exports__XLMRobertaForQuestionAnswering,
    XLMRobertaForSequenceClassification: () => __webpack_exports__XLMRobertaForSequenceClassification,
    XLMRobertaForTokenClassification: () => __webpack_exports__XLMRobertaForTokenClassification,
    XLMRobertaModel: () => __webpack_exports__XLMRobertaModel,
    XLMRobertaPreTrainedModel: () => __webpack_exports__XLMRobertaPreTrainedModel,
    XLMRobertaTokenizer: () => __webpack_exports__XLMRobertaTokenizer,
    XLMTokenizer: () => __webpack_exports__XLMTokenizer,
    XLMWithLMHeadModel: () => __webpack_exports__XLMWithLMHeadModel,
    XVectorOutput: () => __webpack_exports__XVectorOutput,
    YolosFeatureExtractor: () => __webpack_exports__YolosFeatureExtractor,
    YolosForObjectDetection: () => __webpack_exports__YolosForObjectDetection,
    YolosModel: () => __webpack_exports__YolosModel,
    YolosObjectDetectionOutput: () => __webpack_exports__YolosObjectDetectionOutput,
    YolosPreTrainedModel: () => __webpack_exports__YolosPreTrainedModel,
    ZeroShotAudioClassificationPipeline: () => __webpack_exports__ZeroShotAudioClassificationPipeline,
    ZeroShotClassificationPipeline: () => __webpack_exports__ZeroShotClassificationPipeline,
    ZeroShotImageClassificationPipeline: () => __webpack_exports__ZeroShotImageClassificationPipeline,
    ZeroShotObjectDetectionPipeline: () => __webpack_exports__ZeroShotObjectDetectionPipeline,
    bankers_round: () => __webpack_exports__bankers_round,
    cat: () => __webpack_exports__cat,
    cos_sim: () => __webpack_exports__cos_sim,
    dot: () => __webpack_exports__dot,
    dynamicTimeWarping: () => __webpack_exports__dynamicTimeWarping,
    env: () => __webpack_exports__env,
    getTopItems: () => __webpack_exports__getTopItems,
    hanning: () => __webpack_exports__hanning,
    interpolate: () => __webpack_exports__interpolate,
    interpolate_data: () => __webpack_exports__interpolate_data,
    layer_norm: () => __webpack_exports__layer_norm,
    log_softmax: () => __webpack_exports__log_softmax,
    magnitude: () => __webpack_exports__magnitude,
    max: () => __webpack_exports__max,
    mean: () => __webpack_exports__mean,
    mean_pooling: () => __webpack_exports__mean_pooling,
    medianFilter: () => __webpack_exports__medianFilter,
    mel_filter_bank: () => __webpack_exports__mel_filter_bank,
    min: () => __webpack_exports__min,
    ones: () => __webpack_exports__ones,
    ones_like: () => __webpack_exports__ones_like,
    permute: () => __webpack_exports__permute,
    permute_data: () => __webpack_exports__permute_data,
    pipeline: () => __webpack_exports__pipeline,
    quantize_embeddings: () => __webpack_exports__quantize_embeddings,
    read_audio: () => __webpack_exports__read_audio,
    round: () => __webpack_exports__round,
    softmax: () => __webpack_exports__softmax,
    spectrogram: () => __webpack_exports__spectrogram,
    stack: () => __webpack_exports__stack,
    std_mean: () => __webpack_exports__std_mean,
    window_function: () => __webpack_exports__window_function
  });
  var __webpack_modules__ = { "./node_modules/onnxruntime-common/dist/lib/backend-impl.js": (
    /*!******************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/backend-impl.js ***!
      \******************************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { registerBackend: () => i, resolveBackend: () => s });
      const r = {}, o = [], i = (e3, t2, n2) => {
        if (!t2 || "function" != typeof t2.init || "function" != typeof t2.createSessionHandler) throw new TypeError("not a valid backend");
        {
          const i2 = r[e3];
          if (void 0 === i2) r[e3] = { backend: t2, priority: n2 };
          else {
            if (i2.priority > n2) return;
            if (i2.priority === n2 && i2.backend !== t2) throw new Error(`cannot register backend "${e3}" using priority ${n2}`);
          }
          if (n2 >= 0) {
            const t3 = o.indexOf(e3);
            -1 !== t3 && o.splice(t3, 1);
            for (let t4 = 0; t4 < o.length; t4++) if (r[o[t4]].priority <= n2) return void o.splice(t4, 0, e3);
            o.push(e3);
          }
        }
      }, s = async (e3) => {
        const t2 = 0 === e3.length ? o : e3, n2 = [];
        for (const e4 of t2) {
          const t3 = r[e4];
          if (t3) {
            if (t3.initialized) return t3.backend;
            if (t3.aborted) continue;
            const r2 = !!t3.initPromise;
            try {
              return r2 || (t3.initPromise = t3.backend.init()), await t3.initPromise, t3.initialized = true, t3.backend;
            } catch (o2) {
              r2 || n2.push({ name: e4, err: o2 }), t3.aborted = true;
            } finally {
              delete t3.initPromise;
            }
          }
        }
        throw new Error(`no available backend found. ERR: ${n2.map(((e4) => `[${e4.name}] ${e4.err}`)).join(", ")}`);
      };
    }
  ), "./node_modules/onnxruntime-common/dist/lib/backend.js": (
    /*!*************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/backend.js ***!
      \*************************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { registerBackend: () => r.registerBackend });
      var r = n(
        /*! ./backend-impl */
        "./node_modules/onnxruntime-common/dist/lib/backend-impl.js"
      );
    }
  ), "./node_modules/onnxruntime-common/dist/lib/env-impl.js": (
    /*!**************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/env-impl.js ***!
      \**************************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { EnvImpl: () => r });
      class r {
        constructor() {
          this.wasm = {}, this.webgl = {}, this.logLevelInternal = "warning";
        }
        set logLevel(e3) {
          if (void 0 !== e3) {
            if ("string" != typeof e3 || -1 === ["verbose", "info", "warning", "error", "fatal"].indexOf(e3)) throw new Error(`Unsupported logging level: ${e3}`);
            this.logLevelInternal = e3;
          }
        }
        get logLevel() {
          return this.logLevelInternal;
        }
      }
    }
  ), "./node_modules/onnxruntime-common/dist/lib/env.js": (
    /*!*********************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/env.js ***!
      \*********************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { env: () => r });
      const r = new (n(
        /*! ./env-impl */
        "./node_modules/onnxruntime-common/dist/lib/env-impl.js"
      )).EnvImpl();
    }
  ), "./node_modules/onnxruntime-common/dist/lib/index.js": (
    /*!***********************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/index.js ***!
      \***********************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { InferenceSession: () => i.InferenceSession, Tensor: () => s.Tensor, env: () => o.env, registerBackend: () => r.registerBackend });
      var r = n(
        /*! ./backend */
        "./node_modules/onnxruntime-common/dist/lib/backend.js"
      ), o = n(
        /*! ./env */
        "./node_modules/onnxruntime-common/dist/lib/env.js"
      ), i = n(
        /*! ./inference-session */
        "./node_modules/onnxruntime-common/dist/lib/inference-session.js"
      ), s = n(
        /*! ./tensor */
        "./node_modules/onnxruntime-common/dist/lib/tensor.js"
      );
      n(
        /*! ./onnx-value */
        "./node_modules/onnxruntime-common/dist/lib/onnx-value.js"
      );
    }
  ), "./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js": (
    /*!****************************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js ***!
      \****************************************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { InferenceSession: () => i });
      var r = n(
        /*! ./backend-impl */
        "./node_modules/onnxruntime-common/dist/lib/backend-impl.js"
      ), o = n(
        /*! ./tensor */
        "./node_modules/onnxruntime-common/dist/lib/tensor.js"
      );
      class i {
        constructor(e3) {
          this.handler = e3;
        }
        async run(e3, t2, n2) {
          const r2 = {};
          let i2 = {};
          if ("object" != typeof e3 || null === e3 || e3 instanceof o.Tensor || Array.isArray(e3)) throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          let s = true;
          if ("object" == typeof t2) {
            if (null === t2) throw new TypeError("Unexpected argument[1]: cannot be null.");
            if (t2 instanceof o.Tensor) throw new TypeError("'fetches' cannot be a Tensor");
            if (Array.isArray(t2)) {
              if (0 === t2.length) throw new TypeError("'fetches' cannot be an empty array.");
              s = false;
              for (const e4 of t2) {
                if ("string" != typeof e4) throw new TypeError("'fetches' must be a string array or an object.");
                if (-1 === this.outputNames.indexOf(e4)) throw new RangeError(`'fetches' contains invalid output name: ${e4}.`);
                r2[e4] = null;
              }
              if ("object" == typeof n2 && null !== n2) i2 = n2;
              else if (void 0 !== n2) throw new TypeError("'options' must be an object.");
            } else {
              let e4 = false;
              const a2 = Object.getOwnPropertyNames(t2);
              for (const n3 of this.outputNames) if (-1 !== a2.indexOf(n3)) {
                const i3 = t2[n3];
                (null === i3 || i3 instanceof o.Tensor) && (e4 = true, s = false, r2[n3] = i3);
              }
              if (e4) {
                if ("object" == typeof n2 && null !== n2) i2 = n2;
                else if (void 0 !== n2) throw new TypeError("'options' must be an object.");
              } else i2 = t2;
            }
          } else if (void 0 !== t2) throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          for (const t3 of this.inputNames) if (void 0 === e3[t3]) throw new Error(`input '${t3}' is missing in 'feeds'.`);
          if (s) for (const e4 of this.outputNames) r2[e4] = null;
          const a = await this.handler.run(e3, r2, i2), l = {};
          for (const e4 in a) Object.hasOwnProperty.call(a, e4) && (l[e4] = new o.Tensor(a[e4].type, a[e4].data, a[e4].dims));
          return l;
        }
        static async create(e3, t2, n2, o2) {
          let s, a = {};
          if ("string" == typeof e3) {
            if (s = e3, "object" == typeof t2 && null !== t2) a = t2;
            else if (void 0 !== t2) throw new TypeError("'options' must be an object.");
          } else if (e3 instanceof Uint8Array) {
            if (s = e3, "object" == typeof t2 && null !== t2) a = t2;
            else if (void 0 !== t2) throw new TypeError("'options' must be an object.");
          } else {
            if (!(e3 instanceof ArrayBuffer || "undefined" != typeof SharedArrayBuffer && e3 instanceof SharedArrayBuffer)) throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
            {
              const r2 = e3;
              let i2 = 0, l2 = e3.byteLength;
              if ("object" == typeof t2 && null !== t2) a = t2;
              else if ("number" == typeof t2) {
                if (i2 = t2, !Number.isSafeInteger(i2)) throw new RangeError("'byteOffset' must be an integer.");
                if (i2 < 0 || i2 >= r2.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${r2.byteLength}).`);
                if (l2 = e3.byteLength - i2, "number" == typeof n2) {
                  if (l2 = n2, !Number.isSafeInteger(l2)) throw new RangeError("'byteLength' must be an integer.");
                  if (l2 <= 0 || i2 + l2 > r2.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${r2.byteLength - i2}].`);
                  if ("object" == typeof o2 && null !== o2) a = o2;
                  else if (void 0 !== o2) throw new TypeError("'options' must be an object.");
                } else if (void 0 !== n2) throw new TypeError("'byteLength' must be a number.");
              } else if (void 0 !== t2) throw new TypeError("'options' must be an object.");
              s = new Uint8Array(r2, i2, l2);
            }
          }
          const l = (a.executionProviders || []).map(((e4) => "string" == typeof e4 ? e4 : e4.name)), c = await (0, r.resolveBackend)(l), u = await c.createSessionHandler(s, a);
          return new i(u);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
      }
    }
  ), "./node_modules/onnxruntime-common/dist/lib/inference-session.js": (
    /*!***********************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/inference-session.js ***!
      \***********************************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { InferenceSession: () => r });
      const r = n(
        /*! ./inference-session-impl */
        "./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js"
      ).InferenceSession;
    }
  ), "./node_modules/onnxruntime-common/dist/lib/onnx-value.js": (
    /*!****************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/onnx-value.js ***!
      \****************************************************************/
    (e2, t, n) => {
      n.r(t);
    }
  ), "./node_modules/onnxruntime-common/dist/lib/tensor-impl.js": (
    /*!*****************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/tensor-impl.js ***!
      \*****************************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { Tensor: () => a });
      const r = "undefined" != typeof BigInt64Array && "function" == typeof BigInt64Array.from, o = "undefined" != typeof BigUint64Array && "function" == typeof BigUint64Array.from, i = /* @__PURE__ */ new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]]), s = /* @__PURE__ */ new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]);
      r && (i.set("int64", BigInt64Array), s.set(BigInt64Array, "int64")), o && (i.set("uint64", BigUint64Array), s.set(BigUint64Array, "uint64"));
      class a {
        constructor(e3, t2, n2) {
          let r2, o2, a2;
          if ("string" == typeof e3) if (r2 = e3, a2 = n2, "string" === e3) {
            if (!Array.isArray(t2)) throw new TypeError("A string tensor's data must be a string array.");
            o2 = t2;
          } else {
            const n3 = i.get(e3);
            if (void 0 === n3) throw new TypeError(`Unsupported tensor type: ${e3}.`);
            if (Array.isArray(t2)) o2 = n3.from(t2);
            else {
              if (!(t2 instanceof n3)) throw new TypeError(`A ${r2} tensor's data must be type of ${n3}`);
              o2 = t2;
            }
          }
          else if (a2 = t2, Array.isArray(e3)) {
            if (0 === e3.length) throw new TypeError("Tensor type cannot be inferred from an empty array.");
            const t3 = typeof e3[0];
            if ("string" === t3) r2 = "string", o2 = e3;
            else {
              if ("boolean" !== t3) throw new TypeError(`Invalid element type of data array: ${t3}.`);
              r2 = "bool", o2 = Uint8Array.from(e3);
            }
          } else {
            const t3 = s.get(e3.constructor);
            if (void 0 === t3) throw new TypeError(`Unsupported type for tensor data: ${e3.constructor}.`);
            r2 = t3, o2 = e3;
          }
          if (void 0 === a2) a2 = [o2.length];
          else if (!Array.isArray(a2)) throw new TypeError("A tensor's dims must be a number array");
          const l = ((e4) => {
            let t3 = 1;
            for (let n3 = 0; n3 < e4.length; n3++) {
              const r3 = e4[n3];
              if ("number" != typeof r3 || !Number.isSafeInteger(r3)) throw new TypeError(`dims[${n3}] must be an integer, got: ${r3}`);
              if (r3 < 0) throw new RangeError(`dims[${n3}] must be a non-negative integer, got: ${r3}`);
              t3 *= r3;
            }
            return t3;
          })(a2);
          if (l !== o2.length) throw new Error(`Tensor's size(${l}) does not match data length(${o2.length}).`);
          this.dims = a2, this.type = r2, this.data = o2, this.size = l;
        }
        static bufferToTensor(e3, t2) {
          if (void 0 === e3) throw new Error("Image buffer must be defined");
          if (void 0 === t2.height || void 0 === t2.width) throw new Error("Image height and width must be defined");
          const { height: n2, width: r2 } = t2, o2 = t2.norm;
          let i2, s2;
          i2 = void 0 === o2 || void 0 === o2.mean ? 255 : o2.mean, s2 = void 0 === o2 || void 0 === o2.bias ? 0 : o2.bias;
          const l = void 0 !== t2.bitmapFormat ? t2.bitmapFormat : "RGBA", c = void 0 !== t2.tensorFormat && void 0 !== t2.tensorFormat ? t2.tensorFormat : "RGB", u = n2 * r2, p = "RGBA" === c ? new Float32Array(4 * u) : new Float32Array(3 * u);
          let d = 4, _ = 0, h = 1, f = 2, m = 3, g = 0, b = u, w = 2 * u, x = -1;
          "RGB" === l && (d = 3, _ = 0, h = 1, f = 2, m = -1), "RGBA" === c ? x = 3 * u : "RBG" === c ? (g = 0, w = u, b = 2 * u) : "BGR" === c && (w = 0, b = u, g = 2 * u);
          for (let t3 = 0; t3 < u; t3++, _ += d, f += d, h += d, m += d) p[g++] = (e3[_] + s2) / i2, p[b++] = (e3[h] + s2) / i2, p[w++] = (e3[f] + s2) / i2, -1 !== x && -1 !== m && (p[x++] = (e3[m] + s2) / i2);
          return new a("float32", p, "RGBA" === c ? [1, 4, n2, r2] : [1, 3, n2, r2]);
        }
        static async fromImage(e3, t2) {
          const n2 = "undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement, r2 = "undefined" != typeof ImageData && e3 instanceof ImageData, o2 = "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap, i2 = "undefined" != typeof String && (e3 instanceof String || "string" == typeof e3);
          let s2, l = {};
          if (n2) {
            const n3 = document.createElement("canvas"), r3 = n3.getContext("2d");
            if (null == r3) throw new Error("Can not access image data");
            {
              let o3 = e3.naturalHeight, i3 = e3.naturalWidth;
              if (void 0 !== t2 && void 0 !== t2.resizedHeight && void 0 !== t2.resizedWidth && (o3 = t2.resizedHeight, i3 = t2.resizedWidth), void 0 !== t2) {
                if (l = t2, void 0 !== t2.tensorFormat) throw new Error("Image input config format must be RGBA for HTMLImageElement");
                if (l.tensorFormat = "RGBA", void 0 !== t2.height && t2.height !== o3) throw new Error("Image input config height doesn't match HTMLImageElement height");
                if (l.height = o3, void 0 !== t2.width && t2.width !== i3) throw new Error("Image input config width doesn't match HTMLImageElement width");
                l.width = i3;
              } else l.tensorFormat = "RGBA", l.height = o3, l.width = i3;
              n3.width = i3, n3.height = o3, r3.drawImage(e3, 0, 0, i3, o3), s2 = r3.getImageData(0, 0, i3, o3).data;
            }
          } else {
            if (!r2) {
              if (o2) {
                if (void 0 === t2) throw new Error("Please provide image config with format for Imagebitmap");
                if (void 0 !== t2.bitmapFormat) throw new Error("Image input config format must be defined for ImageBitmap");
                const n3 = document.createElement("canvas").getContext("2d");
                if (null != n3) {
                  const r3 = e3.height, o3 = e3.width;
                  if (n3.drawImage(e3, 0, 0, o3, r3), s2 = n3.getImageData(0, 0, o3, r3).data, void 0 !== t2) {
                    if (void 0 !== t2.height && t2.height !== r3) throw new Error("Image input config height doesn't match ImageBitmap height");
                    if (l.height = r3, void 0 !== t2.width && t2.width !== o3) throw new Error("Image input config width doesn't match ImageBitmap width");
                    l.width = o3;
                  } else l.height = r3, l.width = o3;
                  return a.bufferToTensor(s2, l);
                }
                throw new Error("Can not access image data");
              }
              if (i2) return new Promise(((n3, r3) => {
                const o3 = document.createElement("canvas"), i3 = o3.getContext("2d");
                if (!e3 || !i3) return r3();
                const s3 = new Image();
                s3.crossOrigin = "Anonymous", s3.src = e3, s3.onload = () => {
                  o3.width = s3.width, o3.height = s3.height, i3.drawImage(s3, 0, 0, o3.width, o3.height);
                  const e4 = i3.getImageData(0, 0, o3.width, o3.height);
                  if (void 0 !== t2) {
                    if (void 0 !== t2.height && t2.height !== o3.height) throw new Error("Image input config height doesn't match ImageBitmap height");
                    if (l.height = o3.height, void 0 !== t2.width && t2.width !== o3.width) throw new Error("Image input config width doesn't match ImageBitmap width");
                    l.width = o3.width;
                  } else l.height = o3.height, l.width = o3.width;
                  n3(a.bufferToTensor(e4.data, l));
                };
              }));
              throw new Error("Input data provided is not supported - aborted tensor creation");
            }
            {
              const n3 = "RGBA";
              let r3, o3;
              if (void 0 !== t2 && void 0 !== t2.resizedWidth && void 0 !== t2.resizedHeight ? (r3 = t2.resizedHeight, o3 = t2.resizedWidth) : (r3 = e3.height, o3 = e3.width), void 0 !== t2) {
                if (l = t2, void 0 !== t2.bitmapFormat && t2.bitmapFormat !== n3) throw new Error("Image input config format must be RGBA for ImageData");
                l.bitmapFormat = "RGBA";
              } else l.bitmapFormat = "RGBA";
              if (l.height = r3, l.width = o3, void 0 !== t2) {
                const t3 = document.createElement("canvas");
                t3.width = o3, t3.height = r3;
                const n4 = t3.getContext("2d");
                if (null == n4) throw new Error("Can not access image data");
                n4.putImageData(e3, 0, 0), s2 = n4.getImageData(0, 0, o3, r3).data;
              } else s2 = e3.data;
            }
          }
          if (void 0 !== s2) return a.bufferToTensor(s2, l);
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        toImageData(e3) {
          var t2, n2;
          const r2 = document.createElement("canvas").getContext("2d");
          let o2;
          if (null == r2) throw new Error("Can not access image data");
          {
            const i2 = this.dims[3], s2 = this.dims[2], a2 = this.dims[1], l = void 0 !== e3 && void 0 !== e3.format ? e3.format : "RGB", c = void 0 !== e3 && void 0 !== (null === (t2 = e3.norm) || void 0 === t2 ? void 0 : t2.mean) ? e3.norm.mean : 255, u = void 0 !== e3 && void 0 !== (null === (n2 = e3.norm) || void 0 === n2 ? void 0 : n2.bias) ? e3.norm.bias : 0, p = s2 * i2;
            if (void 0 !== e3) {
              if (void 0 !== e3.height && e3.height !== s2) throw new Error("Image output config height doesn't match tensor height");
              if (void 0 !== e3.width && e3.width !== i2) throw new Error("Image output config width doesn't match tensor width");
              if (void 0 !== e3.format && 4 === a2 && "RGBA" !== e3.format || 3 === a2 && "RGB" !== e3.format && "BGR" !== e3.format) throw new Error("Tensor format doesn't match input tensor dims");
            }
            const d = 4;
            let _ = 0, h = 1, f = 2, m = 3, g = 0, b = p, w = 2 * p, x = -1;
            "RGBA" === l ? (g = 0, b = p, w = 2 * p, x = 3 * p) : "RGB" === l ? (g = 0, b = p, w = 2 * p) : "RBG" === l && (g = 0, w = p, b = 2 * p), o2 = r2.createImageData(i2, s2);
            for (let e4 = 0; e4 < s2 * i2; _ += d, h += d, f += d, m += d, e4++) o2.data[_] = (this.data[g++] - u) * c, o2.data[h] = (this.data[b++] - u) * c, o2.data[f] = (this.data[w++] - u) * c, o2.data[m] = -1 === x ? 255 : (this.data[x++] - u) * c;
          }
          return o2;
        }
        reshape(e3) {
          return new a(this.type, this.data, e3);
        }
      }
    }
  ), "./node_modules/onnxruntime-common/dist/lib/tensor.js": (
    /*!************************************************************!*\
      !*** ./node_modules/onnxruntime-common/dist/lib/tensor.js ***!
      \************************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { Tensor: () => r });
      const r = n(
        /*! ./tensor-impl */
        "./node_modules/onnxruntime-common/dist/lib/tensor-impl.js"
      ).Tensor;
    }
  ), "./node_modules/onnxruntime-web/dist/ort-web.min.js": (
    /*!**********************************************************!*\
      !*** ./node_modules/onnxruntime-web/dist/ort-web.min.js ***!
      \**********************************************************/
    (module, __unused_webpack_exports, __webpack_require__) => {
      var e;
      self, e = (__WEBPACK_EXTERNAL_MODULE__1670__) => (() => {
        var __webpack_modules__ = { 3474: (e2, t, n) => {
          var r, o = (r = (r = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(e3) {
            function t2() {
              return O.buffer != D && W(O.buffer), L;
            }
            function o2() {
              return O.buffer != D && W(O.buffer), $;
            }
            function i() {
              return O.buffer != D && W(O.buffer), N;
            }
            function s() {
              return O.buffer != D && W(O.buffer), B;
            }
            function a() {
              return O.buffer != D && W(O.buffer), z;
            }
            var l, c, u;
            e3 = e3 || {}, l || (l = void 0 !== e3 ? e3 : {}), l.ready = new Promise((function(e4, t3) {
              c = e4, u = t3;
            }));
            var p, d, _, h, f, m, g = Object.assign({}, l), b = "./this.program", w = (e4, t3) => {
              throw t3;
            }, x = "object" == typeof window, y = "function" == typeof importScripts, T = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, v = l.ENVIRONMENT_IS_PTHREAD || false, k = "";
            function M(e4) {
              return l.locateFile ? l.locateFile(e4, k) : k + e4;
            }
            if (T) {
              let t3;
              k = y ? n(908).dirname(k) + "/" : "//", m = () => {
                f || (h = n(1384), f = n(908));
              }, p = function(e4, t4) {
                return m(), e4 = f.normalize(e4), h.readFileSync(e4, t4 ? void 0 : "utf8");
              }, _ = (e4) => ((e4 = p(e4, true)).buffer || (e4 = new Uint8Array(e4)), e4), d = (e4, t4, n2) => {
                m(), e4 = f.normalize(e4), h.readFile(e4, (function(e5, r2) {
                  e5 ? n2(e5) : t4(r2.buffer);
                }));
              }, 1 < process.argv.length && (b = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", (function(e4) {
                if (!(e4 instanceof ce)) throw e4;
              })), process.on("unhandledRejection", (function(e4) {
                throw e4;
              })), w = (e4, t4) => {
                if (J()) throw process.exitCode = e4, t4;
                t4 instanceof ce || C("exiting due to exception: " + t4), process.exit(e4);
              }, l.inspect = function() {
                return "[Emscripten Module object]";
              };
              try {
                t3 = n(9925);
              } catch (e4) {
                throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), e4;
              }
              n.g.Worker = t3.Worker;
            } else (x || y) && (y ? k = self.location.href : "undefined" != typeof document && document.currentScript && (k = document.currentScript.src), r && (k = r), k = 0 !== k.indexOf("blob:") ? k.substr(0, k.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", T || (p = (e4) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e4, false), t3.send(null), t3.responseText;
            }, y && (_ = (e4) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e4, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), d = (e4, t3, n2) => {
              var r2 = new XMLHttpRequest();
              r2.open("GET", e4, true), r2.responseType = "arraybuffer", r2.onload = () => {
                200 == r2.status || 0 == r2.status && r2.response ? t3(r2.response) : n2();
              }, r2.onerror = n2, r2.send(null);
            }));
            T && "undefined" == typeof performance && (n.g.performance = n(6953).performance);
            var S = console.log.bind(console), P = console.warn.bind(console);
            T && (m(), S = (e4) => h.writeSync(1, e4 + "\n"), P = (e4) => h.writeSync(2, e4 + "\n"));
            var A, F = l.print || S, C = l.printErr || P;
            Object.assign(l, g), g = null, l.thisProgram && (b = l.thisProgram), l.quit && (w = l.quit), l.wasmBinary && (A = l.wasmBinary);
            var E = l.noExitRuntime || false;
            "object" != typeof WebAssembly && ie("no native wasm support detected");
            var O, I, D, L, $, N, B, z, R = false, j = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
            function V(e4, t3, n2) {
              var r2 = (t3 >>>= 0) + n2;
              for (n2 = t3; e4[n2] && !(n2 >= r2); ) ++n2;
              if (16 < n2 - t3 && e4.buffer && j) return j.decode(e4.buffer instanceof SharedArrayBuffer ? e4.slice(t3, n2) : e4.subarray(t3, n2));
              for (r2 = ""; t3 < n2; ) {
                var o3 = e4[t3++];
                if (128 & o3) {
                  var i2 = 63 & e4[t3++];
                  if (192 == (224 & o3)) r2 += String.fromCharCode((31 & o3) << 6 | i2);
                  else {
                    var s2 = 63 & e4[t3++];
                    65536 > (o3 = 224 == (240 & o3) ? (15 & o3) << 12 | i2 << 6 | s2 : (7 & o3) << 18 | i2 << 12 | s2 << 6 | 63 & e4[t3++]) ? r2 += String.fromCharCode(o3) : (o3 -= 65536, r2 += String.fromCharCode(55296 | o3 >> 10, 56320 | 1023 & o3));
                  }
                } else r2 += String.fromCharCode(o3);
              }
              return r2;
            }
            function U(e4, t3) {
              return (e4 >>>= 0) ? V(o2(), e4, t3) : "";
            }
            function G(e4, t3, n2, r2) {
              if (!(0 < r2)) return 0;
              var o3 = n2 >>>= 0;
              r2 = n2 + r2 - 1;
              for (var i2 = 0; i2 < e4.length; ++i2) {
                var s2 = e4.charCodeAt(i2);
                if (55296 <= s2 && 57343 >= s2 && (s2 = 65536 + ((1023 & s2) << 10) | 1023 & e4.charCodeAt(++i2)), 127 >= s2) {
                  if (n2 >= r2) break;
                  t3[n2++ >>> 0] = s2;
                } else {
                  if (2047 >= s2) {
                    if (n2 + 1 >= r2) break;
                    t3[n2++ >>> 0] = 192 | s2 >> 6;
                  } else {
                    if (65535 >= s2) {
                      if (n2 + 2 >= r2) break;
                      t3[n2++ >>> 0] = 224 | s2 >> 12;
                    } else {
                      if (n2 + 3 >= r2) break;
                      t3[n2++ >>> 0] = 240 | s2 >> 18, t3[n2++ >>> 0] = 128 | s2 >> 12 & 63;
                    }
                    t3[n2++ >>> 0] = 128 | s2 >> 6 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | 63 & s2;
                }
              }
              return t3[n2 >>> 0] = 0, n2 - o3;
            }
            function q(e4) {
              for (var t3 = 0, n2 = 0; n2 < e4.length; ++n2) {
                var r2 = e4.charCodeAt(n2);
                127 >= r2 ? t3++ : 2047 >= r2 ? t3 += 2 : 55296 <= r2 && 57343 >= r2 ? (t3 += 4, ++n2) : t3 += 3;
              }
              return t3;
            }
            function W(e4) {
              D = e4, l.HEAP8 = L = new Int8Array(e4), l.HEAP16 = new Int16Array(e4), l.HEAP32 = N = new Int32Array(e4), l.HEAPU8 = $ = new Uint8Array(e4), l.HEAPU16 = new Uint16Array(e4), l.HEAPU32 = B = new Uint32Array(e4), l.HEAPF32 = new Float32Array(e4), l.HEAPF64 = z = new Float64Array(e4);
            }
            v && (D = l.buffer);
            var H = l.INITIAL_MEMORY || 16777216;
            if (v) O = l.wasmMemory, D = l.buffer;
            else if (l.wasmMemory) O = l.wasmMemory;
            else if (!((O = new WebAssembly.Memory({ initial: H / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer)) throw C("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), T && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
            O && (D = O.buffer), H = D.byteLength, W(D);
            var X, Q = [], Y = [], K = [], Z = [];
            function J() {
              return E || false;
            }
            function ee() {
              var e4 = l.preRun.shift();
              Q.unshift(e4);
            }
            var te, ne = 0, re = null, oe = null;
            function ie(e4) {
              throw v ? postMessage({ cmd: "onAbort", arg: e4 }) : l.onAbort && l.onAbort(e4), C(e4 = "Aborted(" + e4 + ")"), R = true, e4 = new WebAssembly.RuntimeError(e4 + ". Build with -sASSERTIONS for more info."), u(e4), e4;
            }
            function se() {
              return te.startsWith("data:application/octet-stream;base64,");
            }
            function ae() {
              var e4 = te;
              try {
                if (e4 == te && A) return new Uint8Array(A);
                if (_) return _(e4);
                throw "both async and sync fetching of the wasm failed";
              } catch (e5) {
                ie(e5);
              }
            }
            te = "ort-wasm-threaded.wasm", se() || (te = M(te));
            var le = {};
            function ce(e4) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + e4 + ")", this.status = e4;
            }
            function ue(e4) {
              (e4 = he.Vb[e4]) || ie(), he.mc(e4);
            }
            function pe(e4) {
              var t3 = he.Cc();
              if (!t3) return 6;
              he.ac.push(t3), he.Vb[e4.Ub] = t3, t3.Ub = e4.Ub;
              var n2 = { cmd: "run", start_routine: e4.Ic, arg: e4.zc, pthread_ptr: e4.Ub };
              return t3.$b = () => {
                n2.time = performance.now(), t3.postMessage(n2, e4.Nc);
              }, t3.loaded && (t3.$b(), delete t3.$b), 0;
            }
            function de(e4) {
              if (v) return He(1, 1, e4);
              J() || (he.oc(), l.onExit && l.onExit(e4), R = true), w(e4, new ce(e4));
            }
            function _e(e4, t3) {
              if (!t3 && v) throw me(e4), "unwind";
              J() || v || (gt(), fe(K), mt(0), rt[1].length && ot(1, 10), rt[2].length && ot(2, 10), he.oc()), de(e4);
            }
            var he = { Yb: [], ac: [], qc: [], Vb: {}, fc: function() {
              v && he.Ec();
            }, Pc: function() {
            }, Ec: function() {
              he.receiveObjectTransfer = he.Gc, he.threadInitTLS = he.pc, he.setExitStatus = he.nc, E = false;
            }, nc: function() {
            }, oc: function() {
              for (var e4 of Object.values(he.Vb)) he.mc(e4);
              for (e4 of he.Yb) e4.terminate();
              he.Yb = [];
            }, mc: function(e4) {
              var t3 = e4.Ub;
              delete he.Vb[t3], he.Yb.push(e4), he.ac.splice(he.ac.indexOf(e4), 1), e4.Ub = 0, Tt(t3);
            }, Gc: function() {
            }, pc: function() {
              he.qc.forEach(((e4) => e4()));
            }, Fc: function(e4, t3) {
              e4.onmessage = (n2) => {
                var r2 = (n2 = n2.data).cmd;
                if (e4.Ub && (he.Bc = e4.Ub), n2.targetThread && n2.targetThread != _t()) {
                  var o3 = he.Vb[n2.Qc];
                  o3 ? o3.postMessage(n2, n2.transferList) : C('Internal error! Worker sent a message "' + r2 + '" to target pthread ' + n2.targetThread + ", but that thread no longer exists!");
                } else "processProxyingQueue" === r2 ? je(n2.queue) : "spawnThread" === r2 ? pe(n2) : "cleanupThread" === r2 ? ue(n2.thread) : "killThread" === r2 ? (n2 = n2.thread, r2 = he.Vb[n2], delete he.Vb[n2], r2.terminate(), Tt(n2), he.ac.splice(he.ac.indexOf(r2), 1), r2.Ub = 0) : "cancelThread" === r2 ? he.Vb[n2.thread].postMessage({ cmd: "cancel" }) : "loaded" === r2 ? (e4.loaded = true, t3 && t3(e4), e4.$b && (e4.$b(), delete e4.$b)) : "print" === r2 ? F("Thread " + n2.threadId + ": " + n2.text) : "printErr" === r2 ? C("Thread " + n2.threadId + ": " + n2.text) : "alert" === r2 ? alert("Thread " + n2.threadId + ": " + n2.text) : "setimmediate" === n2.target ? e4.postMessage(n2) : "onAbort" === r2 ? l.onAbort && l.onAbort(n2.arg) : r2 && C("worker sent an unknown command " + r2);
                he.Bc = void 0;
              }, e4.onerror = (e5) => {
                throw C("worker sent an error! " + e5.filename + ":" + e5.lineno + ": " + e5.message), e5;
              }, T && (e4.on("message", (function(t4) {
                e4.onmessage({ data: t4 });
              })), e4.on("error", (function(t4) {
                e4.onerror(t4);
              })), e4.on("detachedExit", (function() {
              }))), e4.postMessage({ cmd: "load", urlOrBlob: l.mainScriptUrlOrBlob || r, wasmMemory: O, wasmModule: I });
            }, yc: function() {
              var e4 = M("ort-wasm-threaded.worker.js");
              he.Yb.push(new Worker(e4));
            }, Cc: function() {
              return 0 == he.Yb.length && (he.yc(), he.Fc(he.Yb[0])), he.Yb.pop();
            } };
            function fe(e4) {
              for (; 0 < e4.length; ) e4.shift()(l);
            }
            function me(e4) {
              if (v) return He(2, 0, e4);
              try {
                _e(e4);
              } catch (e5) {
                e5 instanceof ce || "unwind" == e5 || w(1, e5);
              }
            }
            l.PThread = he, l.establishStackSpace = function() {
              var e4 = _t(), t3 = i()[e4 + 44 >> 2 >>> 0];
              e4 = i()[e4 + 48 >> 2 >>> 0], Mt(t3, t3 - e4), Pt(t3);
            };
            var ge = [];
            function be(e4) {
              var t3 = ge[e4];
              return t3 || (e4 >= ge.length && (ge.length = e4 + 1), ge[e4] = t3 = X.get(e4)), t3;
            }
            l.invokeEntryPoint = function(e4, t3) {
              e4 = be(e4)(t3), J() ? he.nc(e4) : vt(e4);
            };
            var we, xe, ye = [], Te = 0, ve = 0;
            function ke(e4) {
              this.Zb = e4, this.Sb = e4 - 24, this.xc = function(e5) {
                s()[this.Sb + 4 >> 2 >>> 0] = e5;
              }, this.bc = function() {
                return s()[this.Sb + 4 >> 2 >>> 0];
              }, this.wc = function(e5) {
                s()[this.Sb + 8 >> 2 >>> 0] = e5;
              }, this.Dc = function() {
                return s()[this.Sb + 8 >> 2 >>> 0];
              }, this.rc = function() {
                i()[this.Sb >> 2 >>> 0] = 0;
              }, this.hc = function(e5) {
                e5 = e5 ? 1 : 0, t2()[this.Sb + 12 >> 0 >>> 0] = e5;
              }, this.uc = function() {
                return 0 != t2()[this.Sb + 12 >> 0 >>> 0];
              }, this.ic = function(e5) {
                e5 = e5 ? 1 : 0, t2()[this.Sb + 13 >> 0 >>> 0] = e5;
              }, this.kc = function() {
                return 0 != t2()[this.Sb + 13 >> 0 >>> 0];
              }, this.fc = function(e5, t3) {
                this.cc(0), this.xc(e5), this.wc(t3), this.rc(), this.hc(false), this.ic(false);
              }, this.sc = function() {
                Atomics.add(i(), this.Sb >> 2, 1);
              }, this.Hc = function() {
                return 1 === Atomics.sub(i(), this.Sb >> 2, 1);
              }, this.cc = function(e5) {
                s()[this.Sb + 16 >> 2 >>> 0] = e5;
              }, this.tc = function() {
                return s()[this.Sb + 16 >> 2 >>> 0];
              }, this.vc = function() {
                if (Ct(this.bc())) return s()[this.Zb >> 2 >>> 0];
                var e5 = this.tc();
                return 0 !== e5 ? e5 : this.Zb;
              };
            }
            function Me(e4) {
              return ft(new ke(e4).Sb);
            }
            function Se(e4, t3, n2, r2) {
              return v ? He(3, 1, e4, t3, n2, r2) : Pe(e4, t3, n2, r2);
            }
            function Pe(e4, t3, n2, r2) {
              if ("undefined" == typeof SharedArrayBuffer) return C("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
              var o3 = [];
              return v && 0 === o3.length ? Se(e4, t3, n2, r2) : (e4 = { Ic: n2, Ub: e4, zc: r2, Nc: o3 }, v ? (e4.Oc = "spawnThread", postMessage(e4, o3), 0) : pe(e4));
            }
            function Ae(e4, t3, n2) {
              return v ? He(4, 1, e4, t3, n2) : 0;
            }
            function Fe(e4, t3) {
              if (v) return He(5, 1, e4, t3);
            }
            function Ce(e4, t3) {
              if (v) return He(6, 1, e4, t3);
            }
            function Ee(e4, t3, n2) {
              if (v) return He(7, 1, e4, t3, n2);
            }
            function Oe(e4, t3, n2) {
              return v ? He(8, 1, e4, t3, n2) : 0;
            }
            function Ie(e4, t3) {
              if (v) return He(9, 1, e4, t3);
            }
            function De(e4, t3, n2) {
              if (v) return He(10, 1, e4, t3, n2);
            }
            function Le(e4, t3, n2, r2) {
              if (v) return He(11, 1, e4, t3, n2, r2);
            }
            function $e(e4, t3, n2, r2) {
              if (v) return He(12, 1, e4, t3, n2, r2);
            }
            function Ne(e4, t3, n2, r2) {
              if (v) return He(13, 1, e4, t3, n2, r2);
            }
            function Be(e4) {
              if (v) return He(14, 1, e4);
            }
            function ze(e4, t3) {
              if (v) return He(15, 1, e4, t3);
            }
            function Re(e4, t3, n2) {
              if (v) return He(16, 1, e4, t3, n2);
            }
            function je(e4) {
              Atomics.store(i(), e4 >> 2, 1), _t() && yt(e4), Atomics.compareExchange(i(), e4 >> 2, 1, 0);
            }
            function Ve(e4) {
              return s()[e4 >>> 2] + 4294967296 * i()[e4 + 4 >>> 2];
            }
            function Ue(e4, t3, n2, r2, o3, i2) {
              return v ? He(17, 1, e4, t3, n2, r2, o3, i2) : -52;
            }
            function Ge(e4, t3, n2, r2, o3, i2) {
              if (v) return He(18, 1, e4, t3, n2, r2, o3, i2);
            }
            function qe(e4) {
              var n2 = q(e4) + 1, r2 = ht(n2);
              return r2 && G(e4, t2(), r2, n2), r2;
            }
            function We(e4, t3, n2) {
              function r2(e5) {
                return (e5 = e5.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e5[1] : "GMT";
              }
              if (v) return He(19, 1, e4, t3, n2);
              var o3 = (/* @__PURE__ */ new Date()).getFullYear(), a2 = new Date(o3, 0, 1), l2 = new Date(o3, 6, 1);
              o3 = a2.getTimezoneOffset();
              var c2 = l2.getTimezoneOffset(), u2 = Math.max(o3, c2);
              i()[e4 >> 2 >>> 0] = 60 * u2, i()[t3 >> 2 >>> 0] = Number(o3 != c2), e4 = r2(a2), t3 = r2(l2), e4 = qe(e4), t3 = qe(t3), c2 < o3 ? (s()[n2 >> 2 >>> 0] = e4, s()[n2 + 4 >> 2 >>> 0] = t3) : (s()[n2 >> 2 >>> 0] = t3, s()[n2 + 4 >> 2 >>> 0] = e4);
            }
            function He(e4, t3) {
              var n2 = arguments.length - 2, r2 = arguments;
              return (function(e5) {
                var t4 = St();
                return e5 = e5(), Pt(t4), e5;
              })((() => {
                for (var o3 = At(8 * n2), i2 = o3 >> 3, s2 = 0; s2 < n2; s2++) {
                  var l2 = r2[2 + s2];
                  a()[i2 + s2 >>> 0] = l2;
                }
                return xt(e4, n2, o3, t3);
              }));
            }
            l.executeNotifiedProxyingQueue = je, xe = T ? () => {
              var e4 = process.hrtime();
              return 1e3 * e4[0] + e4[1] / 1e6;
            } : v ? () => performance.now() - l.__performance_now_clock_drift : () => performance.now();
            var Xe, Qe = [], Ye = {};
            function Ke() {
              if (!Xe) {
                var e4, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: b || "./this.program" };
                for (e4 in Ye) void 0 === Ye[e4] ? delete t3[e4] : t3[e4] = Ye[e4];
                var n2 = [];
                for (e4 in t3) n2.push(e4 + "=" + t3[e4]);
                Xe = n2;
              }
              return Xe;
            }
            function Ze(e4, n2) {
              if (v) return He(20, 1, e4, n2);
              var r2 = 0;
              return Ke().forEach((function(o3, i2) {
                var a2 = n2 + r2;
                for (i2 = s()[e4 + 4 * i2 >> 2 >>> 0] = a2, a2 = 0; a2 < o3.length; ++a2) t2()[i2++ >> 0 >>> 0] = o3.charCodeAt(a2);
                t2()[i2 >> 0 >>> 0] = 0, r2 += o3.length + 1;
              })), 0;
            }
            function Je(e4, t3) {
              if (v) return He(21, 1, e4, t3);
              var n2 = Ke();
              s()[e4 >> 2 >>> 0] = n2.length;
              var r2 = 0;
              return n2.forEach((function(e5) {
                r2 += e5.length + 1;
              })), s()[t3 >> 2 >>> 0] = r2, 0;
            }
            function et(e4) {
              return v ? He(22, 1, e4) : 52;
            }
            function tt(e4, t3, n2, r2) {
              return v ? He(23, 1, e4, t3, n2, r2) : 52;
            }
            function nt(e4, t3, n2, r2, o3) {
              return v ? He(24, 1, e4, t3, n2, r2, o3) : 70;
            }
            var rt = [null, [], []];
            function ot(e4, t3) {
              var n2 = rt[e4];
              0 === t3 || 10 === t3 ? ((1 === e4 ? F : C)(V(n2, 0)), n2.length = 0) : n2.push(t3);
            }
            function it(e4, t3, n2, r2) {
              if (v) return He(25, 1, e4, t3, n2, r2);
              for (var i2 = 0, a2 = 0; a2 < n2; a2++) {
                var l2 = s()[t3 >> 2 >>> 0], c2 = s()[t3 + 4 >> 2 >>> 0];
                t3 += 8;
                for (var u2 = 0; u2 < c2; u2++) ot(e4, o2()[l2 + u2 >>> 0]);
                i2 += c2;
              }
              return s()[r2 >> 2 >>> 0] = i2, 0;
            }
            var st = 0;
            function at(e4) {
              return 0 == e4 % 4 && (0 != e4 % 100 || 0 == e4 % 400);
            }
            var lt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ct = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function ut(e4, n2, r2, o3) {
              function s2(e5, t3, n3) {
                for (e5 = "number" == typeof e5 ? e5.toString() : e5 || ""; e5.length < t3; ) e5 = n3[0] + e5;
                return e5;
              }
              function a2(e5, t3) {
                return s2(e5, t3, "0");
              }
              function l2(e5, t3) {
                function n3(e6) {
                  return 0 > e6 ? -1 : 0 < e6 ? 1 : 0;
                }
                var r3;
                return 0 === (r3 = n3(e5.getFullYear() - t3.getFullYear())) && 0 === (r3 = n3(e5.getMonth() - t3.getMonth())) && (r3 = n3(e5.getDate() - t3.getDate())), r3;
              }
              function c2(e5) {
                switch (e5.getDay()) {
                  case 0:
                    return new Date(e5.getFullYear() - 1, 11, 29);
                  case 1:
                    return e5;
                  case 2:
                    return new Date(e5.getFullYear(), 0, 3);
                  case 3:
                    return new Date(e5.getFullYear(), 0, 2);
                  case 4:
                    return new Date(e5.getFullYear(), 0, 1);
                  case 5:
                    return new Date(e5.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(e5.getFullYear() - 1, 11, 30);
                }
              }
              function u2(e5) {
                var t3 = e5.Wb;
                for (e5 = new Date(new Date(e5.Xb + 1900, 0, 1).getTime()); 0 < t3; ) {
                  var n3 = e5.getMonth(), r3 = (at(e5.getFullYear()) ? lt : ct)[n3];
                  if (!(t3 > r3 - e5.getDate())) {
                    e5.setDate(e5.getDate() + t3);
                    break;
                  }
                  t3 -= r3 - e5.getDate() + 1, e5.setDate(1), 11 > n3 ? e5.setMonth(n3 + 1) : (e5.setMonth(0), e5.setFullYear(e5.getFullYear() + 1));
                }
                return n3 = new Date(e5.getFullYear() + 1, 0, 4), t3 = c2(new Date(e5.getFullYear(), 0, 4)), n3 = c2(n3), 0 >= l2(t3, e5) ? 0 >= l2(n3, e5) ? e5.getFullYear() + 1 : e5.getFullYear() : e5.getFullYear() - 1;
              }
              var p2 = i()[o3 + 40 >> 2 >>> 0];
              for (var d2 in o3 = { Lc: i()[o3 >> 2 >>> 0], Kc: i()[o3 + 4 >> 2 >>> 0], dc: i()[o3 + 8 >> 2 >>> 0], jc: i()[o3 + 12 >> 2 >>> 0], ec: i()[o3 + 16 >> 2 >>> 0], Xb: i()[o3 + 20 >> 2 >>> 0], Tb: i()[o3 + 24 >> 2 >>> 0], Wb: i()[o3 + 28 >> 2 >>> 0], Rc: i()[o3 + 32 >> 2 >>> 0], Jc: i()[o3 + 36 >> 2 >>> 0], Mc: p2 ? U(p2) : "" }, r2 = U(r2), p2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) r2 = r2.replace(new RegExp(d2, "g"), p2[d2]);
              var _2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h2 = "January February March April May June July August September October November December".split(" ");
              for (d2 in p2 = { "%a": function(e5) {
                return _2[e5.Tb].substring(0, 3);
              }, "%A": function(e5) {
                return _2[e5.Tb];
              }, "%b": function(e5) {
                return h2[e5.ec].substring(0, 3);
              }, "%B": function(e5) {
                return h2[e5.ec];
              }, "%C": function(e5) {
                return a2((e5.Xb + 1900) / 100 | 0, 2);
              }, "%d": function(e5) {
                return a2(e5.jc, 2);
              }, "%e": function(e5) {
                return s2(e5.jc, 2, " ");
              }, "%g": function(e5) {
                return u2(e5).toString().substring(2);
              }, "%G": function(e5) {
                return u2(e5);
              }, "%H": function(e5) {
                return a2(e5.dc, 2);
              }, "%I": function(e5) {
                return 0 == (e5 = e5.dc) ? e5 = 12 : 12 < e5 && (e5 -= 12), a2(e5, 2);
              }, "%j": function(e5) {
                for (var t3 = 0, n3 = 0; n3 <= e5.ec - 1; t3 += (at(e5.Xb + 1900) ? lt : ct)[n3++]) ;
                return a2(e5.jc + t3, 3);
              }, "%m": function(e5) {
                return a2(e5.ec + 1, 2);
              }, "%M": function(e5) {
                return a2(e5.Kc, 2);
              }, "%n": function() {
                return "\n";
              }, "%p": function(e5) {
                return 0 <= e5.dc && 12 > e5.dc ? "AM" : "PM";
              }, "%S": function(e5) {
                return a2(e5.Lc, 2);
              }, "%t": function() {
                return "	";
              }, "%u": function(e5) {
                return e5.Tb || 7;
              }, "%U": function(e5) {
                return a2(Math.floor((e5.Wb + 7 - e5.Tb) / 7), 2);
              }, "%V": function(e5) {
                var t3 = Math.floor((e5.Wb + 7 - (e5.Tb + 6) % 7) / 7);
                if (2 >= (e5.Tb + 371 - e5.Wb - 2) % 7 && t3++, t3) 53 == t3 && (4 == (n3 = (e5.Tb + 371 - e5.Wb) % 7) || 3 == n3 && at(e5.Xb) || (t3 = 1));
                else {
                  t3 = 52;
                  var n3 = (e5.Tb + 7 - e5.Wb - 1) % 7;
                  (4 == n3 || 5 == n3 && at(e5.Xb % 400 - 1)) && t3++;
                }
                return a2(t3, 2);
              }, "%w": function(e5) {
                return e5.Tb;
              }, "%W": function(e5) {
                return a2(Math.floor((e5.Wb + 7 - (e5.Tb + 6) % 7) / 7), 2);
              }, "%y": function(e5) {
                return (e5.Xb + 1900).toString().substring(2);
              }, "%Y": function(e5) {
                return e5.Xb + 1900;
              }, "%z": function(e5) {
                var t3 = 0 <= (e5 = e5.Jc);
                return e5 = Math.abs(e5) / 60, (t3 ? "+" : "-") + String("0000" + (e5 / 60 * 100 + e5 % 60)).slice(-4);
              }, "%Z": function(e5) {
                return e5.Mc;
              }, "%%": function() {
                return "%";
              } }, r2 = r2.replace(/%%/g, "\0\0"), p2) r2.includes(d2) && (r2 = r2.replace(new RegExp(d2, "g"), p2[d2](o3)));
              return d2 = (function(e5) {
                var t3 = Array(q(e5) + 1);
                return G(e5, t3, 0, t3.length), t3;
              })(r2 = r2.replace(/\0\0/g, "%")), d2.length > n2 ? 0 : ((function(e5, n3) {
                t2().set(e5, n3 >>> 0);
              })(d2, e4), d2.length - 1);
            }
            he.fc();
            var pt = [null, de, me, Se, Ae, Fe, Ce, Ee, Oe, Ie, De, Le, $e, Ne, Be, ze, Re, Ue, Ge, We, Ze, Je, et, tt, nt, it], dt = { b: function(e4) {
              return ht(e4 + 24) + 24;
            }, n: function(e4) {
              return (e4 = new ke(e4)).uc() || (e4.hc(true), Te--), e4.ic(false), ye.push(e4), e4.sc(), e4.vc();
            }, ma: function(e4) {
              throw C("Unexpected exception thrown, this is not properly supported - aborting"), R = true, e4;
            }, x: function() {
              kt(0);
              var e4 = ye.pop();
              if (e4.Hc() && !e4.kc()) {
                var t3 = e4.Dc();
                t3 && be(t3)(e4.Zb), Me(e4.Zb);
              }
              ve = 0;
            }, e: function() {
              var e4 = ve;
              if (!e4) return st = 0;
              var t3 = new ke(e4);
              t3.cc(e4);
              var n2 = t3.bc();
              if (!n2) return st = 0, e4;
              for (var r2 = Array.prototype.slice.call(arguments), o3 = 0; o3 < r2.length; o3++) {
                var i2 = r2[o3];
                if (0 === i2 || i2 === n2) break;
                if (Ft(i2, n2, t3.Sb + 16)) return st = i2, e4;
              }
              return st = n2, e4;
            }, l: function() {
              var e4 = ve;
              if (!e4) return st = 0;
              var t3 = new ke(e4);
              t3.cc(e4);
              var n2 = t3.bc();
              if (!n2) return st = 0, e4;
              for (var r2 = Array.prototype.slice.call(arguments), o3 = 0; o3 < r2.length; o3++) {
                var i2 = r2[o3];
                if (0 === i2 || i2 === n2) break;
                if (Ft(i2, n2, t3.Sb + 16)) return st = i2, e4;
              }
              return st = n2, e4;
            }, h: function() {
              var e4 = ve;
              if (!e4) return st = 0;
              var t3 = new ke(e4);
              t3.cc(e4);
              var n2 = t3.bc();
              if (!n2) return st = 0, e4;
              for (var r2 = Array.prototype.slice.call(arguments), o3 = 0; o3 < r2.length; o3++) {
                var i2 = r2[o3];
                if (0 === i2 || i2 === n2) break;
                if (Ft(i2, n2, t3.Sb + 16)) return st = i2, e4;
              }
              return st = n2, e4;
            }, t: Me, M: function() {
              var e4 = ye.pop();
              e4 || ie("no exception to throw");
              var t3 = e4.Zb;
              throw e4.kc() || (ye.push(e4), e4.ic(true), e4.hc(false), Te++), ve = t3, t3;
            }, c: function(e4, t3, n2) {
              throw new ke(e4).fc(t3, n2), ve = e4, Te++, e4;
            }, pa: function() {
              return Te;
            }, Fa: function(e4) {
              bt(e4, !y, 1, !x), he.pc();
            }, T: function(e4) {
              v ? postMessage({ cmd: "cleanupThread", thread: e4 }) : ue(e4);
            }, xa: Pe, j: function(e4) {
              throw ve || (ve = e4), e4;
            }, H: Ae, Ma: Fe, ua: Ce, wa: Ee, oa: Oe, Ka: Ie, Ca: De, Ja: Le, V: $e, va: Ne, sa: Be, La: ze, ta: Re, Ta: function() {
            }, X: function() {
              ie("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, Ua: function() {
              ie("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, W: function() {
              return Date.now();
            }, ya: function() {
              return 2097152;
            }, Oa: function() {
              return true;
            }, za: function(e4, t3, n2, r2) {
              if (e4 == t3) setTimeout((() => je(r2)));
              else if (v) postMessage({ targetThread: e4, cmd: "processProxyingQueue", queue: r2 });
              else {
                if (!(e4 = he.Vb[e4])) return;
                e4.postMessage({ cmd: "processProxyingQueue", queue: r2 });
              }
              return 1;
            }, Ea: function() {
              return -1;
            }, Pa: function(e4, t3) {
              e4 = new Date(1e3 * Ve(e4)), i()[t3 >> 2 >>> 0] = e4.getUTCSeconds(), i()[t3 + 4 >> 2 >>> 0] = e4.getUTCMinutes(), i()[t3 + 8 >> 2 >>> 0] = e4.getUTCHours(), i()[t3 + 12 >> 2 >>> 0] = e4.getUTCDate(), i()[t3 + 16 >> 2 >>> 0] = e4.getUTCMonth(), i()[t3 + 20 >> 2 >>> 0] = e4.getUTCFullYear() - 1900, i()[t3 + 24 >> 2 >>> 0] = e4.getUTCDay(), e4 = (e4.getTime() - Date.UTC(e4.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[t3 + 28 >> 2 >>> 0] = e4;
            }, Qa: function(e4, t3) {
              e4 = new Date(1e3 * Ve(e4)), i()[t3 >> 2 >>> 0] = e4.getSeconds(), i()[t3 + 4 >> 2 >>> 0] = e4.getMinutes(), i()[t3 + 8 >> 2 >>> 0] = e4.getHours(), i()[t3 + 12 >> 2 >>> 0] = e4.getDate(), i()[t3 + 16 >> 2 >>> 0] = e4.getMonth(), i()[t3 + 20 >> 2 >>> 0] = e4.getFullYear() - 1900, i()[t3 + 24 >> 2 >>> 0] = e4.getDay();
              var n2 = new Date(e4.getFullYear(), 0, 1), r2 = (e4.getTime() - n2.getTime()) / 864e5 | 0;
              i()[t3 + 28 >> 2 >>> 0] = r2, i()[t3 + 36 >> 2 >>> 0] = -60 * e4.getTimezoneOffset(), r2 = new Date(e4.getFullYear(), 6, 1).getTimezoneOffset(), e4 = 0 | (r2 != (n2 = n2.getTimezoneOffset()) && e4.getTimezoneOffset() == Math.min(n2, r2)), i()[t3 + 32 >> 2 >>> 0] = e4;
            }, Ra: function(e4) {
              var t3 = new Date(i()[e4 + 20 >> 2 >>> 0] + 1900, i()[e4 + 16 >> 2 >>> 0], i()[e4 + 12 >> 2 >>> 0], i()[e4 + 8 >> 2 >>> 0], i()[e4 + 4 >> 2 >>> 0], i()[e4 >> 2 >>> 0], 0), n2 = i()[e4 + 32 >> 2 >>> 0], r2 = t3.getTimezoneOffset(), o3 = new Date(t3.getFullYear(), 0, 1), s2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), a2 = o3.getTimezoneOffset(), l2 = Math.min(a2, s2);
              return 0 > n2 ? i()[e4 + 32 >> 2 >>> 0] = Number(s2 != a2 && l2 == r2) : 0 < n2 != (l2 == r2) && (s2 = Math.max(a2, s2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? l2 : s2) - r2))), i()[e4 + 24 >> 2 >>> 0] = t3.getDay(), n2 = (t3.getTime() - o3.getTime()) / 864e5 | 0, i()[e4 + 28 >> 2 >>> 0] = n2, i()[e4 >> 2 >>> 0] = t3.getSeconds(), i()[e4 + 4 >> 2 >>> 0] = t3.getMinutes(), i()[e4 + 8 >> 2 >>> 0] = t3.getHours(), i()[e4 + 12 >> 2 >>> 0] = t3.getDate(), i()[e4 + 16 >> 2 >>> 0] = t3.getMonth(), t3.getTime() / 1e3 | 0;
            }, Aa: Ue, Ba: Ge, Sa: function e4(t3, n2, r2) {
              e4.Ac || (e4.Ac = true, We(t3, n2, r2));
            }, y: function() {
              ie("");
            }, U: function() {
              if (!T && !y) {
                var e4 = "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
                we || (we = {}), we[e4] || (we[e4] = 1, T && (e4 = "warning: " + e4), C(e4));
              }
            }, ra: function() {
              return 4294901760;
            }, B: xe, Ia: function(e4, t3, n2) {
              o2().copyWithin(e4 >>> 0, t3 >>> 0, t3 + n2 >>> 0);
            }, F: function() {
              return T ? n(3993).cpus().length : navigator.hardwareConcurrency;
            }, Da: function(e4, t3, n2) {
              Qe.length = t3, n2 >>= 3;
              for (var r2 = 0; r2 < t3; r2++) Qe[r2] = a()[n2 + r2 >>> 0];
              return (0 > e4 ? le[-e4 - 1] : pt[e4]).apply(null, Qe);
            }, qa: function(e4) {
              var t3 = o2().length;
              if ((e4 >>>= 0) <= t3 || 4294901760 < e4) return false;
              for (var n2 = 1; 4 >= n2; n2 *= 2) {
                var r2 = t3 * (1 + 0.2 / n2);
                r2 = Math.min(r2, e4 + 100663296);
                var i2 = Math;
                r2 = Math.max(e4, r2), i2 = i2.min.call(i2, 4294901760, r2 + (65536 - r2 % 65536) % 65536);
                e: {
                  try {
                    O.grow(i2 - D.byteLength + 65535 >>> 16), W(O.buffer);
                    var s2 = 1;
                    break e;
                  } catch (e5) {
                  }
                  s2 = void 0;
                }
                if (s2) return true;
              }
              return false;
            }, Na: function() {
              throw "unwind";
            }, Ga: Ze, Ha: Je, J: _e, I: et, S: tt, ga: nt, R: it, d: function() {
              return st;
            }, na: function e4(r2, o3) {
              e4.lc || (e4.lc = (function() {
                if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                  var e5 = new Uint8Array(1);
                  return () => (crypto.getRandomValues(e5), e5[0]);
                }
                if (T) try {
                  var t3 = n(Object((function() {
                    var e6 = new Error("Cannot find module 'crypto'");
                    throw e6.code = "MODULE_NOT_FOUND", e6;
                  })()));
                  return () => t3.randomBytes(1)[0];
                } catch (e6) {
                }
                return () => ie("randomDevice");
              })());
              for (var i2 = 0; i2 < o3; i2++) t2()[r2 + i2 >> 0 >>> 0] = e4.lc();
              return 0;
            }, ia: function(e4, t3, n2) {
              var r2 = St();
              try {
                return be(e4)(t3, n2);
              } catch (e5) {
                if (Pt(r2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, ja: function(e4, t3, n2) {
              var r2 = St();
              try {
                return be(e4)(t3, n2);
              } catch (e5) {
                if (Pt(r2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, K: function(e4) {
              var t3 = St();
              try {
                return be(e4)();
              } catch (e5) {
                if (Pt(t3), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, f: function(e4, t3) {
              var n2 = St();
              try {
                return be(e4)(t3);
              } catch (e5) {
                if (Pt(n2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, P: function(e4, t3, n2) {
              var r2 = St();
              try {
                return be(e4)(t3, n2);
              } catch (e5) {
                if (Pt(r2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, Q: function(e4, t3, n2) {
              var r2 = St();
              try {
                return be(e4)(t3, n2);
              } catch (e5) {
                if (Pt(r2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, k: function(e4, t3, n2) {
              var r2 = St();
              try {
                return be(e4)(t3, n2);
              } catch (e5) {
                if (Pt(r2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, p: function(e4, t3, n2, r2) {
              var o3 = St();
              try {
                return be(e4)(t3, n2, r2);
              } catch (e5) {
                if (Pt(o3), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, q: function(e4, t3, n2, r2, o3) {
              var i2 = St();
              try {
                return be(e4)(t3, n2, r2, o3);
              } catch (e5) {
                if (Pt(i2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, N: function(e4, t3, n2, r2, o3, i2) {
              var s2 = St();
              try {
                return be(e4)(t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Pt(s2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, s: function(e4, t3, n2, r2, o3, i2) {
              var s2 = St();
              try {
                return be(e4)(t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Pt(s2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, w: function(e4, t3, n2, r2, o3, i2, s2) {
              var a2 = St();
              try {
                return be(e4)(t3, n2, r2, o3, i2, s2);
              } catch (e5) {
                if (Pt(a2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, L: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = St();
              try {
                return be(e4)(t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Pt(l2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, E: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2) {
              var d2 = St();
              try {
                return be(e4)(t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2);
              } catch (e5) {
                if (Pt(d2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, aa: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = St();
              try {
                return zt(e4, t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Pt(l2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, _: function(e4, t3, n2, r2, o3, i2, s2) {
              var a2 = St();
              try {
                return Ot(e4, t3, n2, r2, o3, i2, s2);
              } catch (e5) {
                if (Pt(a2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, Z: function(e4, t3, n2, r2, o3) {
              var i2 = St();
              try {
                return Rt(e4, t3, n2, r2, o3);
              } catch (e5) {
                if (Pt(i2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, ca: function(e4, t3, n2, r2) {
              var o3 = St();
              try {
                return Nt(e4, t3, n2, r2);
              } catch (e5) {
                if (Pt(o3), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, $: function(e4) {
              var t3 = St();
              try {
                return Et(e4);
              } catch (e5) {
                if (Pt(t3), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, ba: function(e4, t3) {
              var n2 = St();
              try {
                return Bt(e4, t3);
              } catch (e5) {
                if (Pt(n2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, Y: function(e4, t3, n2) {
              var r2 = St();
              try {
                return It(e4, t3, n2);
              } catch (e5) {
                if (Pt(r2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, g: function(e4) {
              var t3 = St();
              try {
                be(e4)();
              } catch (e5) {
                if (Pt(t3), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, r: function(e4, t3) {
              var n2 = St();
              try {
                be(e4)(t3);
              } catch (e5) {
                if (Pt(n2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, i: function(e4, t3, n2) {
              var r2 = St();
              try {
                be(e4)(t3, n2);
              } catch (e5) {
                if (Pt(r2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, ha: function(e4, t3, n2, r2) {
              var o3 = St();
              try {
                be(e4)(t3, n2, r2);
              } catch (e5) {
                if (Pt(o3), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, m: function(e4, t3, n2, r2) {
              var o3 = St();
              try {
                be(e4)(t3, n2, r2);
              } catch (e5) {
                if (Pt(o3), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, v: function(e4, t3, n2, r2, o3) {
              var i2 = St();
              try {
                be(e4)(t3, n2, r2, o3);
              } catch (e5) {
                if (Pt(i2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, u: function(e4, t3, n2, r2, o3, i2) {
              var s2 = St();
              try {
                be(e4)(t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Pt(s2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, O: function(e4, t3, n2, r2, o3, i2, s2) {
              var a2 = St();
              try {
                be(e4)(t3, n2, r2, o3, i2, s2);
              } catch (e5) {
                if (Pt(a2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, A: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = St();
              try {
                be(e4)(t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Pt(l2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, ka: function(e4, t3, n2, r2, o3, i2, s2, a2, l2) {
              var c2 = St();
              try {
                be(e4)(t3, n2, r2, o3, i2, s2, a2, l2);
              } catch (e5) {
                if (Pt(c2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, C: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2) {
              var p2 = St();
              try {
                be(e4)(t3, n2, r2, o3, i2, s2, a2, l2, c2, u2);
              } catch (e5) {
                if (Pt(p2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, D: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2, d2, _2, h2, f2) {
              var m2 = St();
              try {
                be(e4)(t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2, d2, _2, h2, f2);
              } catch (e5) {
                if (Pt(m2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, fa: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = St();
              try {
                Dt(e4, t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Pt(l2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, da: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2) {
              var d2 = St();
              try {
                $t(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2);
              } catch (e5) {
                if (Pt(d2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, ea: function(e4, t3, n2, r2, o3, i2) {
              var s2 = St();
              try {
                Lt(e4, t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Pt(s2), e5 !== e5 + 0) throw e5;
                kt(1, 0);
              }
            }, o: function(e4) {
              return e4;
            }, a: O || l.wasmMemory, G: function(e4) {
              st = e4;
            }, la: ut, z: function(e4, t3, n2, r2) {
              return ut(e4, t3, n2, r2);
            } };
            !(function() {
              function e4(e5, t4) {
                l.asm = e5.exports, he.qc.push(l.asm.sb), X = l.asm.ub, Y.unshift(l.asm.Va), I = t4, v || (ne--, l.monitorRunDependencies && l.monitorRunDependencies(ne), 0 == ne && (null !== re && (clearInterval(re), re = null), oe && (e5 = oe, oe = null, e5())));
              }
              function t3(t4) {
                e4(t4.instance, t4.module);
              }
              function n2(e5) {
                return (function() {
                  if (!A && (x || y)) {
                    if ("function" == typeof fetch && !te.startsWith("file://")) return fetch(te, { credentials: "same-origin" }).then((function(e6) {
                      if (!e6.ok) throw "failed to load wasm binary file at '" + te + "'";
                      return e6.arrayBuffer();
                    })).catch((function() {
                      return ae();
                    }));
                    if (d) return new Promise((function(e6, t4) {
                      d(te, (function(t5) {
                        e6(new Uint8Array(t5));
                      }), t4);
                    }));
                  }
                  return Promise.resolve().then((function() {
                    return ae();
                  }));
                })().then((function(e6) {
                  return WebAssembly.instantiate(e6, r2);
                })).then((function(e6) {
                  return e6;
                })).then(e5, (function(e6) {
                  C("failed to asynchronously prepare wasm: " + e6), ie(e6);
                }));
              }
              var r2 = { a: dt };
              if (v || (ne++, l.monitorRunDependencies && l.monitorRunDependencies(ne)), l.instantiateWasm) try {
                return l.instantiateWasm(r2, e4);
              } catch (e5) {
                return C("Module.instantiateWasm callback failed with error: " + e5), false;
              }
              (A || "function" != typeof WebAssembly.instantiateStreaming || se() || te.startsWith("file://") || T || "function" != typeof fetch ? n2(t3) : fetch(te, { credentials: "same-origin" }).then((function(e5) {
                return WebAssembly.instantiateStreaming(e5, r2).then(t3, (function(e6) {
                  return C("wasm streaming compile failed: " + e6), C("falling back to ArrayBuffer instantiation"), n2(t3);
                }));
              }))).catch(u);
            })(), l.___wasm_call_ctors = function() {
              return (l.___wasm_call_ctors = l.asm.Va).apply(null, arguments);
            }, l._OrtInit = function() {
              return (l._OrtInit = l.asm.Wa).apply(null, arguments);
            }, l._OrtCreateSessionOptions = function() {
              return (l._OrtCreateSessionOptions = l.asm.Xa).apply(null, arguments);
            }, l._OrtAppendExecutionProvider = function() {
              return (l._OrtAppendExecutionProvider = l.asm.Ya).apply(null, arguments);
            }, l._OrtAddSessionConfigEntry = function() {
              return (l._OrtAddSessionConfigEntry = l.asm.Za).apply(null, arguments);
            }, l._OrtReleaseSessionOptions = function() {
              return (l._OrtReleaseSessionOptions = l.asm._a).apply(null, arguments);
            }, l._OrtCreateSession = function() {
              return (l._OrtCreateSession = l.asm.$a).apply(null, arguments);
            }, l._OrtReleaseSession = function() {
              return (l._OrtReleaseSession = l.asm.ab).apply(null, arguments);
            }, l._OrtGetInputCount = function() {
              return (l._OrtGetInputCount = l.asm.bb).apply(null, arguments);
            }, l._OrtGetOutputCount = function() {
              return (l._OrtGetOutputCount = l.asm.cb).apply(null, arguments);
            }, l._OrtGetInputName = function() {
              return (l._OrtGetInputName = l.asm.db).apply(null, arguments);
            }, l._OrtGetOutputName = function() {
              return (l._OrtGetOutputName = l.asm.eb).apply(null, arguments);
            }, l._OrtFree = function() {
              return (l._OrtFree = l.asm.fb).apply(null, arguments);
            }, l._OrtCreateTensor = function() {
              return (l._OrtCreateTensor = l.asm.gb).apply(null, arguments);
            }, l._OrtGetTensorData = function() {
              return (l._OrtGetTensorData = l.asm.hb).apply(null, arguments);
            }, l._OrtReleaseTensor = function() {
              return (l._OrtReleaseTensor = l.asm.ib).apply(null, arguments);
            }, l._OrtCreateRunOptions = function() {
              return (l._OrtCreateRunOptions = l.asm.jb).apply(null, arguments);
            }, l._OrtAddRunConfigEntry = function() {
              return (l._OrtAddRunConfigEntry = l.asm.kb).apply(null, arguments);
            }, l._OrtReleaseRunOptions = function() {
              return (l._OrtReleaseRunOptions = l.asm.lb).apply(null, arguments);
            }, l._OrtRun = function() {
              return (l._OrtRun = l.asm.mb).apply(null, arguments);
            }, l._OrtEndProfiling = function() {
              return (l._OrtEndProfiling = l.asm.nb).apply(null, arguments);
            };
            var _t = l._pthread_self = function() {
              return (_t = l._pthread_self = l.asm.ob).apply(null, arguments);
            }, ht = l._malloc = function() {
              return (ht = l._malloc = l.asm.pb).apply(null, arguments);
            }, ft = l._free = function() {
              return (ft = l._free = l.asm.qb).apply(null, arguments);
            }, mt = l._fflush = function() {
              return (mt = l._fflush = l.asm.rb).apply(null, arguments);
            };
            l.__emscripten_tls_init = function() {
              return (l.__emscripten_tls_init = l.asm.sb).apply(null, arguments);
            };
            var gt = l.___funcs_on_exit = function() {
              return (gt = l.___funcs_on_exit = l.asm.tb).apply(null, arguments);
            }, bt = l.__emscripten_thread_init = function() {
              return (bt = l.__emscripten_thread_init = l.asm.vb).apply(null, arguments);
            };
            l.__emscripten_thread_crashed = function() {
              return (l.__emscripten_thread_crashed = l.asm.wb).apply(null, arguments);
            };
            var wt, xt = l._emscripten_run_in_main_runtime_thread_js = function() {
              return (xt = l._emscripten_run_in_main_runtime_thread_js = l.asm.xb).apply(null, arguments);
            }, yt = l.__emscripten_proxy_execute_task_queue = function() {
              return (yt = l.__emscripten_proxy_execute_task_queue = l.asm.yb).apply(null, arguments);
            }, Tt = l.__emscripten_thread_free_data = function() {
              return (Tt = l.__emscripten_thread_free_data = l.asm.zb).apply(null, arguments);
            }, vt = l.__emscripten_thread_exit = function() {
              return (vt = l.__emscripten_thread_exit = l.asm.Ab).apply(null, arguments);
            }, kt = l._setThrew = function() {
              return (kt = l._setThrew = l.asm.Bb).apply(null, arguments);
            }, Mt = l._emscripten_stack_set_limits = function() {
              return (Mt = l._emscripten_stack_set_limits = l.asm.Cb).apply(null, arguments);
            }, St = l.stackSave = function() {
              return (St = l.stackSave = l.asm.Db).apply(null, arguments);
            }, Pt = l.stackRestore = function() {
              return (Pt = l.stackRestore = l.asm.Eb).apply(null, arguments);
            }, At = l.stackAlloc = function() {
              return (At = l.stackAlloc = l.asm.Fb).apply(null, arguments);
            }, Ft = l.___cxa_can_catch = function() {
              return (Ft = l.___cxa_can_catch = l.asm.Gb).apply(null, arguments);
            }, Ct = l.___cxa_is_pointer_type = function() {
              return (Ct = l.___cxa_is_pointer_type = l.asm.Hb).apply(null, arguments);
            }, Et = l.dynCall_j = function() {
              return (Et = l.dynCall_j = l.asm.Ib).apply(null, arguments);
            }, Ot = l.dynCall_iiiiij = function() {
              return (Ot = l.dynCall_iiiiij = l.asm.Jb).apply(null, arguments);
            }, It = l.dynCall_jii = function() {
              return (It = l.dynCall_jii = l.asm.Kb).apply(null, arguments);
            }, Dt = l.dynCall_viiiiij = function() {
              return (Dt = l.dynCall_viiiiij = l.asm.Lb).apply(null, arguments);
            }, Lt = l.dynCall_vjji = function() {
              return (Lt = l.dynCall_vjji = l.asm.Mb).apply(null, arguments);
            }, $t = l.dynCall_viiijjjii = function() {
              return ($t = l.dynCall_viiijjjii = l.asm.Nb).apply(null, arguments);
            }, Nt = l.dynCall_iij = function() {
              return (Nt = l.dynCall_iij = l.asm.Ob).apply(null, arguments);
            }, Bt = l.dynCall_ji = function() {
              return (Bt = l.dynCall_ji = l.asm.Pb).apply(null, arguments);
            }, zt = l.dynCall_iiiiiij = function() {
              return (zt = l.dynCall_iiiiiij = l.asm.Qb).apply(null, arguments);
            }, Rt = l.dynCall_iiij = function() {
              return (Rt = l.dynCall_iiij = l.asm.Rb).apply(null, arguments);
            };
            function jt() {
              function e4() {
                if (!wt && (wt = true, l.calledRun = true, !R) && (v || fe(Y), c(l), l.onRuntimeInitialized && l.onRuntimeInitialized(), !v)) {
                  if (l.postRun) for ("function" == typeof l.postRun && (l.postRun = [l.postRun]); l.postRun.length; ) {
                    var e5 = l.postRun.shift();
                    Z.unshift(e5);
                  }
                  fe(Z);
                }
              }
              if (!(0 < ne)) if (v) c(l), v || fe(Y), postMessage({ cmd: "loaded" });
              else {
                if (l.preRun) for ("function" == typeof l.preRun && (l.preRun = [l.preRun]); l.preRun.length; ) ee();
                fe(Q), 0 < ne || (l.setStatus ? (l.setStatus("Running..."), setTimeout((function() {
                  setTimeout((function() {
                    l.setStatus("");
                  }), 1), e4();
                }), 1)) : e4());
              }
            }
            if (l.UTF8ToString = U, l.stringToUTF8 = function(e4, t3, n2) {
              return G(e4, o2(), t3, n2);
            }, l.lengthBytesUTF8 = q, l.keepRuntimeAlive = J, l.wasmMemory = O, l.stackSave = St, l.stackRestore = Pt, l.stackAlloc = At, l.ExitStatus = ce, l.PThread = he, oe = function e4() {
              wt || jt(), wt || (oe = e4);
            }, l.preInit) for ("function" == typeof l.preInit && (l.preInit = [l.preInit]); 0 < l.preInit.length; ) l.preInit.pop()();
            return jt(), e3.ready;
          });
          e2.exports = o;
        }, 932: (e2, t, n) => {
          var r, o = (r = (r = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(e3) {
            var t2, o2, i;
            e3 = e3 || {}, t2 || (t2 = void 0 !== e3 ? e3 : {}), t2.ready = new Promise((function(e4, t3) {
              o2 = e4, i = t3;
            }));
            var s, a, l, c, u, p, d = Object.assign({}, t2), _ = "./this.program", h = (e4, t3) => {
              throw t3;
            }, f = "object" == typeof window, m = "function" == typeof importScripts, g = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, b = "";
            g ? (b = m ? n(908).dirname(b) + "/" : "//", p = () => {
              u || (c = n(1384), u = n(908));
            }, s = function(e4, t3) {
              return p(), e4 = u.normalize(e4), c.readFileSync(e4, t3 ? void 0 : "utf8");
            }, l = (e4) => ((e4 = s(e4, true)).buffer || (e4 = new Uint8Array(e4)), e4), a = (e4, t3, n2) => {
              p(), e4 = u.normalize(e4), c.readFile(e4, (function(e5, r2) {
                e5 ? n2(e5) : t3(r2.buffer);
              }));
            }, 1 < process.argv.length && (_ = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", (function(e4) {
              if (!(e4 instanceof K)) throw e4;
            })), process.on("unhandledRejection", (function(e4) {
              throw e4;
            })), h = (e4, t3) => {
              if (T || 0 < j) throw process.exitCode = e4, t3;
              t3 instanceof K || y("exiting due to exception: " + t3), process.exit(e4);
            }, t2.inspect = function() {
              return "[Emscripten Module object]";
            }) : (f || m) && (m ? b = self.location.href : "undefined" != typeof document && document.currentScript && (b = document.currentScript.src), r && (b = r), b = 0 !== b.indexOf("blob:") ? b.substr(0, b.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", s = (e4) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e4, false), t3.send(null), t3.responseText;
            }, m && (l = (e4) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e4, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), a = (e4, t3, n2) => {
              var r2 = new XMLHttpRequest();
              r2.open("GET", e4, true), r2.responseType = "arraybuffer", r2.onload = () => {
                200 == r2.status || 0 == r2.status && r2.response ? t3(r2.response) : n2();
              }, r2.onerror = n2, r2.send(null);
            });
            var w, x = t2.print || console.log.bind(console), y = t2.printErr || console.warn.bind(console);
            Object.assign(t2, d), d = null, t2.thisProgram && (_ = t2.thisProgram), t2.quit && (h = t2.quit), t2.wasmBinary && (w = t2.wasmBinary);
            var T = t2.noExitRuntime || false;
            "object" != typeof WebAssembly && H("no native wasm support detected");
            var v, k, M, S, P, A, F = false, C = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
            function E(e4, t3, n2) {
              var r2 = (t3 >>>= 0) + n2;
              for (n2 = t3; e4[n2] && !(n2 >= r2); ) ++n2;
              if (16 < n2 - t3 && e4.buffer && C) return C.decode(e4.subarray(t3, n2));
              for (r2 = ""; t3 < n2; ) {
                var o3 = e4[t3++];
                if (128 & o3) {
                  var i2 = 63 & e4[t3++];
                  if (192 == (224 & o3)) r2 += String.fromCharCode((31 & o3) << 6 | i2);
                  else {
                    var s2 = 63 & e4[t3++];
                    65536 > (o3 = 224 == (240 & o3) ? (15 & o3) << 12 | i2 << 6 | s2 : (7 & o3) << 18 | i2 << 12 | s2 << 6 | 63 & e4[t3++]) ? r2 += String.fromCharCode(o3) : (o3 -= 65536, r2 += String.fromCharCode(55296 | o3 >> 10, 56320 | 1023 & o3));
                  }
                } else r2 += String.fromCharCode(o3);
              }
              return r2;
            }
            function O(e4, t3) {
              return (e4 >>>= 0) ? E(S, e4, t3) : "";
            }
            function I(e4, t3, n2, r2) {
              if (!(0 < r2)) return 0;
              var o3 = n2 >>>= 0;
              r2 = n2 + r2 - 1;
              for (var i2 = 0; i2 < e4.length; ++i2) {
                var s2 = e4.charCodeAt(i2);
                if (55296 <= s2 && 57343 >= s2 && (s2 = 65536 + ((1023 & s2) << 10) | 1023 & e4.charCodeAt(++i2)), 127 >= s2) {
                  if (n2 >= r2) break;
                  t3[n2++ >>> 0] = s2;
                } else {
                  if (2047 >= s2) {
                    if (n2 + 1 >= r2) break;
                    t3[n2++ >>> 0] = 192 | s2 >> 6;
                  } else {
                    if (65535 >= s2) {
                      if (n2 + 2 >= r2) break;
                      t3[n2++ >>> 0] = 224 | s2 >> 12;
                    } else {
                      if (n2 + 3 >= r2) break;
                      t3[n2++ >>> 0] = 240 | s2 >> 18, t3[n2++ >>> 0] = 128 | s2 >> 12 & 63;
                    }
                    t3[n2++ >>> 0] = 128 | s2 >> 6 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | 63 & s2;
                }
              }
              return t3[n2 >>> 0] = 0, n2 - o3;
            }
            function D(e4) {
              for (var t3 = 0, n2 = 0; n2 < e4.length; ++n2) {
                var r2 = e4.charCodeAt(n2);
                127 >= r2 ? t3++ : 2047 >= r2 ? t3 += 2 : 55296 <= r2 && 57343 >= r2 ? (t3 += 4, ++n2) : t3 += 3;
              }
              return t3;
            }
            function L() {
              var e4 = v.buffer;
              k = e4, t2.HEAP8 = M = new Int8Array(e4), t2.HEAP16 = new Int16Array(e4), t2.HEAP32 = P = new Int32Array(e4), t2.HEAPU8 = S = new Uint8Array(e4), t2.HEAPU16 = new Uint16Array(e4), t2.HEAPU32 = A = new Uint32Array(e4), t2.HEAPF32 = new Float32Array(e4), t2.HEAPF64 = new Float64Array(e4);
            }
            var $, N = [], B = [], z = [], R = [], j = 0;
            function V() {
              var e4 = t2.preRun.shift();
              N.unshift(e4);
            }
            var U, G = 0, q = null, W = null;
            function H(e4) {
              throw t2.onAbort && t2.onAbort(e4), y(e4 = "Aborted(" + e4 + ")"), F = true, e4 = new WebAssembly.RuntimeError(e4 + ". Build with -sASSERTIONS for more info."), i(e4), e4;
            }
            function X() {
              return U.startsWith("data:application/octet-stream;base64,");
            }
            if (U = "ort-wasm.wasm", !X()) {
              var Q = U;
              U = t2.locateFile ? t2.locateFile(Q, b) : b + Q;
            }
            function Y() {
              var e4 = U;
              try {
                if (e4 == U && w) return new Uint8Array(w);
                if (l) return l(e4);
                throw "both async and sync fetching of the wasm failed";
              } catch (e5) {
                H(e5);
              }
            }
            function K(e4) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + e4 + ")", this.status = e4;
            }
            function Z(e4) {
              for (; 0 < e4.length; ) e4.shift()(t2);
            }
            var J = [], ee = 0, te = 0;
            function ne(e4) {
              this.Db = e4, this.zb = e4 - 24, this.Ub = function(e5) {
                A[this.zb + 4 >> 2 >>> 0] = e5;
              }, this.Eb = function() {
                return A[this.zb + 4 >> 2 >>> 0];
              }, this.Sb = function(e5) {
                A[this.zb + 8 >> 2 >>> 0] = e5;
              }, this.Wb = function() {
                return A[this.zb + 8 >> 2 >>> 0];
              }, this.Tb = function() {
                P[this.zb >> 2 >>> 0] = 0;
              }, this.Ib = function(e5) {
                M[this.zb + 12 >> 0 >>> 0] = e5 ? 1 : 0;
              }, this.Pb = function() {
                return 0 != M[this.zb + 12 >> 0 >>> 0];
              }, this.Jb = function(e5) {
                M[this.zb + 13 >> 0 >>> 0] = e5 ? 1 : 0;
              }, this.Lb = function() {
                return 0 != M[this.zb + 13 >> 0 >>> 0];
              }, this.Rb = function(e5, t3) {
                this.Fb(0), this.Ub(e5), this.Sb(t3), this.Tb(), this.Ib(false), this.Jb(false);
              }, this.Nb = function() {
                P[this.zb >> 2 >>> 0] += 1;
              }, this.Xb = function() {
                var e5 = P[this.zb >> 2 >>> 0];
                return P[this.zb >> 2 >>> 0] = e5 - 1, 1 === e5;
              }, this.Fb = function(e5) {
                A[this.zb + 16 >> 2 >>> 0] = e5;
              }, this.Ob = function() {
                return A[this.zb + 16 >> 2 >>> 0];
              }, this.Qb = function() {
                if (Ae(this.Eb())) return A[this.Db >> 2 >>> 0];
                var e5 = this.Ob();
                return 0 !== e5 ? e5 : this.Db;
              };
            }
            function re(e4) {
              return xe(new ne(e4).zb);
            }
            var oe = [];
            function ie(e4) {
              var t3 = oe[e4];
              return t3 || (e4 >= oe.length && (oe.length = e4 + 1), oe[e4] = t3 = $.get(e4)), t3;
            }
            function se(e4) {
              var t3 = D(e4) + 1, n2 = we(t3);
              return n2 && I(e4, M, n2, t3), n2;
            }
            var ae = {};
            function le() {
              if (!ce) {
                var e4, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: _ || "./this.program" };
                for (e4 in ae) void 0 === ae[e4] ? delete t3[e4] : t3[e4] = ae[e4];
                var n2 = [];
                for (e4 in t3) n2.push(e4 + "=" + t3[e4]);
                ce = n2;
              }
              return ce;
            }
            var ce, ue = [null, [], []];
            function pe(e4, t3) {
              var n2 = ue[e4];
              0 === t3 || 10 === t3 ? ((1 === e4 ? x : y)(E(n2, 0)), n2.length = 0) : n2.push(t3);
            }
            var de = 0;
            function _e(e4) {
              return 0 == e4 % 4 && (0 != e4 % 100 || 0 == e4 % 400);
            }
            var he = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], fe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function me(e4, t3, n2, r2) {
              function o3(e5, t4, n3) {
                for (e5 = "number" == typeof e5 ? e5.toString() : e5 || ""; e5.length < t4; ) e5 = n3[0] + e5;
                return e5;
              }
              function i2(e5, t4) {
                return o3(e5, t4, "0");
              }
              function s2(e5, t4) {
                function n3(e6) {
                  return 0 > e6 ? -1 : 0 < e6 ? 1 : 0;
                }
                var r3;
                return 0 === (r3 = n3(e5.getFullYear() - t4.getFullYear())) && 0 === (r3 = n3(e5.getMonth() - t4.getMonth())) && (r3 = n3(e5.getDate() - t4.getDate())), r3;
              }
              function a2(e5) {
                switch (e5.getDay()) {
                  case 0:
                    return new Date(e5.getFullYear() - 1, 11, 29);
                  case 1:
                    return e5;
                  case 2:
                    return new Date(e5.getFullYear(), 0, 3);
                  case 3:
                    return new Date(e5.getFullYear(), 0, 2);
                  case 4:
                    return new Date(e5.getFullYear(), 0, 1);
                  case 5:
                    return new Date(e5.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(e5.getFullYear() - 1, 11, 30);
                }
              }
              function l2(e5) {
                var t4 = e5.Bb;
                for (e5 = new Date(new Date(e5.Cb + 1900, 0, 1).getTime()); 0 < t4; ) {
                  var n3 = e5.getMonth(), r3 = (_e(e5.getFullYear()) ? he : fe)[n3];
                  if (!(t4 > r3 - e5.getDate())) {
                    e5.setDate(e5.getDate() + t4);
                    break;
                  }
                  t4 -= r3 - e5.getDate() + 1, e5.setDate(1), 11 > n3 ? e5.setMonth(n3 + 1) : (e5.setMonth(0), e5.setFullYear(e5.getFullYear() + 1));
                }
                return n3 = new Date(e5.getFullYear() + 1, 0, 4), t4 = a2(new Date(e5.getFullYear(), 0, 4)), n3 = a2(n3), 0 >= s2(t4, e5) ? 0 >= s2(n3, e5) ? e5.getFullYear() + 1 : e5.getFullYear() : e5.getFullYear() - 1;
              }
              var c2 = P[r2 + 40 >> 2 >>> 0];
              for (var u2 in r2 = { $b: P[r2 >> 2 >>> 0], Zb: P[r2 + 4 >> 2 >>> 0], Gb: P[r2 + 8 >> 2 >>> 0], Kb: P[r2 + 12 >> 2 >>> 0], Hb: P[r2 + 16 >> 2 >>> 0], Cb: P[r2 + 20 >> 2 >>> 0], Ab: P[r2 + 24 >> 2 >>> 0], Bb: P[r2 + 28 >> 2 >>> 0], bc: P[r2 + 32 >> 2 >>> 0], Yb: P[r2 + 36 >> 2 >>> 0], ac: c2 ? O(c2) : "" }, n2 = O(n2), c2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) n2 = n2.replace(new RegExp(u2, "g"), c2[u2]);
              var p2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), d2 = "January February March April May June July August September October November December".split(" ");
              for (u2 in c2 = { "%a": function(e5) {
                return p2[e5.Ab].substring(0, 3);
              }, "%A": function(e5) {
                return p2[e5.Ab];
              }, "%b": function(e5) {
                return d2[e5.Hb].substring(0, 3);
              }, "%B": function(e5) {
                return d2[e5.Hb];
              }, "%C": function(e5) {
                return i2((e5.Cb + 1900) / 100 | 0, 2);
              }, "%d": function(e5) {
                return i2(e5.Kb, 2);
              }, "%e": function(e5) {
                return o3(e5.Kb, 2, " ");
              }, "%g": function(e5) {
                return l2(e5).toString().substring(2);
              }, "%G": function(e5) {
                return l2(e5);
              }, "%H": function(e5) {
                return i2(e5.Gb, 2);
              }, "%I": function(e5) {
                return 0 == (e5 = e5.Gb) ? e5 = 12 : 12 < e5 && (e5 -= 12), i2(e5, 2);
              }, "%j": function(e5) {
                for (var t4 = 0, n3 = 0; n3 <= e5.Hb - 1; t4 += (_e(e5.Cb + 1900) ? he : fe)[n3++]) ;
                return i2(e5.Kb + t4, 3);
              }, "%m": function(e5) {
                return i2(e5.Hb + 1, 2);
              }, "%M": function(e5) {
                return i2(e5.Zb, 2);
              }, "%n": function() {
                return "\n";
              }, "%p": function(e5) {
                return 0 <= e5.Gb && 12 > e5.Gb ? "AM" : "PM";
              }, "%S": function(e5) {
                return i2(e5.$b, 2);
              }, "%t": function() {
                return "	";
              }, "%u": function(e5) {
                return e5.Ab || 7;
              }, "%U": function(e5) {
                return i2(Math.floor((e5.Bb + 7 - e5.Ab) / 7), 2);
              }, "%V": function(e5) {
                var t4 = Math.floor((e5.Bb + 7 - (e5.Ab + 6) % 7) / 7);
                if (2 >= (e5.Ab + 371 - e5.Bb - 2) % 7 && t4++, t4) 53 == t4 && (4 == (n3 = (e5.Ab + 371 - e5.Bb) % 7) || 3 == n3 && _e(e5.Cb) || (t4 = 1));
                else {
                  t4 = 52;
                  var n3 = (e5.Ab + 7 - e5.Bb - 1) % 7;
                  (4 == n3 || 5 == n3 && _e(e5.Cb % 400 - 1)) && t4++;
                }
                return i2(t4, 2);
              }, "%w": function(e5) {
                return e5.Ab;
              }, "%W": function(e5) {
                return i2(Math.floor((e5.Bb + 7 - (e5.Ab + 6) % 7) / 7), 2);
              }, "%y": function(e5) {
                return (e5.Cb + 1900).toString().substring(2);
              }, "%Y": function(e5) {
                return e5.Cb + 1900;
              }, "%z": function(e5) {
                var t4 = 0 <= (e5 = e5.Yb);
                return e5 = Math.abs(e5) / 60, (t4 ? "+" : "-") + String("0000" + (e5 / 60 * 100 + e5 % 60)).slice(-4);
              }, "%Z": function(e5) {
                return e5.ac;
              }, "%%": function() {
                return "%";
              } }, n2 = n2.replace(/%%/g, "\0\0"), c2) n2.includes(u2) && (n2 = n2.replace(new RegExp(u2, "g"), c2[u2](r2)));
              return u2 = (function(e5) {
                var t4 = Array(D(e5) + 1);
                return I(e5, t4, 0, t4.length), t4;
              })(n2 = n2.replace(/\0\0/g, "%")), u2.length > t3 ? 0 : (M.set(u2, e4 >>> 0), u2.length - 1);
            }
            var ge = { a: function(e4) {
              return we(e4 + 24) + 24;
            }, m: function(e4) {
              return (e4 = new ne(e4)).Pb() || (e4.Ib(true), ee--), e4.Jb(false), J.push(e4), e4.Nb(), e4.Qb();
            }, ia: function(e4) {
              throw y("Unexpected exception thrown, this is not properly supported - aborting"), F = true, e4;
            }, w: function() {
              ve(0);
              var e4 = J.pop();
              if (e4.Xb() && !e4.Lb()) {
                var t3 = e4.Wb();
                t3 && ie(t3)(e4.Db), re(e4.Db);
              }
              te = 0;
            }, d: function() {
              var e4 = te;
              if (!e4) return de = 0;
              var t3 = new ne(e4);
              t3.Fb(e4);
              var n2 = t3.Eb();
              if (!n2) return de = 0, e4;
              for (var r2 = Array.prototype.slice.call(arguments), o3 = 0; o3 < r2.length; o3++) {
                var i2 = r2[o3];
                if (0 === i2 || i2 === n2) break;
                if (Pe(i2, n2, t3.zb + 16)) return de = i2, e4;
              }
              return de = n2, e4;
            }, k: function() {
              var e4 = te;
              if (!e4) return de = 0;
              var t3 = new ne(e4);
              t3.Fb(e4);
              var n2 = t3.Eb();
              if (!n2) return de = 0, e4;
              for (var r2 = Array.prototype.slice.call(arguments), o3 = 0; o3 < r2.length; o3++) {
                var i2 = r2[o3];
                if (0 === i2 || i2 === n2) break;
                if (Pe(i2, n2, t3.zb + 16)) return de = i2, e4;
              }
              return de = n2, e4;
            }, g: function() {
              var e4 = te;
              if (!e4) return de = 0;
              var t3 = new ne(e4);
              t3.Fb(e4);
              var n2 = t3.Eb();
              if (!n2) return de = 0, e4;
              for (var r2 = Array.prototype.slice.call(arguments), o3 = 0; o3 < r2.length; o3++) {
                var i2 = r2[o3];
                if (0 === i2 || i2 === n2) break;
                if (Pe(i2, n2, t3.zb + 16)) return de = i2, e4;
              }
              return de = n2, e4;
            }, s: re, L: function() {
              var e4 = J.pop();
              e4 || H("no exception to throw");
              var t3 = e4.Db;
              throw e4.Lb() || (J.push(e4), e4.Jb(true), e4.Ib(false), ee++), te = t3, t3;
            }, b: function(e4, t3, n2) {
              throw new ne(e4).Rb(t3, n2), te = e4, ee++, e4;
            }, la: function() {
              return ee;
            }, i: function(e4) {
              throw te || (te = e4), e4;
            }, H: function() {
              return 0;
            }, Ba: function() {
            }, pa: function() {
            }, ra: function() {
            }, ka: function() {
              return 0;
            }, za: function() {
            }, ua: function() {
            }, ya: function() {
            }, R: function() {
            }, qa: function() {
            }, na: function() {
            }, Aa: function() {
            }, oa: function() {
            }, Ha: function() {
            }, Ja: function() {
              H("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, Ia: function() {
              H("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, S: function() {
              return Date.now();
            }, Ca: function() {
              return true;
            }, Da: function(e4, t3) {
              e4 = new Date(1e3 * (A[e4 >>> 2] + 4294967296 * P[e4 + 4 >>> 2])), P[t3 >> 2 >>> 0] = e4.getUTCSeconds(), P[t3 + 4 >> 2 >>> 0] = e4.getUTCMinutes(), P[t3 + 8 >> 2 >>> 0] = e4.getUTCHours(), P[t3 + 12 >> 2 >>> 0] = e4.getUTCDate(), P[t3 + 16 >> 2 >>> 0] = e4.getUTCMonth(), P[t3 + 20 >> 2 >>> 0] = e4.getUTCFullYear() - 1900, P[t3 + 24 >> 2 >>> 0] = e4.getUTCDay(), P[t3 + 28 >> 2 >>> 0] = (e4.getTime() - Date.UTC(e4.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
            }, Ea: function(e4, t3) {
              e4 = new Date(1e3 * (A[e4 >>> 2] + 4294967296 * P[e4 + 4 >>> 2])), P[t3 >> 2 >>> 0] = e4.getSeconds(), P[t3 + 4 >> 2 >>> 0] = e4.getMinutes(), P[t3 + 8 >> 2 >>> 0] = e4.getHours(), P[t3 + 12 >> 2 >>> 0] = e4.getDate(), P[t3 + 16 >> 2 >>> 0] = e4.getMonth(), P[t3 + 20 >> 2 >>> 0] = e4.getFullYear() - 1900, P[t3 + 24 >> 2 >>> 0] = e4.getDay();
              var n2 = new Date(e4.getFullYear(), 0, 1);
              P[t3 + 28 >> 2 >>> 0] = (e4.getTime() - n2.getTime()) / 864e5 | 0, P[t3 + 36 >> 2 >>> 0] = -60 * e4.getTimezoneOffset();
              var r2 = new Date(e4.getFullYear(), 6, 1).getTimezoneOffset();
              n2 = n2.getTimezoneOffset(), P[t3 + 32 >> 2 >>> 0] = 0 | (r2 != n2 && e4.getTimezoneOffset() == Math.min(n2, r2));
            }, Fa: function(e4) {
              var t3 = new Date(P[e4 + 20 >> 2 >>> 0] + 1900, P[e4 + 16 >> 2 >>> 0], P[e4 + 12 >> 2 >>> 0], P[e4 + 8 >> 2 >>> 0], P[e4 + 4 >> 2 >>> 0], P[e4 >> 2 >>> 0], 0), n2 = P[e4 + 32 >> 2 >>> 0], r2 = t3.getTimezoneOffset(), o3 = new Date(t3.getFullYear(), 0, 1), i2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), s2 = o3.getTimezoneOffset(), a2 = Math.min(s2, i2);
              return 0 > n2 ? P[e4 + 32 >> 2 >>> 0] = Number(i2 != s2 && a2 == r2) : 0 < n2 != (a2 == r2) && (i2 = Math.max(s2, i2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? a2 : i2) - r2))), P[e4 + 24 >> 2 >>> 0] = t3.getDay(), P[e4 + 28 >> 2 >>> 0] = (t3.getTime() - o3.getTime()) / 864e5 | 0, P[e4 >> 2 >>> 0] = t3.getSeconds(), P[e4 + 4 >> 2 >>> 0] = t3.getMinutes(), P[e4 + 8 >> 2 >>> 0] = t3.getHours(), P[e4 + 12 >> 2 >>> 0] = t3.getDate(), P[e4 + 16 >> 2 >>> 0] = t3.getMonth(), t3.getTime() / 1e3 | 0;
            }, sa: function() {
              return -52;
            }, ta: function() {
            }, Ga: function e4(t3, n2, r2) {
              e4.Vb || (e4.Vb = true, (function(e5, t4, n3) {
                function r3(e6) {
                  return (e6 = e6.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e6[1] : "GMT";
                }
                var o3 = (/* @__PURE__ */ new Date()).getFullYear(), i2 = new Date(o3, 0, 1), s2 = new Date(o3, 6, 1);
                o3 = i2.getTimezoneOffset();
                var a2 = s2.getTimezoneOffset();
                P[e5 >> 2 >>> 0] = 60 * Math.max(o3, a2), P[t4 >> 2 >>> 0] = Number(o3 != a2), e5 = r3(i2), t4 = r3(s2), e5 = se(e5), t4 = se(t4), a2 < o3 ? (A[n3 >> 2 >>> 0] = e5, A[n3 + 4 >> 2 >>> 0] = t4) : (A[n3 >> 2 >>> 0] = t4, A[n3 + 4 >> 2 >>> 0] = e5);
              })(t3, n2, r2));
            }, B: function() {
              H("");
            }, ma: function() {
              return 4294901760;
            }, I: g ? () => {
              var e4 = process.hrtime();
              return 1e3 * e4[0] + e4[1] / 1e6;
            } : () => performance.now(), xa: function(e4, t3, n2) {
              S.copyWithin(e4 >>> 0, t3 >>> 0, t3 + n2 >>> 0);
            }, G: function(e4) {
              var t3 = S.length;
              if (4294901760 < (e4 >>>= 0)) return false;
              for (var n2 = 1; 4 >= n2; n2 *= 2) {
                var r2 = t3 * (1 + 0.2 / n2);
                r2 = Math.min(r2, e4 + 100663296);
                var o3 = Math;
                r2 = Math.max(e4, r2), o3 = o3.min.call(o3, 4294901760, r2 + (65536 - r2 % 65536) % 65536);
                e: {
                  try {
                    v.grow(o3 - k.byteLength + 65535 >>> 16), L();
                    var i2 = 1;
                    break e;
                  } catch (e5) {
                  }
                  i2 = void 0;
                }
                if (i2) return true;
              }
              return false;
            }, va: function(e4, t3) {
              var n2 = 0;
              return le().forEach((function(r2, o3) {
                var i2 = t3 + n2;
                for (o3 = A[e4 + 4 * o3 >> 2 >>> 0] = i2, i2 = 0; i2 < r2.length; ++i2) M[o3++ >> 0 >>> 0] = r2.charCodeAt(i2);
                M[o3 >> 0 >>> 0] = 0, n2 += r2.length + 1;
              })), 0;
            }, wa: function(e4, t3) {
              var n2 = le();
              A[e4 >> 2 >>> 0] = n2.length;
              var r2 = 0;
              return n2.forEach((function(e5) {
                r2 += e5.length + 1;
              })), A[t3 >> 2 >>> 0] = r2, 0;
            }, ba: function(e4) {
              T || 0 < j || (Te(), Z(z), ye(0), ue[1].length && pe(1, 10), ue[2].length && pe(2, 10)), T || 0 < j || (t2.onExit && t2.onExit(e4), F = true), h(e4, new K(e4));
            }, E: function() {
              return 52;
            }, Q: function() {
              return 52;
            }, ca: function() {
              return 70;
            }, P: function(e4, t3, n2, r2) {
              for (var o3 = 0, i2 = 0; i2 < n2; i2++) {
                var s2 = A[t3 >> 2 >>> 0], a2 = A[t3 + 4 >> 2 >>> 0];
                t3 += 8;
                for (var l2 = 0; l2 < a2; l2++) pe(e4, S[s2 + l2 >>> 0]);
                o3 += a2;
              }
              return A[r2 >> 2 >>> 0] = o3, 0;
            }, c: function() {
              return de;
            }, ja: function e4(t3, r2) {
              e4.Mb || (e4.Mb = (function() {
                if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                  var e5 = new Uint8Array(1);
                  return () => (crypto.getRandomValues(e5), e5[0]);
                }
                if (g) try {
                  var t4 = n(Object((function() {
                    var e6 = new Error("Cannot find module 'crypto'");
                    throw e6.code = "MODULE_NOT_FOUND", e6;
                  })()));
                  return () => t4.randomBytes(1)[0];
                } catch (e6) {
                }
                return () => H("randomDevice");
              })());
              for (var o3 = 0; o3 < r2; o3++) M[t3 + o3 >> 0 >>> 0] = e4.Mb();
              return 0;
            }, ea: function(e4, t3, n2) {
              var r2 = ke();
              try {
                return ie(e4)(t3, n2);
              } catch (e5) {
                if (Me(r2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, fa: function(e4, t3, n2) {
              var r2 = ke();
              try {
                return ie(e4)(t3, n2);
              } catch (e5) {
                if (Me(r2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, J: function(e4) {
              var t3 = ke();
              try {
                return ie(e4)();
              } catch (e5) {
                if (Me(t3), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, e: function(e4, t3) {
              var n2 = ke();
              try {
                return ie(e4)(t3);
              } catch (e5) {
                if (Me(n2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, N: function(e4, t3, n2) {
              var r2 = ke();
              try {
                return ie(e4)(t3, n2);
              } catch (e5) {
                if (Me(r2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, O: function(e4, t3, n2) {
              var r2 = ke();
              try {
                return ie(e4)(t3, n2);
              } catch (e5) {
                if (Me(r2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, j: function(e4, t3, n2) {
              var r2 = ke();
              try {
                return ie(e4)(t3, n2);
              } catch (e5) {
                if (Me(r2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, o: function(e4, t3, n2, r2) {
              var o3 = ke();
              try {
                return ie(e4)(t3, n2, r2);
              } catch (e5) {
                if (Me(o3), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, p: function(e4, t3, n2, r2, o3) {
              var i2 = ke();
              try {
                return ie(e4)(t3, n2, r2, o3);
              } catch (e5) {
                if (Me(i2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, M: function(e4, t3, n2, r2, o3, i2) {
              var s2 = ke();
              try {
                return ie(e4)(t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Me(s2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, r: function(e4, t3, n2, r2, o3, i2) {
              var s2 = ke();
              try {
                return ie(e4)(t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Me(s2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, v: function(e4, t3, n2, r2, o3, i2, s2) {
              var a2 = ke();
              try {
                return ie(e4)(t3, n2, r2, o3, i2, s2);
              } catch (e5) {
                if (Me(a2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, K: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = ke();
              try {
                return ie(e4)(t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Me(l2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, D: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2) {
              var d2 = ke();
              try {
                return ie(e4)(t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2);
              } catch (e5) {
                if (Me(d2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, X: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = ke();
              try {
                return Ne(e4, t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Me(l2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, V: function(e4, t3, n2, r2, o3, i2, s2) {
              var a2 = ke();
              try {
                return Ce(e4, t3, n2, r2, o3, i2, s2);
              } catch (e5) {
                if (Me(a2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, U: function(e4, t3, n2, r2, o3) {
              var i2 = ke();
              try {
                return Be(e4, t3, n2, r2, o3);
              } catch (e5) {
                if (Me(i2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, Z: function(e4, t3, n2, r2) {
              var o3 = ke();
              try {
                return Le(e4, t3, n2, r2);
              } catch (e5) {
                if (Me(o3), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, W: function(e4) {
              var t3 = ke();
              try {
                return Fe(e4);
              } catch (e5) {
                if (Me(t3), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, Y: function(e4, t3) {
              var n2 = ke();
              try {
                return $e(e4, t3);
              } catch (e5) {
                if (Me(n2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, T: function(e4, t3, n2) {
              var r2 = ke();
              try {
                return Ee(e4, t3, n2);
              } catch (e5) {
                if (Me(r2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, f: function(e4) {
              var t3 = ke();
              try {
                ie(e4)();
              } catch (e5) {
                if (Me(t3), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, q: function(e4, t3) {
              var n2 = ke();
              try {
                ie(e4)(t3);
              } catch (e5) {
                if (Me(n2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, h: function(e4, t3, n2) {
              var r2 = ke();
              try {
                ie(e4)(t3, n2);
              } catch (e5) {
                if (Me(r2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, da: function(e4, t3, n2, r2) {
              var o3 = ke();
              try {
                ie(e4)(t3, n2, r2);
              } catch (e5) {
                if (Me(o3), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, l: function(e4, t3, n2, r2) {
              var o3 = ke();
              try {
                ie(e4)(t3, n2, r2);
              } catch (e5) {
                if (Me(o3), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, t: function(e4, t3, n2, r2, o3) {
              var i2 = ke();
              try {
                ie(e4)(t3, n2, r2, o3);
              } catch (e5) {
                if (Me(i2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, u: function(e4, t3, n2, r2, o3, i2) {
              var s2 = ke();
              try {
                ie(e4)(t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Me(s2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, x: function(e4, t3, n2, r2, o3, i2, s2) {
              var a2 = ke();
              try {
                ie(e4)(t3, n2, r2, o3, i2, s2);
              } catch (e5) {
                if (Me(a2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, z: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = ke();
              try {
                ie(e4)(t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Me(l2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, ga: function(e4, t3, n2, r2, o3, i2, s2, a2, l2) {
              var c2 = ke();
              try {
                ie(e4)(t3, n2, r2, o3, i2, s2, a2, l2);
              } catch (e5) {
                if (Me(c2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, A: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2) {
              var p2 = ke();
              try {
                ie(e4)(t3, n2, r2, o3, i2, s2, a2, l2, c2, u2);
              } catch (e5) {
                if (Me(p2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, C: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2, d2, _2, h2, f2) {
              var m2 = ke();
              try {
                ie(e4)(t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2, d2, _2, h2, f2);
              } catch (e5) {
                if (Me(m2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, aa: function(e4, t3, n2, r2, o3, i2, s2, a2) {
              var l2 = ke();
              try {
                Oe(e4, t3, n2, r2, o3, i2, s2, a2);
              } catch (e5) {
                if (Me(l2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, _: function(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2) {
              var d2 = ke();
              try {
                De(e4, t3, n2, r2, o3, i2, s2, a2, l2, c2, u2, p2);
              } catch (e5) {
                if (Me(d2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, $: function(e4, t3, n2, r2, o3, i2) {
              var s2 = ke();
              try {
                Ie(e4, t3, n2, r2, o3, i2);
              } catch (e5) {
                if (Me(s2), e5 !== e5 + 0) throw e5;
                ve(1, 0);
              }
            }, n: function(e4) {
              return e4;
            }, F: function(e4) {
              de = e4;
            }, ha: me, y: function(e4, t3, n2, r2) {
              return me(e4, t3, n2, r2);
            } };
            !(function() {
              function e4(e5) {
                t2.asm = e5.exports, v = t2.asm.Ka, L(), $ = t2.asm.ib, B.unshift(t2.asm.La), G--, t2.monitorRunDependencies && t2.monitorRunDependencies(G), 0 == G && (null !== q && (clearInterval(q), q = null), W && (e5 = W, W = null, e5()));
              }
              function n2(t3) {
                e4(t3.instance);
              }
              function r2(e5) {
                return (function() {
                  if (!w && (f || m)) {
                    if ("function" == typeof fetch && !U.startsWith("file://")) return fetch(U, { credentials: "same-origin" }).then((function(e6) {
                      if (!e6.ok) throw "failed to load wasm binary file at '" + U + "'";
                      return e6.arrayBuffer();
                    })).catch((function() {
                      return Y();
                    }));
                    if (a) return new Promise((function(e6, t3) {
                      a(U, (function(t4) {
                        e6(new Uint8Array(t4));
                      }), t3);
                    }));
                  }
                  return Promise.resolve().then((function() {
                    return Y();
                  }));
                })().then((function(e6) {
                  return WebAssembly.instantiate(e6, o3);
                })).then((function(e6) {
                  return e6;
                })).then(e5, (function(e6) {
                  y("failed to asynchronously prepare wasm: " + e6), H(e6);
                }));
              }
              var o3 = { a: ge };
              if (G++, t2.monitorRunDependencies && t2.monitorRunDependencies(G), t2.instantiateWasm) try {
                return t2.instantiateWasm(o3, e4);
              } catch (e5) {
                return y("Module.instantiateWasm callback failed with error: " + e5), false;
              }
              (w || "function" != typeof WebAssembly.instantiateStreaming || X() || U.startsWith("file://") || g || "function" != typeof fetch ? r2(n2) : fetch(U, { credentials: "same-origin" }).then((function(e5) {
                return WebAssembly.instantiateStreaming(e5, o3).then(n2, (function(e6) {
                  return y("wasm streaming compile failed: " + e6), y("falling back to ArrayBuffer instantiation"), r2(n2);
                }));
              }))).catch(i);
            })(), t2.___wasm_call_ctors = function() {
              return (t2.___wasm_call_ctors = t2.asm.La).apply(null, arguments);
            }, t2._OrtInit = function() {
              return (t2._OrtInit = t2.asm.Ma).apply(null, arguments);
            }, t2._OrtCreateSessionOptions = function() {
              return (t2._OrtCreateSessionOptions = t2.asm.Na).apply(null, arguments);
            }, t2._OrtAppendExecutionProvider = function() {
              return (t2._OrtAppendExecutionProvider = t2.asm.Oa).apply(null, arguments);
            }, t2._OrtAddSessionConfigEntry = function() {
              return (t2._OrtAddSessionConfigEntry = t2.asm.Pa).apply(null, arguments);
            }, t2._OrtReleaseSessionOptions = function() {
              return (t2._OrtReleaseSessionOptions = t2.asm.Qa).apply(null, arguments);
            }, t2._OrtCreateSession = function() {
              return (t2._OrtCreateSession = t2.asm.Ra).apply(null, arguments);
            }, t2._OrtReleaseSession = function() {
              return (t2._OrtReleaseSession = t2.asm.Sa).apply(null, arguments);
            }, t2._OrtGetInputCount = function() {
              return (t2._OrtGetInputCount = t2.asm.Ta).apply(null, arguments);
            }, t2._OrtGetOutputCount = function() {
              return (t2._OrtGetOutputCount = t2.asm.Ua).apply(null, arguments);
            }, t2._OrtGetInputName = function() {
              return (t2._OrtGetInputName = t2.asm.Va).apply(null, arguments);
            }, t2._OrtGetOutputName = function() {
              return (t2._OrtGetOutputName = t2.asm.Wa).apply(null, arguments);
            }, t2._OrtFree = function() {
              return (t2._OrtFree = t2.asm.Xa).apply(null, arguments);
            }, t2._OrtCreateTensor = function() {
              return (t2._OrtCreateTensor = t2.asm.Ya).apply(null, arguments);
            }, t2._OrtGetTensorData = function() {
              return (t2._OrtGetTensorData = t2.asm.Za).apply(null, arguments);
            }, t2._OrtReleaseTensor = function() {
              return (t2._OrtReleaseTensor = t2.asm._a).apply(null, arguments);
            }, t2._OrtCreateRunOptions = function() {
              return (t2._OrtCreateRunOptions = t2.asm.$a).apply(null, arguments);
            }, t2._OrtAddRunConfigEntry = function() {
              return (t2._OrtAddRunConfigEntry = t2.asm.ab).apply(null, arguments);
            }, t2._OrtReleaseRunOptions = function() {
              return (t2._OrtReleaseRunOptions = t2.asm.bb).apply(null, arguments);
            }, t2._OrtRun = function() {
              return (t2._OrtRun = t2.asm.cb).apply(null, arguments);
            }, t2._OrtEndProfiling = function() {
              return (t2._OrtEndProfiling = t2.asm.db).apply(null, arguments);
            };
            var be, we = t2._malloc = function() {
              return (we = t2._malloc = t2.asm.eb).apply(null, arguments);
            }, xe = t2._free = function() {
              return (xe = t2._free = t2.asm.fb).apply(null, arguments);
            }, ye = t2._fflush = function() {
              return (ye = t2._fflush = t2.asm.gb).apply(null, arguments);
            }, Te = t2.___funcs_on_exit = function() {
              return (Te = t2.___funcs_on_exit = t2.asm.hb).apply(null, arguments);
            }, ve = t2._setThrew = function() {
              return (ve = t2._setThrew = t2.asm.jb).apply(null, arguments);
            }, ke = t2.stackSave = function() {
              return (ke = t2.stackSave = t2.asm.kb).apply(null, arguments);
            }, Me = t2.stackRestore = function() {
              return (Me = t2.stackRestore = t2.asm.lb).apply(null, arguments);
            }, Se = t2.stackAlloc = function() {
              return (Se = t2.stackAlloc = t2.asm.mb).apply(null, arguments);
            }, Pe = t2.___cxa_can_catch = function() {
              return (Pe = t2.___cxa_can_catch = t2.asm.nb).apply(null, arguments);
            }, Ae = t2.___cxa_is_pointer_type = function() {
              return (Ae = t2.___cxa_is_pointer_type = t2.asm.ob).apply(null, arguments);
            }, Fe = t2.dynCall_j = function() {
              return (Fe = t2.dynCall_j = t2.asm.pb).apply(null, arguments);
            }, Ce = t2.dynCall_iiiiij = function() {
              return (Ce = t2.dynCall_iiiiij = t2.asm.qb).apply(null, arguments);
            }, Ee = t2.dynCall_jii = function() {
              return (Ee = t2.dynCall_jii = t2.asm.rb).apply(null, arguments);
            }, Oe = t2.dynCall_viiiiij = function() {
              return (Oe = t2.dynCall_viiiiij = t2.asm.sb).apply(null, arguments);
            }, Ie = t2.dynCall_vjji = function() {
              return (Ie = t2.dynCall_vjji = t2.asm.tb).apply(null, arguments);
            }, De = t2.dynCall_viiijjjii = function() {
              return (De = t2.dynCall_viiijjjii = t2.asm.ub).apply(null, arguments);
            }, Le = t2.dynCall_iij = function() {
              return (Le = t2.dynCall_iij = t2.asm.vb).apply(null, arguments);
            }, $e = t2.dynCall_ji = function() {
              return ($e = t2.dynCall_ji = t2.asm.wb).apply(null, arguments);
            }, Ne = t2.dynCall_iiiiiij = function() {
              return (Ne = t2.dynCall_iiiiiij = t2.asm.xb).apply(null, arguments);
            }, Be = t2.dynCall_iiij = function() {
              return (Be = t2.dynCall_iiij = t2.asm.yb).apply(null, arguments);
            };
            function ze() {
              function e4() {
                if (!be && (be = true, t2.calledRun = true, !F)) {
                  if (Z(B), o2(t2), t2.onRuntimeInitialized && t2.onRuntimeInitialized(), t2.postRun) for ("function" == typeof t2.postRun && (t2.postRun = [t2.postRun]); t2.postRun.length; ) {
                    var e5 = t2.postRun.shift();
                    R.unshift(e5);
                  }
                  Z(R);
                }
              }
              if (!(0 < G)) {
                if (t2.preRun) for ("function" == typeof t2.preRun && (t2.preRun = [t2.preRun]); t2.preRun.length; ) V();
                Z(N), 0 < G || (t2.setStatus ? (t2.setStatus("Running..."), setTimeout((function() {
                  setTimeout((function() {
                    t2.setStatus("");
                  }), 1), e4();
                }), 1)) : e4());
              }
            }
            if (t2.UTF8ToString = O, t2.stringToUTF8 = function(e4, t3, n2) {
              return I(e4, S, t3, n2);
            }, t2.lengthBytesUTF8 = D, t2.stackSave = ke, t2.stackRestore = Me, t2.stackAlloc = Se, W = function e4() {
              be || ze(), be || (W = e4);
            }, t2.preInit) for ("function" == typeof t2.preInit && (t2.preInit = [t2.preInit]); 0 < t2.preInit.length; ) t2.preInit.pop()();
            return ze(), e3.ready;
          });
          e2.exports = o;
        }, 4537: (e2) => {
          e2.exports = function(e3, t) {
            for (var n = new Array(arguments.length - 1), r = 0, o = 2, i = true; o < arguments.length; ) n[r++] = arguments[o++];
            return new Promise((function(o2, s) {
              n[r] = function(e4) {
                if (i) if (i = false, e4) s(e4);
                else {
                  for (var t2 = new Array(arguments.length - 1), n2 = 0; n2 < t2.length; ) t2[n2++] = arguments[n2];
                  o2.apply(null, t2);
                }
              };
              try {
                e3.apply(t || null, n);
              } catch (e4) {
                i && (i = false, s(e4));
              }
            }));
          };
        }, 7419: (e2, t) => {
          var n = t;
          n.length = function(e3) {
            var t2 = e3.length;
            if (!t2) return 0;
            for (var n2 = 0; --t2 % 4 > 1 && "=" === e3.charAt(t2); ) ++n2;
            return Math.ceil(3 * e3.length) / 4 - n2;
          };
          for (var r = new Array(64), o = new Array(123), i = 0; i < 64; ) o[r[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
          n.encode = function(e3, t2, n2) {
            for (var o2, i2 = null, s2 = [], a = 0, l = 0; t2 < n2; ) {
              var c = e3[t2++];
              switch (l) {
                case 0:
                  s2[a++] = r[c >> 2], o2 = (3 & c) << 4, l = 1;
                  break;
                case 1:
                  s2[a++] = r[o2 | c >> 4], o2 = (15 & c) << 2, l = 2;
                  break;
                case 2:
                  s2[a++] = r[o2 | c >> 6], s2[a++] = r[63 & c], l = 0;
              }
              a > 8191 && ((i2 || (i2 = [])).push(String.fromCharCode.apply(String, s2)), a = 0);
            }
            return l && (s2[a++] = r[o2], s2[a++] = 61, 1 === l && (s2[a++] = 61)), i2 ? (a && i2.push(String.fromCharCode.apply(String, s2.slice(0, a))), i2.join("")) : String.fromCharCode.apply(String, s2.slice(0, a));
          };
          var s = "invalid encoding";
          n.decode = function(e3, t2, n2) {
            for (var r2, i2 = n2, a = 0, l = 0; l < e3.length; ) {
              var c = e3.charCodeAt(l++);
              if (61 === c && a > 1) break;
              if (void 0 === (c = o[c])) throw Error(s);
              switch (a) {
                case 0:
                  r2 = c, a = 1;
                  break;
                case 1:
                  t2[n2++] = r2 << 2 | (48 & c) >> 4, r2 = c, a = 2;
                  break;
                case 2:
                  t2[n2++] = (15 & r2) << 4 | (60 & c) >> 2, r2 = c, a = 3;
                  break;
                case 3:
                  t2[n2++] = (3 & r2) << 6 | c, a = 0;
              }
            }
            if (1 === a) throw Error(s);
            return n2 - i2;
          }, n.test = function(e3) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e3);
          };
        }, 9211: (e2) => {
          function t() {
            this._listeners = {};
          }
          e2.exports = t, t.prototype.on = function(e3, t2, n) {
            return (this._listeners[e3] || (this._listeners[e3] = [])).push({ fn: t2, ctx: n || this }), this;
          }, t.prototype.off = function(e3, t2) {
            if (void 0 === e3) this._listeners = {};
            else if (void 0 === t2) this._listeners[e3] = [];
            else for (var n = this._listeners[e3], r = 0; r < n.length; ) n[r].fn === t2 ? n.splice(r, 1) : ++r;
            return this;
          }, t.prototype.emit = function(e3) {
            var t2 = this._listeners[e3];
            if (t2) {
              for (var n = [], r = 1; r < arguments.length; ) n.push(arguments[r++]);
              for (r = 0; r < t2.length; ) t2[r].fn.apply(t2[r++].ctx, n);
            }
            return this;
          };
        }, 945: (e2) => {
          function t(e3) {
            return "undefined" != typeof Float32Array ? (function() {
              var t2 = new Float32Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[3];
              function o2(e4, r3, o3) {
                t2[0] = e4, r3[o3] = n2[0], r3[o3 + 1] = n2[1], r3[o3 + 2] = n2[2], r3[o3 + 3] = n2[3];
              }
              function i2(e4, r3, o3) {
                t2[0] = e4, r3[o3] = n2[3], r3[o3 + 1] = n2[2], r3[o3 + 2] = n2[1], r3[o3 + 3] = n2[0];
              }
              function s(e4, r3) {
                return n2[0] = e4[r3], n2[1] = e4[r3 + 1], n2[2] = e4[r3 + 2], n2[3] = e4[r3 + 3], t2[0];
              }
              function a(e4, r3) {
                return n2[3] = e4[r3], n2[2] = e4[r3 + 1], n2[1] = e4[r3 + 2], n2[0] = e4[r3 + 3], t2[0];
              }
              e3.writeFloatLE = r2 ? o2 : i2, e3.writeFloatBE = r2 ? i2 : o2, e3.readFloatLE = r2 ? s : a, e3.readFloatBE = r2 ? a : s;
            })() : (function() {
              function t2(e4, t3, n2, r2) {
                var o2 = t3 < 0 ? 1 : 0;
                if (o2 && (t3 = -t3), 0 === t3) e4(1 / t3 > 0 ? 0 : 2147483648, n2, r2);
                else if (isNaN(t3)) e4(2143289344, n2, r2);
                else if (t3 > 34028234663852886e22) e4((o2 << 31 | 2139095040) >>> 0, n2, r2);
                else if (t3 < 11754943508222875e-54) e4((o2 << 31 | Math.round(t3 / 1401298464324817e-60)) >>> 0, n2, r2);
                else {
                  var i2 = Math.floor(Math.log(t3) / Math.LN2);
                  e4((o2 << 31 | i2 + 127 << 23 | 8388607 & Math.round(t3 * Math.pow(2, -i2) * 8388608)) >>> 0, n2, r2);
                }
              }
              function s(e4, t3, n2) {
                var r2 = e4(t3, n2), o2 = 2 * (r2 >> 31) + 1, i2 = r2 >>> 23 & 255, s2 = 8388607 & r2;
                return 255 === i2 ? s2 ? NaN : o2 * (1 / 0) : 0 === i2 ? 1401298464324817e-60 * o2 * s2 : o2 * Math.pow(2, i2 - 150) * (s2 + 8388608);
              }
              e3.writeFloatLE = t2.bind(null, n), e3.writeFloatBE = t2.bind(null, r), e3.readFloatLE = s.bind(null, o), e3.readFloatBE = s.bind(null, i);
            })(), "undefined" != typeof Float64Array ? (function() {
              var t2 = new Float64Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[7];
              function o2(e4, r3, o3) {
                t2[0] = e4, r3[o3] = n2[0], r3[o3 + 1] = n2[1], r3[o3 + 2] = n2[2], r3[o3 + 3] = n2[3], r3[o3 + 4] = n2[4], r3[o3 + 5] = n2[5], r3[o3 + 6] = n2[6], r3[o3 + 7] = n2[7];
              }
              function i2(e4, r3, o3) {
                t2[0] = e4, r3[o3] = n2[7], r3[o3 + 1] = n2[6], r3[o3 + 2] = n2[5], r3[o3 + 3] = n2[4], r3[o3 + 4] = n2[3], r3[o3 + 5] = n2[2], r3[o3 + 6] = n2[1], r3[o3 + 7] = n2[0];
              }
              function s(e4, r3) {
                return n2[0] = e4[r3], n2[1] = e4[r3 + 1], n2[2] = e4[r3 + 2], n2[3] = e4[r3 + 3], n2[4] = e4[r3 + 4], n2[5] = e4[r3 + 5], n2[6] = e4[r3 + 6], n2[7] = e4[r3 + 7], t2[0];
              }
              function a(e4, r3) {
                return n2[7] = e4[r3], n2[6] = e4[r3 + 1], n2[5] = e4[r3 + 2], n2[4] = e4[r3 + 3], n2[3] = e4[r3 + 4], n2[2] = e4[r3 + 5], n2[1] = e4[r3 + 6], n2[0] = e4[r3 + 7], t2[0];
              }
              e3.writeDoubleLE = r2 ? o2 : i2, e3.writeDoubleBE = r2 ? i2 : o2, e3.readDoubleLE = r2 ? s : a, e3.readDoubleBE = r2 ? a : s;
            })() : (function() {
              function t2(e4, t3, n2, r2, o2, i2) {
                var s2 = r2 < 0 ? 1 : 0;
                if (s2 && (r2 = -r2), 0 === r2) e4(0, o2, i2 + t3), e4(1 / r2 > 0 ? 0 : 2147483648, o2, i2 + n2);
                else if (isNaN(r2)) e4(0, o2, i2 + t3), e4(2146959360, o2, i2 + n2);
                else if (r2 > 17976931348623157e292) e4(0, o2, i2 + t3), e4((s2 << 31 | 2146435072) >>> 0, o2, i2 + n2);
                else {
                  var a;
                  if (r2 < 22250738585072014e-324) e4((a = r2 / 5e-324) >>> 0, o2, i2 + t3), e4((s2 << 31 | a / 4294967296) >>> 0, o2, i2 + n2);
                  else {
                    var l = Math.floor(Math.log(r2) / Math.LN2);
                    1024 === l && (l = 1023), e4(4503599627370496 * (a = r2 * Math.pow(2, -l)) >>> 0, o2, i2 + t3), e4((s2 << 31 | l + 1023 << 20 | 1048576 * a & 1048575) >>> 0, o2, i2 + n2);
                  }
                }
              }
              function s(e4, t3, n2, r2, o2) {
                var i2 = e4(r2, o2 + t3), s2 = e4(r2, o2 + n2), a = 2 * (s2 >> 31) + 1, l = s2 >>> 20 & 2047, c = 4294967296 * (1048575 & s2) + i2;
                return 2047 === l ? c ? NaN : a * (1 / 0) : 0 === l ? 5e-324 * a * c : a * Math.pow(2, l - 1075) * (c + 4503599627370496);
              }
              e3.writeDoubleLE = t2.bind(null, n, 0, 4), e3.writeDoubleBE = t2.bind(null, r, 4, 0), e3.readDoubleLE = s.bind(null, o, 0, 4), e3.readDoubleBE = s.bind(null, i, 4, 0);
            })(), e3;
          }
          function n(e3, t2, n2) {
            t2[n2] = 255 & e3, t2[n2 + 1] = e3 >>> 8 & 255, t2[n2 + 2] = e3 >>> 16 & 255, t2[n2 + 3] = e3 >>> 24;
          }
          function r(e3, t2, n2) {
            t2[n2] = e3 >>> 24, t2[n2 + 1] = e3 >>> 16 & 255, t2[n2 + 2] = e3 >>> 8 & 255, t2[n2 + 3] = 255 & e3;
          }
          function o(e3, t2) {
            return (e3[t2] | e3[t2 + 1] << 8 | e3[t2 + 2] << 16 | e3[t2 + 3] << 24) >>> 0;
          }
          function i(e3, t2) {
            return (e3[t2] << 24 | e3[t2 + 1] << 16 | e3[t2 + 2] << 8 | e3[t2 + 3]) >>> 0;
          }
          e2.exports = t(t);
        }, 7199: (module) => {
          function inquire(moduleName) {
            try {
              var mod = eval("quire".replace(/^/, "re"))(moduleName);
              if (mod && (mod.length || Object.keys(mod).length)) return mod;
            } catch (e2) {
            }
            return null;
          }
          module.exports = inquire;
        }, 6662: (e2) => {
          e2.exports = function(e3, t, n) {
            var r = n || 8192, o = r >>> 1, i = null, s = r;
            return function(n2) {
              if (n2 < 1 || n2 > o) return e3(n2);
              s + n2 > r && (i = e3(r), s = 0);
              var a = t.call(i, s, s += n2);
              return 7 & s && (s = 1 + (7 | s)), a;
            };
          };
        }, 4997: (e2, t) => {
          var n = t;
          n.length = function(e3) {
            for (var t2 = 0, n2 = 0, r = 0; r < e3.length; ++r) (n2 = e3.charCodeAt(r)) < 128 ? t2 += 1 : n2 < 2048 ? t2 += 2 : 55296 == (64512 & n2) && 56320 == (64512 & e3.charCodeAt(r + 1)) ? (++r, t2 += 4) : t2 += 3;
            return t2;
          }, n.read = function(e3, t2, n2) {
            if (n2 - t2 < 1) return "";
            for (var r, o = null, i = [], s = 0; t2 < n2; ) (r = e3[t2++]) < 128 ? i[s++] = r : r > 191 && r < 224 ? i[s++] = (31 & r) << 6 | 63 & e3[t2++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & e3[t2++]) << 12 | (63 & e3[t2++]) << 6 | 63 & e3[t2++]) - 65536, i[s++] = 55296 + (r >> 10), i[s++] = 56320 + (1023 & r)) : i[s++] = (15 & r) << 12 | (63 & e3[t2++]) << 6 | 63 & e3[t2++], s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), s = 0);
            return o ? (s && o.push(String.fromCharCode.apply(String, i.slice(0, s))), o.join("")) : String.fromCharCode.apply(String, i.slice(0, s));
          }, n.write = function(e3, t2, n2) {
            for (var r, o, i = n2, s = 0; s < e3.length; ++s) (r = e3.charCodeAt(s)) < 128 ? t2[n2++] = r : r < 2048 ? (t2[n2++] = r >> 6 | 192, t2[n2++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (o = e3.charCodeAt(s + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & o), ++s, t2[n2++] = r >> 18 | 240, t2[n2++] = r >> 12 & 63 | 128, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128) : (t2[n2++] = r >> 12 | 224, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128);
            return n2 - i;
          };
        }, 3442: (e2, t) => {
          t.__esModule = true;
          var n = (function() {
            function e3(t2) {
              if (!t2) throw new TypeError("Invalid argument; `value` has no value.");
              this.value = e3.EMPTY, t2 && e3.isGuid(t2) && (this.value = t2);
            }
            return e3.isGuid = function(t2) {
              var n2 = t2.toString();
              return t2 && (t2 instanceof e3 || e3.validator.test(n2));
            }, e3.create = function() {
              return new e3([e3.gen(2), e3.gen(1), e3.gen(1), e3.gen(1), e3.gen(3)].join("-"));
            }, e3.createEmpty = function() {
              return new e3("emptyguid");
            }, e3.parse = function(t2) {
              return new e3(t2);
            }, e3.raw = function() {
              return [e3.gen(2), e3.gen(1), e3.gen(1), e3.gen(1), e3.gen(3)].join("-");
            }, e3.gen = function(e4) {
              for (var t2 = "", n2 = 0; n2 < e4; n2++) t2 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
              return t2;
            }, e3.prototype.equals = function(t2) {
              return e3.isGuid(t2) && this.value === t2.toString();
            }, e3.prototype.isEmpty = function() {
              return this.value === e3.EMPTY;
            }, e3.prototype.toString = function() {
              return this.value;
            }, e3.prototype.toJSON = function() {
              return { value: this.value };
            }, e3.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), e3.EMPTY = "00000000-0000-0000-0000-000000000000", e3;
          })();
          t.Guid = n;
        }, 3720: (e2) => {
          e2.exports = n;
          var t = null;
          try {
            t = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
          } catch (e3) {
          }
          function n(e3, t2, n2) {
            this.low = 0 | e3, this.high = 0 | t2, this.unsigned = !!n2;
          }
          function r(e3) {
            return true === (e3 && e3.__isLong__);
          }
          n.prototype.__isLong__, Object.defineProperty(n.prototype, "__isLong__", { value: true }), n.isLong = r;
          var o = {}, i = {};
          function s(e3, t2) {
            var n2, r2, s2;
            return t2 ? (s2 = 0 <= (e3 >>>= 0) && e3 < 256) && (r2 = i[e3]) ? r2 : (n2 = l(e3, (0 | e3) < 0 ? -1 : 0, true), s2 && (i[e3] = n2), n2) : (s2 = -128 <= (e3 |= 0) && e3 < 128) && (r2 = o[e3]) ? r2 : (n2 = l(e3, e3 < 0 ? -1 : 0, false), s2 && (o[e3] = n2), n2);
          }
          function a(e3, t2) {
            if (isNaN(e3)) return t2 ? g : m;
            if (t2) {
              if (e3 < 0) return g;
              if (e3 >= _) return T;
            } else {
              if (e3 <= -h) return v;
              if (e3 + 1 >= h) return y;
            }
            return e3 < 0 ? a(-e3, t2).neg() : l(e3 % d | 0, e3 / d | 0, t2);
          }
          function l(e3, t2, r2) {
            return new n(e3, t2, r2);
          }
          n.fromInt = s, n.fromNumber = a, n.fromBits = l;
          var c = Math.pow;
          function u(e3, t2, n2) {
            if (0 === e3.length) throw Error("empty string");
            if ("NaN" === e3 || "Infinity" === e3 || "+Infinity" === e3 || "-Infinity" === e3) return m;
            if ("number" == typeof t2 ? (n2 = t2, t2 = false) : t2 = !!t2, (n2 = n2 || 10) < 2 || 36 < n2) throw RangeError("radix");
            var r2;
            if ((r2 = e3.indexOf("-")) > 0) throw Error("interior hyphen");
            if (0 === r2) return u(e3.substring(1), t2, n2).neg();
            for (var o2 = a(c(n2, 8)), i2 = m, s2 = 0; s2 < e3.length; s2 += 8) {
              var l2 = Math.min(8, e3.length - s2), p2 = parseInt(e3.substring(s2, s2 + l2), n2);
              if (l2 < 8) {
                var d2 = a(c(n2, l2));
                i2 = i2.mul(d2).add(a(p2));
              } else i2 = (i2 = i2.mul(o2)).add(a(p2));
            }
            return i2.unsigned = t2, i2;
          }
          function p(e3, t2) {
            return "number" == typeof e3 ? a(e3, t2) : "string" == typeof e3 ? u(e3, t2) : l(e3.low, e3.high, "boolean" == typeof t2 ? t2 : e3.unsigned);
          }
          n.fromString = u, n.fromValue = p;
          var d = 4294967296, _ = d * d, h = _ / 2, f = s(1 << 24), m = s(0);
          n.ZERO = m;
          var g = s(0, true);
          n.UZERO = g;
          var b = s(1);
          n.ONE = b;
          var w = s(1, true);
          n.UONE = w;
          var x = s(-1);
          n.NEG_ONE = x;
          var y = l(-1, 2147483647, false);
          n.MAX_VALUE = y;
          var T = l(-1, -1, true);
          n.MAX_UNSIGNED_VALUE = T;
          var v = l(0, -2147483648, false);
          n.MIN_VALUE = v;
          var k = n.prototype;
          k.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }, k.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * d + (this.low >>> 0) : this.high * d + (this.low >>> 0);
          }, k.toString = function(e3) {
            if ((e3 = e3 || 10) < 2 || 36 < e3) throw RangeError("radix");
            if (this.isZero()) return "0";
            if (this.isNegative()) {
              if (this.eq(v)) {
                var t2 = a(e3), n2 = this.div(t2), r2 = n2.mul(t2).sub(this);
                return n2.toString(e3) + r2.toInt().toString(e3);
              }
              return "-" + this.neg().toString(e3);
            }
            for (var o2 = a(c(e3, 6), this.unsigned), i2 = this, s2 = ""; ; ) {
              var l2 = i2.div(o2), u2 = (i2.sub(l2.mul(o2)).toInt() >>> 0).toString(e3);
              if ((i2 = l2).isZero()) return u2 + s2;
              for (; u2.length < 6; ) u2 = "0" + u2;
              s2 = "" + u2 + s2;
            }
          }, k.getHighBits = function() {
            return this.high;
          }, k.getHighBitsUnsigned = function() {
            return this.high >>> 0;
          }, k.getLowBits = function() {
            return this.low;
          }, k.getLowBitsUnsigned = function() {
            return this.low >>> 0;
          }, k.getNumBitsAbs = function() {
            if (this.isNegative()) return this.eq(v) ? 64 : this.neg().getNumBitsAbs();
            for (var e3 = 0 != this.high ? this.high : this.low, t2 = 31; t2 > 0 && 0 == (e3 & 1 << t2); t2--) ;
            return 0 != this.high ? t2 + 33 : t2 + 1;
          }, k.isZero = function() {
            return 0 === this.high && 0 === this.low;
          }, k.eqz = k.isZero, k.isNegative = function() {
            return !this.unsigned && this.high < 0;
          }, k.isPositive = function() {
            return this.unsigned || this.high >= 0;
          }, k.isOdd = function() {
            return 1 == (1 & this.low);
          }, k.isEven = function() {
            return 0 == (1 & this.low);
          }, k.equals = function(e3) {
            return r(e3) || (e3 = p(e3)), (this.unsigned === e3.unsigned || this.high >>> 31 != 1 || e3.high >>> 31 != 1) && this.high === e3.high && this.low === e3.low;
          }, k.eq = k.equals, k.notEquals = function(e3) {
            return !this.eq(e3);
          }, k.neq = k.notEquals, k.ne = k.notEquals, k.lessThan = function(e3) {
            return this.comp(e3) < 0;
          }, k.lt = k.lessThan, k.lessThanOrEqual = function(e3) {
            return this.comp(e3) <= 0;
          }, k.lte = k.lessThanOrEqual, k.le = k.lessThanOrEqual, k.greaterThan = function(e3) {
            return this.comp(e3) > 0;
          }, k.gt = k.greaterThan, k.greaterThanOrEqual = function(e3) {
            return this.comp(e3) >= 0;
          }, k.gte = k.greaterThanOrEqual, k.ge = k.greaterThanOrEqual, k.compare = function(e3) {
            if (r(e3) || (e3 = p(e3)), this.eq(e3)) return 0;
            var t2 = this.isNegative(), n2 = e3.isNegative();
            return t2 && !n2 ? -1 : !t2 && n2 ? 1 : this.unsigned ? e3.high >>> 0 > this.high >>> 0 || e3.high === this.high && e3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e3).isNegative() ? -1 : 1;
          }, k.comp = k.compare, k.negate = function() {
            return !this.unsigned && this.eq(v) ? v : this.not().add(b);
          }, k.neg = k.negate, k.add = function(e3) {
            r(e3) || (e3 = p(e3));
            var t2 = this.high >>> 16, n2 = 65535 & this.high, o2 = this.low >>> 16, i2 = 65535 & this.low, s2 = e3.high >>> 16, a2 = 65535 & e3.high, c2 = e3.low >>> 16, u2 = 0, d2 = 0, _2 = 0, h2 = 0;
            return _2 += (h2 += i2 + (65535 & e3.low)) >>> 16, d2 += (_2 += o2 + c2) >>> 16, u2 += (d2 += n2 + a2) >>> 16, u2 += t2 + s2, l((_2 &= 65535) << 16 | (h2 &= 65535), (u2 &= 65535) << 16 | (d2 &= 65535), this.unsigned);
          }, k.subtract = function(e3) {
            return r(e3) || (e3 = p(e3)), this.add(e3.neg());
          }, k.sub = k.subtract, k.multiply = function(e3) {
            if (this.isZero()) return m;
            if (r(e3) || (e3 = p(e3)), t) return l(t.mul(this.low, this.high, e3.low, e3.high), t.get_high(), this.unsigned);
            if (e3.isZero()) return m;
            if (this.eq(v)) return e3.isOdd() ? v : m;
            if (e3.eq(v)) return this.isOdd() ? v : m;
            if (this.isNegative()) return e3.isNegative() ? this.neg().mul(e3.neg()) : this.neg().mul(e3).neg();
            if (e3.isNegative()) return this.mul(e3.neg()).neg();
            if (this.lt(f) && e3.lt(f)) return a(this.toNumber() * e3.toNumber(), this.unsigned);
            var n2 = this.high >>> 16, o2 = 65535 & this.high, i2 = this.low >>> 16, s2 = 65535 & this.low, c2 = e3.high >>> 16, u2 = 65535 & e3.high, d2 = e3.low >>> 16, _2 = 65535 & e3.low, h2 = 0, g2 = 0, b2 = 0, w2 = 0;
            return b2 += (w2 += s2 * _2) >>> 16, g2 += (b2 += i2 * _2) >>> 16, b2 &= 65535, g2 += (b2 += s2 * d2) >>> 16, h2 += (g2 += o2 * _2) >>> 16, g2 &= 65535, h2 += (g2 += i2 * d2) >>> 16, g2 &= 65535, h2 += (g2 += s2 * u2) >>> 16, h2 += n2 * _2 + o2 * d2 + i2 * u2 + s2 * c2, l((b2 &= 65535) << 16 | (w2 &= 65535), (h2 &= 65535) << 16 | (g2 &= 65535), this.unsigned);
          }, k.mul = k.multiply, k.divide = function(e3) {
            if (r(e3) || (e3 = p(e3)), e3.isZero()) throw Error("division by zero");
            var n2, o2, i2;
            if (t) return this.unsigned || -2147483648 !== this.high || -1 !== e3.low || -1 !== e3.high ? l((this.unsigned ? t.div_u : t.div_s)(this.low, this.high, e3.low, e3.high), t.get_high(), this.unsigned) : this;
            if (this.isZero()) return this.unsigned ? g : m;
            if (this.unsigned) {
              if (e3.unsigned || (e3 = e3.toUnsigned()), e3.gt(this)) return g;
              if (e3.gt(this.shru(1))) return w;
              i2 = g;
            } else {
              if (this.eq(v)) return e3.eq(b) || e3.eq(x) ? v : e3.eq(v) ? b : (n2 = this.shr(1).div(e3).shl(1)).eq(m) ? e3.isNegative() ? b : x : (o2 = this.sub(e3.mul(n2)), i2 = n2.add(o2.div(e3)));
              if (e3.eq(v)) return this.unsigned ? g : m;
              if (this.isNegative()) return e3.isNegative() ? this.neg().div(e3.neg()) : this.neg().div(e3).neg();
              if (e3.isNegative()) return this.div(e3.neg()).neg();
              i2 = m;
            }
            for (o2 = this; o2.gte(e3); ) {
              n2 = Math.max(1, Math.floor(o2.toNumber() / e3.toNumber()));
              for (var s2 = Math.ceil(Math.log(n2) / Math.LN2), u2 = s2 <= 48 ? 1 : c(2, s2 - 48), d2 = a(n2), _2 = d2.mul(e3); _2.isNegative() || _2.gt(o2); ) _2 = (d2 = a(n2 -= u2, this.unsigned)).mul(e3);
              d2.isZero() && (d2 = b), i2 = i2.add(d2), o2 = o2.sub(_2);
            }
            return i2;
          }, k.div = k.divide, k.modulo = function(e3) {
            return r(e3) || (e3 = p(e3)), t ? l((this.unsigned ? t.rem_u : t.rem_s)(this.low, this.high, e3.low, e3.high), t.get_high(), this.unsigned) : this.sub(this.div(e3).mul(e3));
          }, k.mod = k.modulo, k.rem = k.modulo, k.not = function() {
            return l(~this.low, ~this.high, this.unsigned);
          }, k.and = function(e3) {
            return r(e3) || (e3 = p(e3)), l(this.low & e3.low, this.high & e3.high, this.unsigned);
          }, k.or = function(e3) {
            return r(e3) || (e3 = p(e3)), l(this.low | e3.low, this.high | e3.high, this.unsigned);
          }, k.xor = function(e3) {
            return r(e3) || (e3 = p(e3)), l(this.low ^ e3.low, this.high ^ e3.high, this.unsigned);
          }, k.shiftLeft = function(e3) {
            return r(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low << e3, this.high << e3 | this.low >>> 32 - e3, this.unsigned) : l(0, this.low << e3 - 32, this.unsigned);
          }, k.shl = k.shiftLeft, k.shiftRight = function(e3) {
            return r(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low >>> e3 | this.high << 32 - e3, this.high >> e3, this.unsigned) : l(this.high >> e3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }, k.shr = k.shiftRight, k.shiftRightUnsigned = function(e3) {
            if (r(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63)) return this;
            var t2 = this.high;
            return e3 < 32 ? l(this.low >>> e3 | t2 << 32 - e3, t2 >>> e3, this.unsigned) : l(32 === e3 ? t2 : t2 >>> e3 - 32, 0, this.unsigned);
          }, k.shru = k.shiftRightUnsigned, k.shr_u = k.shiftRightUnsigned, k.toSigned = function() {
            return this.unsigned ? l(this.low, this.high, false) : this;
          }, k.toUnsigned = function() {
            return this.unsigned ? this : l(this.low, this.high, true);
          }, k.toBytes = function(e3) {
            return e3 ? this.toBytesLE() : this.toBytesBE();
          }, k.toBytesLE = function() {
            var e3 = this.high, t2 = this.low;
            return [255 & t2, t2 >>> 8 & 255, t2 >>> 16 & 255, t2 >>> 24, 255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24];
          }, k.toBytesBE = function() {
            var e3 = this.high, t2 = this.low;
            return [e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3, t2 >>> 24, t2 >>> 16 & 255, t2 >>> 8 & 255, 255 & t2];
          }, n.fromBytes = function(e3, t2, r2) {
            return r2 ? n.fromBytesLE(e3, t2) : n.fromBytesBE(e3, t2);
          }, n.fromBytesLE = function(e3, t2) {
            return new n(e3[0] | e3[1] << 8 | e3[2] << 16 | e3[3] << 24, e3[4] | e3[5] << 8 | e3[6] << 16 | e3[7] << 24, t2);
          }, n.fromBytesBE = function(e3, t2) {
            return new n(e3[4] << 24 | e3[5] << 16 | e3[6] << 8 | e3[7], e3[0] << 24 | e3[1] << 16 | e3[2] << 8 | e3[3], t2);
          };
        }, 1446: (e2, t, n) => {
          var r, o, i, s = n(2100), a = s.Reader, l = s.Writer, c = s.util, u = s.roots.default || (s.roots.default = {});
          u.onnx = ((i = {}).Version = (r = {}, (o = Object.create(r))[r[0] = "_START_VERSION"] = 0, o[r[1] = "IR_VERSION_2017_10_10"] = 1, o[r[2] = "IR_VERSION_2017_10_30"] = 2, o[r[3] = "IR_VERSION_2017_11_3"] = 3, o[r[4] = "IR_VERSION_2019_1_22"] = 4, o[r[5] = "IR_VERSION"] = 5, o), i.AttributeProto = (function() {
            function e3(e4) {
              if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.name = "", e3.prototype.refAttrName = "", e3.prototype.docString = "", e3.prototype.type = 0, e3.prototype.f = 0, e3.prototype.i = c.Long ? c.Long.fromBits(0, 0, false) : 0, e3.prototype.s = c.newBuffer([]), e3.prototype.t = null, e3.prototype.g = null, e3.prototype.floats = c.emptyArray, e3.prototype.ints = c.emptyArray, e3.prototype.strings = c.emptyArray, e3.prototype.tensors = c.emptyArray, e3.prototype.graphs = c.emptyArray, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              if (t2 || (t2 = l.create()), null != e4.name && e4.hasOwnProperty("name") && t2.uint32(10).string(e4.name), null != e4.f && e4.hasOwnProperty("f") && t2.uint32(21).float(e4.f), null != e4.i && e4.hasOwnProperty("i") && t2.uint32(24).int64(e4.i), null != e4.s && e4.hasOwnProperty("s") && t2.uint32(34).bytes(e4.s), null != e4.t && e4.hasOwnProperty("t") && u.onnx.TensorProto.encode(e4.t, t2.uint32(42).fork()).ldelim(), null != e4.g && e4.hasOwnProperty("g") && u.onnx.GraphProto.encode(e4.g, t2.uint32(50).fork()).ldelim(), null != e4.floats && e4.floats.length) {
                t2.uint32(58).fork();
                for (var n2 = 0; n2 < e4.floats.length; ++n2) t2.float(e4.floats[n2]);
                t2.ldelim();
              }
              if (null != e4.ints && e4.ints.length) {
                for (t2.uint32(66).fork(), n2 = 0; n2 < e4.ints.length; ++n2) t2.int64(e4.ints[n2]);
                t2.ldelim();
              }
              if (null != e4.strings && e4.strings.length) for (n2 = 0; n2 < e4.strings.length; ++n2) t2.uint32(74).bytes(e4.strings[n2]);
              if (null != e4.tensors && e4.tensors.length) for (n2 = 0; n2 < e4.tensors.length; ++n2) u.onnx.TensorProto.encode(e4.tensors[n2], t2.uint32(82).fork()).ldelim();
              if (null != e4.graphs && e4.graphs.length) for (n2 = 0; n2 < e4.graphs.length; ++n2) u.onnx.GraphProto.encode(e4.graphs[n2], t2.uint32(90).fork()).ldelim();
              return null != e4.docString && e4.hasOwnProperty("docString") && t2.uint32(106).string(e4.docString), null != e4.type && e4.hasOwnProperty("type") && t2.uint32(160).int32(e4.type), null != e4.refAttrName && e4.hasOwnProperty("refAttrName") && t2.uint32(170).string(e4.refAttrName), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.AttributeProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.name = e4.string();
                    break;
                  case 21:
                    r2.refAttrName = e4.string();
                    break;
                  case 13:
                    r2.docString = e4.string();
                    break;
                  case 20:
                    r2.type = e4.int32();
                    break;
                  case 2:
                    r2.f = e4.float();
                    break;
                  case 3:
                    r2.i = e4.int64();
                    break;
                  case 4:
                    r2.s = e4.bytes();
                    break;
                  case 5:
                    r2.t = u.onnx.TensorProto.decode(e4, e4.uint32());
                    break;
                  case 6:
                    r2.g = u.onnx.GraphProto.decode(e4, e4.uint32());
                    break;
                  case 7:
                    if (r2.floats && r2.floats.length || (r2.floats = []), 2 == (7 & o2)) for (var i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.floats.push(e4.float());
                    else r2.floats.push(e4.float());
                    break;
                  case 8:
                    if (r2.ints && r2.ints.length || (r2.ints = []), 2 == (7 & o2)) for (i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.ints.push(e4.int64());
                    else r2.ints.push(e4.int64());
                    break;
                  case 9:
                    r2.strings && r2.strings.length || (r2.strings = []), r2.strings.push(e4.bytes());
                    break;
                  case 10:
                    r2.tensors && r2.tensors.length || (r2.tensors = []), r2.tensors.push(u.onnx.TensorProto.decode(e4, e4.uint32()));
                    break;
                  case 11:
                    r2.graphs && r2.graphs.length || (r2.graphs = []), r2.graphs.push(u.onnx.GraphProto.decode(e4, e4.uint32()));
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.name && e4.hasOwnProperty("name") && !c.isString(e4.name)) return "name: string expected";
              if (null != e4.refAttrName && e4.hasOwnProperty("refAttrName") && !c.isString(e4.refAttrName)) return "refAttrName: string expected";
              if (null != e4.docString && e4.hasOwnProperty("docString") && !c.isString(e4.docString)) return "docString: string expected";
              if (null != e4.type && e4.hasOwnProperty("type")) switch (e4.type) {
                default:
                  return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
              }
              if (null != e4.f && e4.hasOwnProperty("f") && "number" != typeof e4.f) return "f: number expected";
              if (null != e4.i && e4.hasOwnProperty("i") && !(c.isInteger(e4.i) || e4.i && c.isInteger(e4.i.low) && c.isInteger(e4.i.high))) return "i: integer|Long expected";
              if (null != e4.s && e4.hasOwnProperty("s") && !(e4.s && "number" == typeof e4.s.length || c.isString(e4.s))) return "s: buffer expected";
              if (null != e4.t && e4.hasOwnProperty("t") && (n2 = u.onnx.TensorProto.verify(e4.t))) return "t." + n2;
              if (null != e4.g && e4.hasOwnProperty("g") && (n2 = u.onnx.GraphProto.verify(e4.g))) return "g." + n2;
              if (null != e4.floats && e4.hasOwnProperty("floats")) {
                if (!Array.isArray(e4.floats)) return "floats: array expected";
                for (var t2 = 0; t2 < e4.floats.length; ++t2) if ("number" != typeof e4.floats[t2]) return "floats: number[] expected";
              }
              if (null != e4.ints && e4.hasOwnProperty("ints")) {
                if (!Array.isArray(e4.ints)) return "ints: array expected";
                for (t2 = 0; t2 < e4.ints.length; ++t2) if (!(c.isInteger(e4.ints[t2]) || e4.ints[t2] && c.isInteger(e4.ints[t2].low) && c.isInteger(e4.ints[t2].high))) return "ints: integer|Long[] expected";
              }
              if (null != e4.strings && e4.hasOwnProperty("strings")) {
                if (!Array.isArray(e4.strings)) return "strings: array expected";
                for (t2 = 0; t2 < e4.strings.length; ++t2) if (!(e4.strings[t2] && "number" == typeof e4.strings[t2].length || c.isString(e4.strings[t2]))) return "strings: buffer[] expected";
              }
              if (null != e4.tensors && e4.hasOwnProperty("tensors")) {
                if (!Array.isArray(e4.tensors)) return "tensors: array expected";
                for (t2 = 0; t2 < e4.tensors.length; ++t2) if (n2 = u.onnx.TensorProto.verify(e4.tensors[t2])) return "tensors." + n2;
              }
              if (null != e4.graphs && e4.hasOwnProperty("graphs")) {
                if (!Array.isArray(e4.graphs)) return "graphs: array expected";
                for (t2 = 0; t2 < e4.graphs.length; ++t2) {
                  var n2;
                  if (n2 = u.onnx.GraphProto.verify(e4.graphs[t2])) return "graphs." + n2;
                }
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.AttributeProto) return e4;
              var t2 = new u.onnx.AttributeProto();
              switch (null != e4.name && (t2.name = String(e4.name)), null != e4.refAttrName && (t2.refAttrName = String(e4.refAttrName)), null != e4.docString && (t2.docString = String(e4.docString)), e4.type) {
                case "UNDEFINED":
                case 0:
                  t2.type = 0;
                  break;
                case "FLOAT":
                case 1:
                  t2.type = 1;
                  break;
                case "INT":
                case 2:
                  t2.type = 2;
                  break;
                case "STRING":
                case 3:
                  t2.type = 3;
                  break;
                case "TENSOR":
                case 4:
                  t2.type = 4;
                  break;
                case "GRAPH":
                case 5:
                  t2.type = 5;
                  break;
                case "FLOATS":
                case 6:
                  t2.type = 6;
                  break;
                case "INTS":
                case 7:
                  t2.type = 7;
                  break;
                case "STRINGS":
                case 8:
                  t2.type = 8;
                  break;
                case "TENSORS":
                case 9:
                  t2.type = 9;
                  break;
                case "GRAPHS":
                case 10:
                  t2.type = 10;
              }
              if (null != e4.f && (t2.f = Number(e4.f)), null != e4.i && (c.Long ? (t2.i = c.Long.fromValue(e4.i)).unsigned = false : "string" == typeof e4.i ? t2.i = parseInt(e4.i, 10) : "number" == typeof e4.i ? t2.i = e4.i : "object" == typeof e4.i && (t2.i = new c.LongBits(e4.i.low >>> 0, e4.i.high >>> 0).toNumber())), null != e4.s && ("string" == typeof e4.s ? c.base64.decode(e4.s, t2.s = c.newBuffer(c.base64.length(e4.s)), 0) : e4.s.length && (t2.s = e4.s)), null != e4.t) {
                if ("object" != typeof e4.t) throw TypeError(".onnx.AttributeProto.t: object expected");
                t2.t = u.onnx.TensorProto.fromObject(e4.t);
              }
              if (null != e4.g) {
                if ("object" != typeof e4.g) throw TypeError(".onnx.AttributeProto.g: object expected");
                t2.g = u.onnx.GraphProto.fromObject(e4.g);
              }
              if (e4.floats) {
                if (!Array.isArray(e4.floats)) throw TypeError(".onnx.AttributeProto.floats: array expected");
                t2.floats = [];
                for (var n2 = 0; n2 < e4.floats.length; ++n2) t2.floats[n2] = Number(e4.floats[n2]);
              }
              if (e4.ints) {
                if (!Array.isArray(e4.ints)) throw TypeError(".onnx.AttributeProto.ints: array expected");
                for (t2.ints = [], n2 = 0; n2 < e4.ints.length; ++n2) c.Long ? (t2.ints[n2] = c.Long.fromValue(e4.ints[n2])).unsigned = false : "string" == typeof e4.ints[n2] ? t2.ints[n2] = parseInt(e4.ints[n2], 10) : "number" == typeof e4.ints[n2] ? t2.ints[n2] = e4.ints[n2] : "object" == typeof e4.ints[n2] && (t2.ints[n2] = new c.LongBits(e4.ints[n2].low >>> 0, e4.ints[n2].high >>> 0).toNumber());
              }
              if (e4.strings) {
                if (!Array.isArray(e4.strings)) throw TypeError(".onnx.AttributeProto.strings: array expected");
                for (t2.strings = [], n2 = 0; n2 < e4.strings.length; ++n2) "string" == typeof e4.strings[n2] ? c.base64.decode(e4.strings[n2], t2.strings[n2] = c.newBuffer(c.base64.length(e4.strings[n2])), 0) : e4.strings[n2].length && (t2.strings[n2] = e4.strings[n2]);
              }
              if (e4.tensors) {
                if (!Array.isArray(e4.tensors)) throw TypeError(".onnx.AttributeProto.tensors: array expected");
                for (t2.tensors = [], n2 = 0; n2 < e4.tensors.length; ++n2) {
                  if ("object" != typeof e4.tensors[n2]) throw TypeError(".onnx.AttributeProto.tensors: object expected");
                  t2.tensors[n2] = u.onnx.TensorProto.fromObject(e4.tensors[n2]);
                }
              }
              if (e4.graphs) {
                if (!Array.isArray(e4.graphs)) throw TypeError(".onnx.AttributeProto.graphs: array expected");
                for (t2.graphs = [], n2 = 0; n2 < e4.graphs.length; ++n2) {
                  if ("object" != typeof e4.graphs[n2]) throw TypeError(".onnx.AttributeProto.graphs: object expected");
                  t2.graphs[n2] = u.onnx.GraphProto.fromObject(e4.graphs[n2]);
                }
              }
              return t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if ((t2.arrays || t2.defaults) && (n2.floats = [], n2.ints = [], n2.strings = [], n2.tensors = [], n2.graphs = []), t2.defaults) {
                if (n2.name = "", n2.f = 0, c.Long) {
                  var r2 = new c.Long(0, 0, false);
                  n2.i = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
                } else n2.i = t2.longs === String ? "0" : 0;
                t2.bytes === String ? n2.s = "" : (n2.s = [], t2.bytes !== Array && (n2.s = c.newBuffer(n2.s))), n2.t = null, n2.g = null, n2.docString = "", n2.type = t2.enums === String ? "UNDEFINED" : 0, n2.refAttrName = "";
              }
              if (null != e4.name && e4.hasOwnProperty("name") && (n2.name = e4.name), null != e4.f && e4.hasOwnProperty("f") && (n2.f = t2.json && !isFinite(e4.f) ? String(e4.f) : e4.f), null != e4.i && e4.hasOwnProperty("i") && ("number" == typeof e4.i ? n2.i = t2.longs === String ? String(e4.i) : e4.i : n2.i = t2.longs === String ? c.Long.prototype.toString.call(e4.i) : t2.longs === Number ? new c.LongBits(e4.i.low >>> 0, e4.i.high >>> 0).toNumber() : e4.i), null != e4.s && e4.hasOwnProperty("s") && (n2.s = t2.bytes === String ? c.base64.encode(e4.s, 0, e4.s.length) : t2.bytes === Array ? Array.prototype.slice.call(e4.s) : e4.s), null != e4.t && e4.hasOwnProperty("t") && (n2.t = u.onnx.TensorProto.toObject(e4.t, t2)), null != e4.g && e4.hasOwnProperty("g") && (n2.g = u.onnx.GraphProto.toObject(e4.g, t2)), e4.floats && e4.floats.length) {
                n2.floats = [];
                for (var o2 = 0; o2 < e4.floats.length; ++o2) n2.floats[o2] = t2.json && !isFinite(e4.floats[o2]) ? String(e4.floats[o2]) : e4.floats[o2];
              }
              if (e4.ints && e4.ints.length) for (n2.ints = [], o2 = 0; o2 < e4.ints.length; ++o2) "number" == typeof e4.ints[o2] ? n2.ints[o2] = t2.longs === String ? String(e4.ints[o2]) : e4.ints[o2] : n2.ints[o2] = t2.longs === String ? c.Long.prototype.toString.call(e4.ints[o2]) : t2.longs === Number ? new c.LongBits(e4.ints[o2].low >>> 0, e4.ints[o2].high >>> 0).toNumber() : e4.ints[o2];
              if (e4.strings && e4.strings.length) for (n2.strings = [], o2 = 0; o2 < e4.strings.length; ++o2) n2.strings[o2] = t2.bytes === String ? c.base64.encode(e4.strings[o2], 0, e4.strings[o2].length) : t2.bytes === Array ? Array.prototype.slice.call(e4.strings[o2]) : e4.strings[o2];
              if (e4.tensors && e4.tensors.length) for (n2.tensors = [], o2 = 0; o2 < e4.tensors.length; ++o2) n2.tensors[o2] = u.onnx.TensorProto.toObject(e4.tensors[o2], t2);
              if (e4.graphs && e4.graphs.length) for (n2.graphs = [], o2 = 0; o2 < e4.graphs.length; ++o2) n2.graphs[o2] = u.onnx.GraphProto.toObject(e4.graphs[o2], t2);
              return null != e4.docString && e4.hasOwnProperty("docString") && (n2.docString = e4.docString), null != e4.type && e4.hasOwnProperty("type") && (n2.type = t2.enums === String ? u.onnx.AttributeProto.AttributeType[e4.type] : e4.type), null != e4.refAttrName && e4.hasOwnProperty("refAttrName") && (n2.refAttrName = e4.refAttrName), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3.AttributeType = (function() {
              var e4 = {}, t2 = Object.create(e4);
              return t2[e4[0] = "UNDEFINED"] = 0, t2[e4[1] = "FLOAT"] = 1, t2[e4[2] = "INT"] = 2, t2[e4[3] = "STRING"] = 3, t2[e4[4] = "TENSOR"] = 4, t2[e4[5] = "GRAPH"] = 5, t2[e4[6] = "FLOATS"] = 6, t2[e4[7] = "INTS"] = 7, t2[e4[8] = "STRINGS"] = 8, t2[e4[9] = "TENSORS"] = 9, t2[e4[10] = "GRAPHS"] = 10, t2;
            })(), e3;
          })(), i.ValueInfoProto = (function() {
            function e3(e4) {
              if (e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.name = "", e3.prototype.type = null, e3.prototype.docString = "", e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              return t2 || (t2 = l.create()), null != e4.name && e4.hasOwnProperty("name") && t2.uint32(10).string(e4.name), null != e4.type && e4.hasOwnProperty("type") && u.onnx.TypeProto.encode(e4.type, t2.uint32(18).fork()).ldelim(), null != e4.docString && e4.hasOwnProperty("docString") && t2.uint32(26).string(e4.docString), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.ValueInfoProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.name = e4.string();
                    break;
                  case 2:
                    r2.type = u.onnx.TypeProto.decode(e4, e4.uint32());
                    break;
                  case 3:
                    r2.docString = e4.string();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.name && e4.hasOwnProperty("name") && !c.isString(e4.name)) return "name: string expected";
              if (null != e4.type && e4.hasOwnProperty("type")) {
                var t2 = u.onnx.TypeProto.verify(e4.type);
                if (t2) return "type." + t2;
              }
              return null != e4.docString && e4.hasOwnProperty("docString") && !c.isString(e4.docString) ? "docString: string expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.ValueInfoProto) return e4;
              var t2 = new u.onnx.ValueInfoProto();
              if (null != e4.name && (t2.name = String(e4.name)), null != e4.type) {
                if ("object" != typeof e4.type) throw TypeError(".onnx.ValueInfoProto.type: object expected");
                t2.type = u.onnx.TypeProto.fromObject(e4.type);
              }
              return null != e4.docString && (t2.docString = String(e4.docString)), t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              return t2.defaults && (n2.name = "", n2.type = null, n2.docString = ""), null != e4.name && e4.hasOwnProperty("name") && (n2.name = e4.name), null != e4.type && e4.hasOwnProperty("type") && (n2.type = u.onnx.TypeProto.toObject(e4.type, t2)), null != e4.docString && e4.hasOwnProperty("docString") && (n2.docString = e4.docString), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3;
          })(), i.NodeProto = (function() {
            function e3(e4) {
              if (this.input = [], this.output = [], this.attribute = [], e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.input = c.emptyArray, e3.prototype.output = c.emptyArray, e3.prototype.name = "", e3.prototype.opType = "", e3.prototype.domain = "", e3.prototype.attribute = c.emptyArray, e3.prototype.docString = "", e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              if (t2 || (t2 = l.create()), null != e4.input && e4.input.length) for (var n2 = 0; n2 < e4.input.length; ++n2) t2.uint32(10).string(e4.input[n2]);
              if (null != e4.output && e4.output.length) for (n2 = 0; n2 < e4.output.length; ++n2) t2.uint32(18).string(e4.output[n2]);
              if (null != e4.name && e4.hasOwnProperty("name") && t2.uint32(26).string(e4.name), null != e4.opType && e4.hasOwnProperty("opType") && t2.uint32(34).string(e4.opType), null != e4.attribute && e4.attribute.length) for (n2 = 0; n2 < e4.attribute.length; ++n2) u.onnx.AttributeProto.encode(e4.attribute[n2], t2.uint32(42).fork()).ldelim();
              return null != e4.docString && e4.hasOwnProperty("docString") && t2.uint32(50).string(e4.docString), null != e4.domain && e4.hasOwnProperty("domain") && t2.uint32(58).string(e4.domain), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.NodeProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.input && r2.input.length || (r2.input = []), r2.input.push(e4.string());
                    break;
                  case 2:
                    r2.output && r2.output.length || (r2.output = []), r2.output.push(e4.string());
                    break;
                  case 3:
                    r2.name = e4.string();
                    break;
                  case 4:
                    r2.opType = e4.string();
                    break;
                  case 7:
                    r2.domain = e4.string();
                    break;
                  case 5:
                    r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(u.onnx.AttributeProto.decode(e4, e4.uint32()));
                    break;
                  case 6:
                    r2.docString = e4.string();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.input && e4.hasOwnProperty("input")) {
                if (!Array.isArray(e4.input)) return "input: array expected";
                for (var t2 = 0; t2 < e4.input.length; ++t2) if (!c.isString(e4.input[t2])) return "input: string[] expected";
              }
              if (null != e4.output && e4.hasOwnProperty("output")) {
                if (!Array.isArray(e4.output)) return "output: array expected";
                for (t2 = 0; t2 < e4.output.length; ++t2) if (!c.isString(e4.output[t2])) return "output: string[] expected";
              }
              if (null != e4.name && e4.hasOwnProperty("name") && !c.isString(e4.name)) return "name: string expected";
              if (null != e4.opType && e4.hasOwnProperty("opType") && !c.isString(e4.opType)) return "opType: string expected";
              if (null != e4.domain && e4.hasOwnProperty("domain") && !c.isString(e4.domain)) return "domain: string expected";
              if (null != e4.attribute && e4.hasOwnProperty("attribute")) {
                if (!Array.isArray(e4.attribute)) return "attribute: array expected";
                for (t2 = 0; t2 < e4.attribute.length; ++t2) {
                  var n2 = u.onnx.AttributeProto.verify(e4.attribute[t2]);
                  if (n2) return "attribute." + n2;
                }
              }
              return null != e4.docString && e4.hasOwnProperty("docString") && !c.isString(e4.docString) ? "docString: string expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.NodeProto) return e4;
              var t2 = new u.onnx.NodeProto();
              if (e4.input) {
                if (!Array.isArray(e4.input)) throw TypeError(".onnx.NodeProto.input: array expected");
                t2.input = [];
                for (var n2 = 0; n2 < e4.input.length; ++n2) t2.input[n2] = String(e4.input[n2]);
              }
              if (e4.output) {
                if (!Array.isArray(e4.output)) throw TypeError(".onnx.NodeProto.output: array expected");
                for (t2.output = [], n2 = 0; n2 < e4.output.length; ++n2) t2.output[n2] = String(e4.output[n2]);
              }
              if (null != e4.name && (t2.name = String(e4.name)), null != e4.opType && (t2.opType = String(e4.opType)), null != e4.domain && (t2.domain = String(e4.domain)), e4.attribute) {
                if (!Array.isArray(e4.attribute)) throw TypeError(".onnx.NodeProto.attribute: array expected");
                for (t2.attribute = [], n2 = 0; n2 < e4.attribute.length; ++n2) {
                  if ("object" != typeof e4.attribute[n2]) throw TypeError(".onnx.NodeProto.attribute: object expected");
                  t2.attribute[n2] = u.onnx.AttributeProto.fromObject(e4.attribute[n2]);
                }
              }
              return null != e4.docString && (t2.docString = String(e4.docString)), t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if ((t2.arrays || t2.defaults) && (n2.input = [], n2.output = [], n2.attribute = []), t2.defaults && (n2.name = "", n2.opType = "", n2.docString = "", n2.domain = ""), e4.input && e4.input.length) {
                n2.input = [];
                for (var r2 = 0; r2 < e4.input.length; ++r2) n2.input[r2] = e4.input[r2];
              }
              if (e4.output && e4.output.length) for (n2.output = [], r2 = 0; r2 < e4.output.length; ++r2) n2.output[r2] = e4.output[r2];
              if (null != e4.name && e4.hasOwnProperty("name") && (n2.name = e4.name), null != e4.opType && e4.hasOwnProperty("opType") && (n2.opType = e4.opType), e4.attribute && e4.attribute.length) for (n2.attribute = [], r2 = 0; r2 < e4.attribute.length; ++r2) n2.attribute[r2] = u.onnx.AttributeProto.toObject(e4.attribute[r2], t2);
              return null != e4.docString && e4.hasOwnProperty("docString") && (n2.docString = e4.docString), null != e4.domain && e4.hasOwnProperty("domain") && (n2.domain = e4.domain), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3;
          })(), i.ModelProto = (function() {
            function e3(e4) {
              if (this.opsetImport = [], this.metadataProps = [], e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.irVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, e3.prototype.opsetImport = c.emptyArray, e3.prototype.producerName = "", e3.prototype.producerVersion = "", e3.prototype.domain = "", e3.prototype.modelVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, e3.prototype.docString = "", e3.prototype.graph = null, e3.prototype.metadataProps = c.emptyArray, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              if (t2 || (t2 = l.create()), null != e4.irVersion && e4.hasOwnProperty("irVersion") && t2.uint32(8).int64(e4.irVersion), null != e4.producerName && e4.hasOwnProperty("producerName") && t2.uint32(18).string(e4.producerName), null != e4.producerVersion && e4.hasOwnProperty("producerVersion") && t2.uint32(26).string(e4.producerVersion), null != e4.domain && e4.hasOwnProperty("domain") && t2.uint32(34).string(e4.domain), null != e4.modelVersion && e4.hasOwnProperty("modelVersion") && t2.uint32(40).int64(e4.modelVersion), null != e4.docString && e4.hasOwnProperty("docString") && t2.uint32(50).string(e4.docString), null != e4.graph && e4.hasOwnProperty("graph") && u.onnx.GraphProto.encode(e4.graph, t2.uint32(58).fork()).ldelim(), null != e4.opsetImport && e4.opsetImport.length) for (var n2 = 0; n2 < e4.opsetImport.length; ++n2) u.onnx.OperatorSetIdProto.encode(e4.opsetImport[n2], t2.uint32(66).fork()).ldelim();
              if (null != e4.metadataProps && e4.metadataProps.length) for (n2 = 0; n2 < e4.metadataProps.length; ++n2) u.onnx.StringStringEntryProto.encode(e4.metadataProps[n2], t2.uint32(114).fork()).ldelim();
              return t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.ModelProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.irVersion = e4.int64();
                    break;
                  case 8:
                    r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(u.onnx.OperatorSetIdProto.decode(e4, e4.uint32()));
                    break;
                  case 2:
                    r2.producerName = e4.string();
                    break;
                  case 3:
                    r2.producerVersion = e4.string();
                    break;
                  case 4:
                    r2.domain = e4.string();
                    break;
                  case 5:
                    r2.modelVersion = e4.int64();
                    break;
                  case 6:
                    r2.docString = e4.string();
                    break;
                  case 7:
                    r2.graph = u.onnx.GraphProto.decode(e4, e4.uint32());
                    break;
                  case 14:
                    r2.metadataProps && r2.metadataProps.length || (r2.metadataProps = []), r2.metadataProps.push(u.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.irVersion && e4.hasOwnProperty("irVersion") && !(c.isInteger(e4.irVersion) || e4.irVersion && c.isInteger(e4.irVersion.low) && c.isInteger(e4.irVersion.high))) return "irVersion: integer|Long expected";
              if (null != e4.opsetImport && e4.hasOwnProperty("opsetImport")) {
                if (!Array.isArray(e4.opsetImport)) return "opsetImport: array expected";
                for (var t2 = 0; t2 < e4.opsetImport.length; ++t2) if (n2 = u.onnx.OperatorSetIdProto.verify(e4.opsetImport[t2])) return "opsetImport." + n2;
              }
              if (null != e4.producerName && e4.hasOwnProperty("producerName") && !c.isString(e4.producerName)) return "producerName: string expected";
              if (null != e4.producerVersion && e4.hasOwnProperty("producerVersion") && !c.isString(e4.producerVersion)) return "producerVersion: string expected";
              if (null != e4.domain && e4.hasOwnProperty("domain") && !c.isString(e4.domain)) return "domain: string expected";
              if (null != e4.modelVersion && e4.hasOwnProperty("modelVersion") && !(c.isInteger(e4.modelVersion) || e4.modelVersion && c.isInteger(e4.modelVersion.low) && c.isInteger(e4.modelVersion.high))) return "modelVersion: integer|Long expected";
              if (null != e4.docString && e4.hasOwnProperty("docString") && !c.isString(e4.docString)) return "docString: string expected";
              if (null != e4.graph && e4.hasOwnProperty("graph") && (n2 = u.onnx.GraphProto.verify(e4.graph))) return "graph." + n2;
              if (null != e4.metadataProps && e4.hasOwnProperty("metadataProps")) {
                if (!Array.isArray(e4.metadataProps)) return "metadataProps: array expected";
                for (t2 = 0; t2 < e4.metadataProps.length; ++t2) {
                  var n2;
                  if (n2 = u.onnx.StringStringEntryProto.verify(e4.metadataProps[t2])) return "metadataProps." + n2;
                }
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.ModelProto) return e4;
              var t2 = new u.onnx.ModelProto();
              if (null != e4.irVersion && (c.Long ? (t2.irVersion = c.Long.fromValue(e4.irVersion)).unsigned = false : "string" == typeof e4.irVersion ? t2.irVersion = parseInt(e4.irVersion, 10) : "number" == typeof e4.irVersion ? t2.irVersion = e4.irVersion : "object" == typeof e4.irVersion && (t2.irVersion = new c.LongBits(e4.irVersion.low >>> 0, e4.irVersion.high >>> 0).toNumber())), e4.opsetImport) {
                if (!Array.isArray(e4.opsetImport)) throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                t2.opsetImport = [];
                for (var n2 = 0; n2 < e4.opsetImport.length; ++n2) {
                  if ("object" != typeof e4.opsetImport[n2]) throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                  t2.opsetImport[n2] = u.onnx.OperatorSetIdProto.fromObject(e4.opsetImport[n2]);
                }
              }
              if (null != e4.producerName && (t2.producerName = String(e4.producerName)), null != e4.producerVersion && (t2.producerVersion = String(e4.producerVersion)), null != e4.domain && (t2.domain = String(e4.domain)), null != e4.modelVersion && (c.Long ? (t2.modelVersion = c.Long.fromValue(e4.modelVersion)).unsigned = false : "string" == typeof e4.modelVersion ? t2.modelVersion = parseInt(e4.modelVersion, 10) : "number" == typeof e4.modelVersion ? t2.modelVersion = e4.modelVersion : "object" == typeof e4.modelVersion && (t2.modelVersion = new c.LongBits(e4.modelVersion.low >>> 0, e4.modelVersion.high >>> 0).toNumber())), null != e4.docString && (t2.docString = String(e4.docString)), null != e4.graph) {
                if ("object" != typeof e4.graph) throw TypeError(".onnx.ModelProto.graph: object expected");
                t2.graph = u.onnx.GraphProto.fromObject(e4.graph);
              }
              if (e4.metadataProps) {
                if (!Array.isArray(e4.metadataProps)) throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                for (t2.metadataProps = [], n2 = 0; n2 < e4.metadataProps.length; ++n2) {
                  if ("object" != typeof e4.metadataProps[n2]) throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                  t2.metadataProps[n2] = u.onnx.StringStringEntryProto.fromObject(e4.metadataProps[n2]);
                }
              }
              return t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if ((t2.arrays || t2.defaults) && (n2.opsetImport = [], n2.metadataProps = []), t2.defaults) {
                if (c.Long) {
                  var r2 = new c.Long(0, 0, false);
                  n2.irVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
                } else n2.irVersion = t2.longs === String ? "0" : 0;
                n2.producerName = "", n2.producerVersion = "", n2.domain = "", c.Long ? (r2 = new c.Long(0, 0, false), n2.modelVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.modelVersion = t2.longs === String ? "0" : 0, n2.docString = "", n2.graph = null;
              }
              if (null != e4.irVersion && e4.hasOwnProperty("irVersion") && ("number" == typeof e4.irVersion ? n2.irVersion = t2.longs === String ? String(e4.irVersion) : e4.irVersion : n2.irVersion = t2.longs === String ? c.Long.prototype.toString.call(e4.irVersion) : t2.longs === Number ? new c.LongBits(e4.irVersion.low >>> 0, e4.irVersion.high >>> 0).toNumber() : e4.irVersion), null != e4.producerName && e4.hasOwnProperty("producerName") && (n2.producerName = e4.producerName), null != e4.producerVersion && e4.hasOwnProperty("producerVersion") && (n2.producerVersion = e4.producerVersion), null != e4.domain && e4.hasOwnProperty("domain") && (n2.domain = e4.domain), null != e4.modelVersion && e4.hasOwnProperty("modelVersion") && ("number" == typeof e4.modelVersion ? n2.modelVersion = t2.longs === String ? String(e4.modelVersion) : e4.modelVersion : n2.modelVersion = t2.longs === String ? c.Long.prototype.toString.call(e4.modelVersion) : t2.longs === Number ? new c.LongBits(e4.modelVersion.low >>> 0, e4.modelVersion.high >>> 0).toNumber() : e4.modelVersion), null != e4.docString && e4.hasOwnProperty("docString") && (n2.docString = e4.docString), null != e4.graph && e4.hasOwnProperty("graph") && (n2.graph = u.onnx.GraphProto.toObject(e4.graph, t2)), e4.opsetImport && e4.opsetImport.length) {
                n2.opsetImport = [];
                for (var o2 = 0; o2 < e4.opsetImport.length; ++o2) n2.opsetImport[o2] = u.onnx.OperatorSetIdProto.toObject(e4.opsetImport[o2], t2);
              }
              if (e4.metadataProps && e4.metadataProps.length) for (n2.metadataProps = [], o2 = 0; o2 < e4.metadataProps.length; ++o2) n2.metadataProps[o2] = u.onnx.StringStringEntryProto.toObject(e4.metadataProps[o2], t2);
              return n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3;
          })(), i.StringStringEntryProto = (function() {
            function e3(e4) {
              if (e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.key = "", e3.prototype.value = "", e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              return t2 || (t2 = l.create()), null != e4.key && e4.hasOwnProperty("key") && t2.uint32(10).string(e4.key), null != e4.value && e4.hasOwnProperty("value") && t2.uint32(18).string(e4.value), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.StringStringEntryProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.key = e4.string();
                    break;
                  case 2:
                    r2.value = e4.string();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              return "object" != typeof e4 || null === e4 ? "object expected" : null != e4.key && e4.hasOwnProperty("key") && !c.isString(e4.key) ? "key: string expected" : null != e4.value && e4.hasOwnProperty("value") && !c.isString(e4.value) ? "value: string expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.StringStringEntryProto) return e4;
              var t2 = new u.onnx.StringStringEntryProto();
              return null != e4.key && (t2.key = String(e4.key)), null != e4.value && (t2.value = String(e4.value)), t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              return t2.defaults && (n2.key = "", n2.value = ""), null != e4.key && e4.hasOwnProperty("key") && (n2.key = e4.key), null != e4.value && e4.hasOwnProperty("value") && (n2.value = e4.value), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3;
          })(), i.TensorAnnotation = (function() {
            function e3(e4) {
              if (this.quantParameterTensorNames = [], e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.tensorName = "", e3.prototype.quantParameterTensorNames = c.emptyArray, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              if (t2 || (t2 = l.create()), null != e4.tensorName && e4.hasOwnProperty("tensorName") && t2.uint32(10).string(e4.tensorName), null != e4.quantParameterTensorNames && e4.quantParameterTensorNames.length) for (var n2 = 0; n2 < e4.quantParameterTensorNames.length; ++n2) u.onnx.StringStringEntryProto.encode(e4.quantParameterTensorNames[n2], t2.uint32(18).fork()).ldelim();
              return t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.TensorAnnotation(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.tensorName = e4.string();
                    break;
                  case 2:
                    r2.quantParameterTensorNames && r2.quantParameterTensorNames.length || (r2.quantParameterTensorNames = []), r2.quantParameterTensorNames.push(u.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.tensorName && e4.hasOwnProperty("tensorName") && !c.isString(e4.tensorName)) return "tensorName: string expected";
              if (null != e4.quantParameterTensorNames && e4.hasOwnProperty("quantParameterTensorNames")) {
                if (!Array.isArray(e4.quantParameterTensorNames)) return "quantParameterTensorNames: array expected";
                for (var t2 = 0; t2 < e4.quantParameterTensorNames.length; ++t2) {
                  var n2 = u.onnx.StringStringEntryProto.verify(e4.quantParameterTensorNames[t2]);
                  if (n2) return "quantParameterTensorNames." + n2;
                }
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.TensorAnnotation) return e4;
              var t2 = new u.onnx.TensorAnnotation();
              if (null != e4.tensorName && (t2.tensorName = String(e4.tensorName)), e4.quantParameterTensorNames) {
                if (!Array.isArray(e4.quantParameterTensorNames)) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                t2.quantParameterTensorNames = [];
                for (var n2 = 0; n2 < e4.quantParameterTensorNames.length; ++n2) {
                  if ("object" != typeof e4.quantParameterTensorNames[n2]) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                  t2.quantParameterTensorNames[n2] = u.onnx.StringStringEntryProto.fromObject(e4.quantParameterTensorNames[n2]);
                }
              }
              return t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if ((t2.arrays || t2.defaults) && (n2.quantParameterTensorNames = []), t2.defaults && (n2.tensorName = ""), null != e4.tensorName && e4.hasOwnProperty("tensorName") && (n2.tensorName = e4.tensorName), e4.quantParameterTensorNames && e4.quantParameterTensorNames.length) {
                n2.quantParameterTensorNames = [];
                for (var r2 = 0; r2 < e4.quantParameterTensorNames.length; ++r2) n2.quantParameterTensorNames[r2] = u.onnx.StringStringEntryProto.toObject(e4.quantParameterTensorNames[r2], t2);
              }
              return n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3;
          })(), i.GraphProto = (function() {
            function e3(e4) {
              if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.node = c.emptyArray, e3.prototype.name = "", e3.prototype.initializer = c.emptyArray, e3.prototype.docString = "", e3.prototype.input = c.emptyArray, e3.prototype.output = c.emptyArray, e3.prototype.valueInfo = c.emptyArray, e3.prototype.quantizationAnnotation = c.emptyArray, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              if (t2 || (t2 = l.create()), null != e4.node && e4.node.length) for (var n2 = 0; n2 < e4.node.length; ++n2) u.onnx.NodeProto.encode(e4.node[n2], t2.uint32(10).fork()).ldelim();
              if (null != e4.name && e4.hasOwnProperty("name") && t2.uint32(18).string(e4.name), null != e4.initializer && e4.initializer.length) for (n2 = 0; n2 < e4.initializer.length; ++n2) u.onnx.TensorProto.encode(e4.initializer[n2], t2.uint32(42).fork()).ldelim();
              if (null != e4.docString && e4.hasOwnProperty("docString") && t2.uint32(82).string(e4.docString), null != e4.input && e4.input.length) for (n2 = 0; n2 < e4.input.length; ++n2) u.onnx.ValueInfoProto.encode(e4.input[n2], t2.uint32(90).fork()).ldelim();
              if (null != e4.output && e4.output.length) for (n2 = 0; n2 < e4.output.length; ++n2) u.onnx.ValueInfoProto.encode(e4.output[n2], t2.uint32(98).fork()).ldelim();
              if (null != e4.valueInfo && e4.valueInfo.length) for (n2 = 0; n2 < e4.valueInfo.length; ++n2) u.onnx.ValueInfoProto.encode(e4.valueInfo[n2], t2.uint32(106).fork()).ldelim();
              if (null != e4.quantizationAnnotation && e4.quantizationAnnotation.length) for (n2 = 0; n2 < e4.quantizationAnnotation.length; ++n2) u.onnx.TensorAnnotation.encode(e4.quantizationAnnotation[n2], t2.uint32(114).fork()).ldelim();
              return t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.GraphProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.node && r2.node.length || (r2.node = []), r2.node.push(u.onnx.NodeProto.decode(e4, e4.uint32()));
                    break;
                  case 2:
                    r2.name = e4.string();
                    break;
                  case 5:
                    r2.initializer && r2.initializer.length || (r2.initializer = []), r2.initializer.push(u.onnx.TensorProto.decode(e4, e4.uint32()));
                    break;
                  case 10:
                    r2.docString = e4.string();
                    break;
                  case 11:
                    r2.input && r2.input.length || (r2.input = []), r2.input.push(u.onnx.ValueInfoProto.decode(e4, e4.uint32()));
                    break;
                  case 12:
                    r2.output && r2.output.length || (r2.output = []), r2.output.push(u.onnx.ValueInfoProto.decode(e4, e4.uint32()));
                    break;
                  case 13:
                    r2.valueInfo && r2.valueInfo.length || (r2.valueInfo = []), r2.valueInfo.push(u.onnx.ValueInfoProto.decode(e4, e4.uint32()));
                    break;
                  case 14:
                    r2.quantizationAnnotation && r2.quantizationAnnotation.length || (r2.quantizationAnnotation = []), r2.quantizationAnnotation.push(u.onnx.TensorAnnotation.decode(e4, e4.uint32()));
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.node && e4.hasOwnProperty("node")) {
                if (!Array.isArray(e4.node)) return "node: array expected";
                for (var t2 = 0; t2 < e4.node.length; ++t2) if (n2 = u.onnx.NodeProto.verify(e4.node[t2])) return "node." + n2;
              }
              if (null != e4.name && e4.hasOwnProperty("name") && !c.isString(e4.name)) return "name: string expected";
              if (null != e4.initializer && e4.hasOwnProperty("initializer")) {
                if (!Array.isArray(e4.initializer)) return "initializer: array expected";
                for (t2 = 0; t2 < e4.initializer.length; ++t2) if (n2 = u.onnx.TensorProto.verify(e4.initializer[t2])) return "initializer." + n2;
              }
              if (null != e4.docString && e4.hasOwnProperty("docString") && !c.isString(e4.docString)) return "docString: string expected";
              if (null != e4.input && e4.hasOwnProperty("input")) {
                if (!Array.isArray(e4.input)) return "input: array expected";
                for (t2 = 0; t2 < e4.input.length; ++t2) if (n2 = u.onnx.ValueInfoProto.verify(e4.input[t2])) return "input." + n2;
              }
              if (null != e4.output && e4.hasOwnProperty("output")) {
                if (!Array.isArray(e4.output)) return "output: array expected";
                for (t2 = 0; t2 < e4.output.length; ++t2) if (n2 = u.onnx.ValueInfoProto.verify(e4.output[t2])) return "output." + n2;
              }
              if (null != e4.valueInfo && e4.hasOwnProperty("valueInfo")) {
                if (!Array.isArray(e4.valueInfo)) return "valueInfo: array expected";
                for (t2 = 0; t2 < e4.valueInfo.length; ++t2) if (n2 = u.onnx.ValueInfoProto.verify(e4.valueInfo[t2])) return "valueInfo." + n2;
              }
              if (null != e4.quantizationAnnotation && e4.hasOwnProperty("quantizationAnnotation")) {
                if (!Array.isArray(e4.quantizationAnnotation)) return "quantizationAnnotation: array expected";
                for (t2 = 0; t2 < e4.quantizationAnnotation.length; ++t2) {
                  var n2;
                  if (n2 = u.onnx.TensorAnnotation.verify(e4.quantizationAnnotation[t2])) return "quantizationAnnotation." + n2;
                }
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.GraphProto) return e4;
              var t2 = new u.onnx.GraphProto();
              if (e4.node) {
                if (!Array.isArray(e4.node)) throw TypeError(".onnx.GraphProto.node: array expected");
                t2.node = [];
                for (var n2 = 0; n2 < e4.node.length; ++n2) {
                  if ("object" != typeof e4.node[n2]) throw TypeError(".onnx.GraphProto.node: object expected");
                  t2.node[n2] = u.onnx.NodeProto.fromObject(e4.node[n2]);
                }
              }
              if (null != e4.name && (t2.name = String(e4.name)), e4.initializer) {
                if (!Array.isArray(e4.initializer)) throw TypeError(".onnx.GraphProto.initializer: array expected");
                for (t2.initializer = [], n2 = 0; n2 < e4.initializer.length; ++n2) {
                  if ("object" != typeof e4.initializer[n2]) throw TypeError(".onnx.GraphProto.initializer: object expected");
                  t2.initializer[n2] = u.onnx.TensorProto.fromObject(e4.initializer[n2]);
                }
              }
              if (null != e4.docString && (t2.docString = String(e4.docString)), e4.input) {
                if (!Array.isArray(e4.input)) throw TypeError(".onnx.GraphProto.input: array expected");
                for (t2.input = [], n2 = 0; n2 < e4.input.length; ++n2) {
                  if ("object" != typeof e4.input[n2]) throw TypeError(".onnx.GraphProto.input: object expected");
                  t2.input[n2] = u.onnx.ValueInfoProto.fromObject(e4.input[n2]);
                }
              }
              if (e4.output) {
                if (!Array.isArray(e4.output)) throw TypeError(".onnx.GraphProto.output: array expected");
                for (t2.output = [], n2 = 0; n2 < e4.output.length; ++n2) {
                  if ("object" != typeof e4.output[n2]) throw TypeError(".onnx.GraphProto.output: object expected");
                  t2.output[n2] = u.onnx.ValueInfoProto.fromObject(e4.output[n2]);
                }
              }
              if (e4.valueInfo) {
                if (!Array.isArray(e4.valueInfo)) throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                for (t2.valueInfo = [], n2 = 0; n2 < e4.valueInfo.length; ++n2) {
                  if ("object" != typeof e4.valueInfo[n2]) throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                  t2.valueInfo[n2] = u.onnx.ValueInfoProto.fromObject(e4.valueInfo[n2]);
                }
              }
              if (e4.quantizationAnnotation) {
                if (!Array.isArray(e4.quantizationAnnotation)) throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                for (t2.quantizationAnnotation = [], n2 = 0; n2 < e4.quantizationAnnotation.length; ++n2) {
                  if ("object" != typeof e4.quantizationAnnotation[n2]) throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                  t2.quantizationAnnotation[n2] = u.onnx.TensorAnnotation.fromObject(e4.quantizationAnnotation[n2]);
                }
              }
              return t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if ((t2.arrays || t2.defaults) && (n2.node = [], n2.initializer = [], n2.input = [], n2.output = [], n2.valueInfo = [], n2.quantizationAnnotation = []), t2.defaults && (n2.name = "", n2.docString = ""), e4.node && e4.node.length) {
                n2.node = [];
                for (var r2 = 0; r2 < e4.node.length; ++r2) n2.node[r2] = u.onnx.NodeProto.toObject(e4.node[r2], t2);
              }
              if (null != e4.name && e4.hasOwnProperty("name") && (n2.name = e4.name), e4.initializer && e4.initializer.length) for (n2.initializer = [], r2 = 0; r2 < e4.initializer.length; ++r2) n2.initializer[r2] = u.onnx.TensorProto.toObject(e4.initializer[r2], t2);
              if (null != e4.docString && e4.hasOwnProperty("docString") && (n2.docString = e4.docString), e4.input && e4.input.length) for (n2.input = [], r2 = 0; r2 < e4.input.length; ++r2) n2.input[r2] = u.onnx.ValueInfoProto.toObject(e4.input[r2], t2);
              if (e4.output && e4.output.length) for (n2.output = [], r2 = 0; r2 < e4.output.length; ++r2) n2.output[r2] = u.onnx.ValueInfoProto.toObject(e4.output[r2], t2);
              if (e4.valueInfo && e4.valueInfo.length) for (n2.valueInfo = [], r2 = 0; r2 < e4.valueInfo.length; ++r2) n2.valueInfo[r2] = u.onnx.ValueInfoProto.toObject(e4.valueInfo[r2], t2);
              if (e4.quantizationAnnotation && e4.quantizationAnnotation.length) for (n2.quantizationAnnotation = [], r2 = 0; r2 < e4.quantizationAnnotation.length; ++r2) n2.quantizationAnnotation[r2] = u.onnx.TensorAnnotation.toObject(e4.quantizationAnnotation[r2], t2);
              return n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3;
          })(), i.TensorProto = (function() {
            function e3(e4) {
              if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.dims = c.emptyArray, e3.prototype.dataType = 0, e3.prototype.segment = null, e3.prototype.floatData = c.emptyArray, e3.prototype.int32Data = c.emptyArray, e3.prototype.stringData = c.emptyArray, e3.prototype.int64Data = c.emptyArray, e3.prototype.name = "", e3.prototype.docString = "", e3.prototype.rawData = c.newBuffer([]), e3.prototype.externalData = c.emptyArray, e3.prototype.dataLocation = 0, e3.prototype.doubleData = c.emptyArray, e3.prototype.uint64Data = c.emptyArray, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              if (t2 || (t2 = l.create()), null != e4.dims && e4.dims.length) {
                t2.uint32(10).fork();
                for (var n2 = 0; n2 < e4.dims.length; ++n2) t2.int64(e4.dims[n2]);
                t2.ldelim();
              }
              if (null != e4.dataType && e4.hasOwnProperty("dataType") && t2.uint32(16).int32(e4.dataType), null != e4.segment && e4.hasOwnProperty("segment") && u.onnx.TensorProto.Segment.encode(e4.segment, t2.uint32(26).fork()).ldelim(), null != e4.floatData && e4.floatData.length) {
                for (t2.uint32(34).fork(), n2 = 0; n2 < e4.floatData.length; ++n2) t2.float(e4.floatData[n2]);
                t2.ldelim();
              }
              if (null != e4.int32Data && e4.int32Data.length) {
                for (t2.uint32(42).fork(), n2 = 0; n2 < e4.int32Data.length; ++n2) t2.int32(e4.int32Data[n2]);
                t2.ldelim();
              }
              if (null != e4.stringData && e4.stringData.length) for (n2 = 0; n2 < e4.stringData.length; ++n2) t2.uint32(50).bytes(e4.stringData[n2]);
              if (null != e4.int64Data && e4.int64Data.length) {
                for (t2.uint32(58).fork(), n2 = 0; n2 < e4.int64Data.length; ++n2) t2.int64(e4.int64Data[n2]);
                t2.ldelim();
              }
              if (null != e4.name && e4.hasOwnProperty("name") && t2.uint32(66).string(e4.name), null != e4.rawData && e4.hasOwnProperty("rawData") && t2.uint32(74).bytes(e4.rawData), null != e4.doubleData && e4.doubleData.length) {
                for (t2.uint32(82).fork(), n2 = 0; n2 < e4.doubleData.length; ++n2) t2.double(e4.doubleData[n2]);
                t2.ldelim();
              }
              if (null != e4.uint64Data && e4.uint64Data.length) {
                for (t2.uint32(90).fork(), n2 = 0; n2 < e4.uint64Data.length; ++n2) t2.uint64(e4.uint64Data[n2]);
                t2.ldelim();
              }
              if (null != e4.docString && e4.hasOwnProperty("docString") && t2.uint32(98).string(e4.docString), null != e4.externalData && e4.externalData.length) for (n2 = 0; n2 < e4.externalData.length; ++n2) u.onnx.StringStringEntryProto.encode(e4.externalData[n2], t2.uint32(106).fork()).ldelim();
              return null != e4.dataLocation && e4.hasOwnProperty("dataLocation") && t2.uint32(112).int32(e4.dataLocation), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.TensorProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & o2)) for (var i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.dims.push(e4.int64());
                    else r2.dims.push(e4.int64());
                    break;
                  case 2:
                    r2.dataType = e4.int32();
                    break;
                  case 3:
                    r2.segment = u.onnx.TensorProto.Segment.decode(e4, e4.uint32());
                    break;
                  case 4:
                    if (r2.floatData && r2.floatData.length || (r2.floatData = []), 2 == (7 & o2)) for (i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.floatData.push(e4.float());
                    else r2.floatData.push(e4.float());
                    break;
                  case 5:
                    if (r2.int32Data && r2.int32Data.length || (r2.int32Data = []), 2 == (7 & o2)) for (i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.int32Data.push(e4.int32());
                    else r2.int32Data.push(e4.int32());
                    break;
                  case 6:
                    r2.stringData && r2.stringData.length || (r2.stringData = []), r2.stringData.push(e4.bytes());
                    break;
                  case 7:
                    if (r2.int64Data && r2.int64Data.length || (r2.int64Data = []), 2 == (7 & o2)) for (i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.int64Data.push(e4.int64());
                    else r2.int64Data.push(e4.int64());
                    break;
                  case 8:
                    r2.name = e4.string();
                    break;
                  case 12:
                    r2.docString = e4.string();
                    break;
                  case 9:
                    r2.rawData = e4.bytes();
                    break;
                  case 13:
                    r2.externalData && r2.externalData.length || (r2.externalData = []), r2.externalData.push(u.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  case 14:
                    r2.dataLocation = e4.int32();
                    break;
                  case 10:
                    if (r2.doubleData && r2.doubleData.length || (r2.doubleData = []), 2 == (7 & o2)) for (i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.doubleData.push(e4.double());
                    else r2.doubleData.push(e4.double());
                    break;
                  case 11:
                    if (r2.uint64Data && r2.uint64Data.length || (r2.uint64Data = []), 2 == (7 & o2)) for (i2 = e4.uint32() + e4.pos; e4.pos < i2; ) r2.uint64Data.push(e4.uint64());
                    else r2.uint64Data.push(e4.uint64());
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.dims && e4.hasOwnProperty("dims")) {
                if (!Array.isArray(e4.dims)) return "dims: array expected";
                for (var t2 = 0; t2 < e4.dims.length; ++t2) if (!(c.isInteger(e4.dims[t2]) || e4.dims[t2] && c.isInteger(e4.dims[t2].low) && c.isInteger(e4.dims[t2].high))) return "dims: integer|Long[] expected";
              }
              if (null != e4.dataType && e4.hasOwnProperty("dataType") && !c.isInteger(e4.dataType)) return "dataType: integer expected";
              if (null != e4.segment && e4.hasOwnProperty("segment") && (n2 = u.onnx.TensorProto.Segment.verify(e4.segment))) return "segment." + n2;
              if (null != e4.floatData && e4.hasOwnProperty("floatData")) {
                if (!Array.isArray(e4.floatData)) return "floatData: array expected";
                for (t2 = 0; t2 < e4.floatData.length; ++t2) if ("number" != typeof e4.floatData[t2]) return "floatData: number[] expected";
              }
              if (null != e4.int32Data && e4.hasOwnProperty("int32Data")) {
                if (!Array.isArray(e4.int32Data)) return "int32Data: array expected";
                for (t2 = 0; t2 < e4.int32Data.length; ++t2) if (!c.isInteger(e4.int32Data[t2])) return "int32Data: integer[] expected";
              }
              if (null != e4.stringData && e4.hasOwnProperty("stringData")) {
                if (!Array.isArray(e4.stringData)) return "stringData: array expected";
                for (t2 = 0; t2 < e4.stringData.length; ++t2) if (!(e4.stringData[t2] && "number" == typeof e4.stringData[t2].length || c.isString(e4.stringData[t2]))) return "stringData: buffer[] expected";
              }
              if (null != e4.int64Data && e4.hasOwnProperty("int64Data")) {
                if (!Array.isArray(e4.int64Data)) return "int64Data: array expected";
                for (t2 = 0; t2 < e4.int64Data.length; ++t2) if (!(c.isInteger(e4.int64Data[t2]) || e4.int64Data[t2] && c.isInteger(e4.int64Data[t2].low) && c.isInteger(e4.int64Data[t2].high))) return "int64Data: integer|Long[] expected";
              }
              if (null != e4.name && e4.hasOwnProperty("name") && !c.isString(e4.name)) return "name: string expected";
              if (null != e4.docString && e4.hasOwnProperty("docString") && !c.isString(e4.docString)) return "docString: string expected";
              if (null != e4.rawData && e4.hasOwnProperty("rawData") && !(e4.rawData && "number" == typeof e4.rawData.length || c.isString(e4.rawData))) return "rawData: buffer expected";
              if (null != e4.externalData && e4.hasOwnProperty("externalData")) {
                if (!Array.isArray(e4.externalData)) return "externalData: array expected";
                for (t2 = 0; t2 < e4.externalData.length; ++t2) {
                  var n2;
                  if (n2 = u.onnx.StringStringEntryProto.verify(e4.externalData[t2])) return "externalData." + n2;
                }
              }
              if (null != e4.dataLocation && e4.hasOwnProperty("dataLocation")) switch (e4.dataLocation) {
                default:
                  return "dataLocation: enum value expected";
                case 0:
                case 1:
              }
              if (null != e4.doubleData && e4.hasOwnProperty("doubleData")) {
                if (!Array.isArray(e4.doubleData)) return "doubleData: array expected";
                for (t2 = 0; t2 < e4.doubleData.length; ++t2) if ("number" != typeof e4.doubleData[t2]) return "doubleData: number[] expected";
              }
              if (null != e4.uint64Data && e4.hasOwnProperty("uint64Data")) {
                if (!Array.isArray(e4.uint64Data)) return "uint64Data: array expected";
                for (t2 = 0; t2 < e4.uint64Data.length; ++t2) if (!(c.isInteger(e4.uint64Data[t2]) || e4.uint64Data[t2] && c.isInteger(e4.uint64Data[t2].low) && c.isInteger(e4.uint64Data[t2].high))) return "uint64Data: integer|Long[] expected";
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.TensorProto) return e4;
              var t2 = new u.onnx.TensorProto();
              if (e4.dims) {
                if (!Array.isArray(e4.dims)) throw TypeError(".onnx.TensorProto.dims: array expected");
                t2.dims = [];
                for (var n2 = 0; n2 < e4.dims.length; ++n2) c.Long ? (t2.dims[n2] = c.Long.fromValue(e4.dims[n2])).unsigned = false : "string" == typeof e4.dims[n2] ? t2.dims[n2] = parseInt(e4.dims[n2], 10) : "number" == typeof e4.dims[n2] ? t2.dims[n2] = e4.dims[n2] : "object" == typeof e4.dims[n2] && (t2.dims[n2] = new c.LongBits(e4.dims[n2].low >>> 0, e4.dims[n2].high >>> 0).toNumber());
              }
              if (null != e4.dataType && (t2.dataType = 0 | e4.dataType), null != e4.segment) {
                if ("object" != typeof e4.segment) throw TypeError(".onnx.TensorProto.segment: object expected");
                t2.segment = u.onnx.TensorProto.Segment.fromObject(e4.segment);
              }
              if (e4.floatData) {
                if (!Array.isArray(e4.floatData)) throw TypeError(".onnx.TensorProto.floatData: array expected");
                for (t2.floatData = [], n2 = 0; n2 < e4.floatData.length; ++n2) t2.floatData[n2] = Number(e4.floatData[n2]);
              }
              if (e4.int32Data) {
                if (!Array.isArray(e4.int32Data)) throw TypeError(".onnx.TensorProto.int32Data: array expected");
                for (t2.int32Data = [], n2 = 0; n2 < e4.int32Data.length; ++n2) t2.int32Data[n2] = 0 | e4.int32Data[n2];
              }
              if (e4.stringData) {
                if (!Array.isArray(e4.stringData)) throw TypeError(".onnx.TensorProto.stringData: array expected");
                for (t2.stringData = [], n2 = 0; n2 < e4.stringData.length; ++n2) "string" == typeof e4.stringData[n2] ? c.base64.decode(e4.stringData[n2], t2.stringData[n2] = c.newBuffer(c.base64.length(e4.stringData[n2])), 0) : e4.stringData[n2].length && (t2.stringData[n2] = e4.stringData[n2]);
              }
              if (e4.int64Data) {
                if (!Array.isArray(e4.int64Data)) throw TypeError(".onnx.TensorProto.int64Data: array expected");
                for (t2.int64Data = [], n2 = 0; n2 < e4.int64Data.length; ++n2) c.Long ? (t2.int64Data[n2] = c.Long.fromValue(e4.int64Data[n2])).unsigned = false : "string" == typeof e4.int64Data[n2] ? t2.int64Data[n2] = parseInt(e4.int64Data[n2], 10) : "number" == typeof e4.int64Data[n2] ? t2.int64Data[n2] = e4.int64Data[n2] : "object" == typeof e4.int64Data[n2] && (t2.int64Data[n2] = new c.LongBits(e4.int64Data[n2].low >>> 0, e4.int64Data[n2].high >>> 0).toNumber());
              }
              if (null != e4.name && (t2.name = String(e4.name)), null != e4.docString && (t2.docString = String(e4.docString)), null != e4.rawData && ("string" == typeof e4.rawData ? c.base64.decode(e4.rawData, t2.rawData = c.newBuffer(c.base64.length(e4.rawData)), 0) : e4.rawData.length && (t2.rawData = e4.rawData)), e4.externalData) {
                if (!Array.isArray(e4.externalData)) throw TypeError(".onnx.TensorProto.externalData: array expected");
                for (t2.externalData = [], n2 = 0; n2 < e4.externalData.length; ++n2) {
                  if ("object" != typeof e4.externalData[n2]) throw TypeError(".onnx.TensorProto.externalData: object expected");
                  t2.externalData[n2] = u.onnx.StringStringEntryProto.fromObject(e4.externalData[n2]);
                }
              }
              switch (e4.dataLocation) {
                case "DEFAULT":
                case 0:
                  t2.dataLocation = 0;
                  break;
                case "EXTERNAL":
                case 1:
                  t2.dataLocation = 1;
              }
              if (e4.doubleData) {
                if (!Array.isArray(e4.doubleData)) throw TypeError(".onnx.TensorProto.doubleData: array expected");
                for (t2.doubleData = [], n2 = 0; n2 < e4.doubleData.length; ++n2) t2.doubleData[n2] = Number(e4.doubleData[n2]);
              }
              if (e4.uint64Data) {
                if (!Array.isArray(e4.uint64Data)) throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                for (t2.uint64Data = [], n2 = 0; n2 < e4.uint64Data.length; ++n2) c.Long ? (t2.uint64Data[n2] = c.Long.fromValue(e4.uint64Data[n2])).unsigned = true : "string" == typeof e4.uint64Data[n2] ? t2.uint64Data[n2] = parseInt(e4.uint64Data[n2], 10) : "number" == typeof e4.uint64Data[n2] ? t2.uint64Data[n2] = e4.uint64Data[n2] : "object" == typeof e4.uint64Data[n2] && (t2.uint64Data[n2] = new c.LongBits(e4.uint64Data[n2].low >>> 0, e4.uint64Data[n2].high >>> 0).toNumber(true));
              }
              return t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if ((t2.arrays || t2.defaults) && (n2.dims = [], n2.floatData = [], n2.int32Data = [], n2.stringData = [], n2.int64Data = [], n2.doubleData = [], n2.uint64Data = [], n2.externalData = []), t2.defaults && (n2.dataType = 0, n2.segment = null, n2.name = "", t2.bytes === String ? n2.rawData = "" : (n2.rawData = [], t2.bytes !== Array && (n2.rawData = c.newBuffer(n2.rawData))), n2.docString = "", n2.dataLocation = t2.enums === String ? "DEFAULT" : 0), e4.dims && e4.dims.length) {
                n2.dims = [];
                for (var r2 = 0; r2 < e4.dims.length; ++r2) "number" == typeof e4.dims[r2] ? n2.dims[r2] = t2.longs === String ? String(e4.dims[r2]) : e4.dims[r2] : n2.dims[r2] = t2.longs === String ? c.Long.prototype.toString.call(e4.dims[r2]) : t2.longs === Number ? new c.LongBits(e4.dims[r2].low >>> 0, e4.dims[r2].high >>> 0).toNumber() : e4.dims[r2];
              }
              if (null != e4.dataType && e4.hasOwnProperty("dataType") && (n2.dataType = e4.dataType), null != e4.segment && e4.hasOwnProperty("segment") && (n2.segment = u.onnx.TensorProto.Segment.toObject(e4.segment, t2)), e4.floatData && e4.floatData.length) for (n2.floatData = [], r2 = 0; r2 < e4.floatData.length; ++r2) n2.floatData[r2] = t2.json && !isFinite(e4.floatData[r2]) ? String(e4.floatData[r2]) : e4.floatData[r2];
              if (e4.int32Data && e4.int32Data.length) for (n2.int32Data = [], r2 = 0; r2 < e4.int32Data.length; ++r2) n2.int32Data[r2] = e4.int32Data[r2];
              if (e4.stringData && e4.stringData.length) for (n2.stringData = [], r2 = 0; r2 < e4.stringData.length; ++r2) n2.stringData[r2] = t2.bytes === String ? c.base64.encode(e4.stringData[r2], 0, e4.stringData[r2].length) : t2.bytes === Array ? Array.prototype.slice.call(e4.stringData[r2]) : e4.stringData[r2];
              if (e4.int64Data && e4.int64Data.length) for (n2.int64Data = [], r2 = 0; r2 < e4.int64Data.length; ++r2) "number" == typeof e4.int64Data[r2] ? n2.int64Data[r2] = t2.longs === String ? String(e4.int64Data[r2]) : e4.int64Data[r2] : n2.int64Data[r2] = t2.longs === String ? c.Long.prototype.toString.call(e4.int64Data[r2]) : t2.longs === Number ? new c.LongBits(e4.int64Data[r2].low >>> 0, e4.int64Data[r2].high >>> 0).toNumber() : e4.int64Data[r2];
              if (null != e4.name && e4.hasOwnProperty("name") && (n2.name = e4.name), null != e4.rawData && e4.hasOwnProperty("rawData") && (n2.rawData = t2.bytes === String ? c.base64.encode(e4.rawData, 0, e4.rawData.length) : t2.bytes === Array ? Array.prototype.slice.call(e4.rawData) : e4.rawData), e4.doubleData && e4.doubleData.length) for (n2.doubleData = [], r2 = 0; r2 < e4.doubleData.length; ++r2) n2.doubleData[r2] = t2.json && !isFinite(e4.doubleData[r2]) ? String(e4.doubleData[r2]) : e4.doubleData[r2];
              if (e4.uint64Data && e4.uint64Data.length) for (n2.uint64Data = [], r2 = 0; r2 < e4.uint64Data.length; ++r2) "number" == typeof e4.uint64Data[r2] ? n2.uint64Data[r2] = t2.longs === String ? String(e4.uint64Data[r2]) : e4.uint64Data[r2] : n2.uint64Data[r2] = t2.longs === String ? c.Long.prototype.toString.call(e4.uint64Data[r2]) : t2.longs === Number ? new c.LongBits(e4.uint64Data[r2].low >>> 0, e4.uint64Data[r2].high >>> 0).toNumber(true) : e4.uint64Data[r2];
              if (null != e4.docString && e4.hasOwnProperty("docString") && (n2.docString = e4.docString), e4.externalData && e4.externalData.length) for (n2.externalData = [], r2 = 0; r2 < e4.externalData.length; ++r2) n2.externalData[r2] = u.onnx.StringStringEntryProto.toObject(e4.externalData[r2], t2);
              return null != e4.dataLocation && e4.hasOwnProperty("dataLocation") && (n2.dataLocation = t2.enums === String ? u.onnx.TensorProto.DataLocation[e4.dataLocation] : e4.dataLocation), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3.DataType = (function() {
              var e4 = {}, t2 = Object.create(e4);
              return t2[e4[0] = "UNDEFINED"] = 0, t2[e4[1] = "FLOAT"] = 1, t2[e4[2] = "UINT8"] = 2, t2[e4[3] = "INT8"] = 3, t2[e4[4] = "UINT16"] = 4, t2[e4[5] = "INT16"] = 5, t2[e4[6] = "INT32"] = 6, t2[e4[7] = "INT64"] = 7, t2[e4[8] = "STRING"] = 8, t2[e4[9] = "BOOL"] = 9, t2[e4[10] = "FLOAT16"] = 10, t2[e4[11] = "DOUBLE"] = 11, t2[e4[12] = "UINT32"] = 12, t2[e4[13] = "UINT64"] = 13, t2[e4[14] = "COMPLEX64"] = 14, t2[e4[15] = "COMPLEX128"] = 15, t2[e4[16] = "BFLOAT16"] = 16, t2;
            })(), e3.Segment = (function() {
              function e4(e5) {
                if (e5) for (var t2 = Object.keys(e5), n2 = 0; n2 < t2.length; ++n2) null != e5[t2[n2]] && (this[t2[n2]] = e5[t2[n2]]);
              }
              return e4.prototype.begin = c.Long ? c.Long.fromBits(0, 0, false) : 0, e4.prototype.end = c.Long ? c.Long.fromBits(0, 0, false) : 0, e4.create = function(t2) {
                return new e4(t2);
              }, e4.encode = function(e5, t2) {
                return t2 || (t2 = l.create()), null != e5.begin && e5.hasOwnProperty("begin") && t2.uint32(8).int64(e5.begin), null != e5.end && e5.hasOwnProperty("end") && t2.uint32(16).int64(e5.end), t2;
              }, e4.encodeDelimited = function(e5, t2) {
                return this.encode(e5, t2).ldelim();
              }, e4.decode = function(e5, t2) {
                e5 instanceof a || (e5 = a.create(e5));
                for (var n2 = void 0 === t2 ? e5.len : e5.pos + t2, r2 = new u.onnx.TensorProto.Segment(); e5.pos < n2; ) {
                  var o2 = e5.uint32();
                  switch (o2 >>> 3) {
                    case 1:
                      r2.begin = e5.int64();
                      break;
                    case 2:
                      r2.end = e5.int64();
                      break;
                    default:
                      e5.skipType(7 & o2);
                  }
                }
                return r2;
              }, e4.decodeDelimited = function(e5) {
                return e5 instanceof a || (e5 = new a(e5)), this.decode(e5, e5.uint32());
              }, e4.verify = function(e5) {
                return "object" != typeof e5 || null === e5 ? "object expected" : null != e5.begin && e5.hasOwnProperty("begin") && !(c.isInteger(e5.begin) || e5.begin && c.isInteger(e5.begin.low) && c.isInteger(e5.begin.high)) ? "begin: integer|Long expected" : null != e5.end && e5.hasOwnProperty("end") && !(c.isInteger(e5.end) || e5.end && c.isInteger(e5.end.low) && c.isInteger(e5.end.high)) ? "end: integer|Long expected" : null;
              }, e4.fromObject = function(e5) {
                if (e5 instanceof u.onnx.TensorProto.Segment) return e5;
                var t2 = new u.onnx.TensorProto.Segment();
                return null != e5.begin && (c.Long ? (t2.begin = c.Long.fromValue(e5.begin)).unsigned = false : "string" == typeof e5.begin ? t2.begin = parseInt(e5.begin, 10) : "number" == typeof e5.begin ? t2.begin = e5.begin : "object" == typeof e5.begin && (t2.begin = new c.LongBits(e5.begin.low >>> 0, e5.begin.high >>> 0).toNumber())), null != e5.end && (c.Long ? (t2.end = c.Long.fromValue(e5.end)).unsigned = false : "string" == typeof e5.end ? t2.end = parseInt(e5.end, 10) : "number" == typeof e5.end ? t2.end = e5.end : "object" == typeof e5.end && (t2.end = new c.LongBits(e5.end.low >>> 0, e5.end.high >>> 0).toNumber())), t2;
              }, e4.toObject = function(e5, t2) {
                t2 || (t2 = {});
                var n2 = {};
                if (t2.defaults) {
                  if (c.Long) {
                    var r2 = new c.Long(0, 0, false);
                    n2.begin = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
                  } else n2.begin = t2.longs === String ? "0" : 0;
                  c.Long ? (r2 = new c.Long(0, 0, false), n2.end = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.end = t2.longs === String ? "0" : 0;
                }
                return null != e5.begin && e5.hasOwnProperty("begin") && ("number" == typeof e5.begin ? n2.begin = t2.longs === String ? String(e5.begin) : e5.begin : n2.begin = t2.longs === String ? c.Long.prototype.toString.call(e5.begin) : t2.longs === Number ? new c.LongBits(e5.begin.low >>> 0, e5.begin.high >>> 0).toNumber() : e5.begin), null != e5.end && e5.hasOwnProperty("end") && ("number" == typeof e5.end ? n2.end = t2.longs === String ? String(e5.end) : e5.end : n2.end = t2.longs === String ? c.Long.prototype.toString.call(e5.end) : t2.longs === Number ? new c.LongBits(e5.end.low >>> 0, e5.end.high >>> 0).toNumber() : e5.end), n2;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, s.util.toJSONOptions);
              }, e4;
            })(), e3.DataLocation = (function() {
              var e4 = {}, t2 = Object.create(e4);
              return t2[e4[0] = "DEFAULT"] = 0, t2[e4[1] = "EXTERNAL"] = 1, t2;
            })(), e3;
          })(), i.TensorShapeProto = (function() {
            function e3(e4) {
              if (this.dim = [], e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.dim = c.emptyArray, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              if (t2 || (t2 = l.create()), null != e4.dim && e4.dim.length) for (var n2 = 0; n2 < e4.dim.length; ++n2) u.onnx.TensorShapeProto.Dimension.encode(e4.dim[n2], t2.uint32(10).fork()).ldelim();
              return t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.TensorShapeProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                o2 >>> 3 == 1 ? (r2.dim && r2.dim.length || (r2.dim = []), r2.dim.push(u.onnx.TensorShapeProto.Dimension.decode(e4, e4.uint32()))) : e4.skipType(7 & o2);
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.dim && e4.hasOwnProperty("dim")) {
                if (!Array.isArray(e4.dim)) return "dim: array expected";
                for (var t2 = 0; t2 < e4.dim.length; ++t2) {
                  var n2 = u.onnx.TensorShapeProto.Dimension.verify(e4.dim[t2]);
                  if (n2) return "dim." + n2;
                }
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.TensorShapeProto) return e4;
              var t2 = new u.onnx.TensorShapeProto();
              if (e4.dim) {
                if (!Array.isArray(e4.dim)) throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                t2.dim = [];
                for (var n2 = 0; n2 < e4.dim.length; ++n2) {
                  if ("object" != typeof e4.dim[n2]) throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                  t2.dim[n2] = u.onnx.TensorShapeProto.Dimension.fromObject(e4.dim[n2]);
                }
              }
              return t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if ((t2.arrays || t2.defaults) && (n2.dim = []), e4.dim && e4.dim.length) {
                n2.dim = [];
                for (var r2 = 0; r2 < e4.dim.length; ++r2) n2.dim[r2] = u.onnx.TensorShapeProto.Dimension.toObject(e4.dim[r2], t2);
              }
              return n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3.Dimension = (function() {
              function e4(e5) {
                if (e5) for (var t3 = Object.keys(e5), n2 = 0; n2 < t3.length; ++n2) null != e5[t3[n2]] && (this[t3[n2]] = e5[t3[n2]]);
              }
              var t2;
              return e4.prototype.dimValue = c.Long ? c.Long.fromBits(0, 0, false) : 0, e4.prototype.dimParam = "", e4.prototype.denotation = "", Object.defineProperty(e4.prototype, "value", { get: c.oneOfGetter(t2 = ["dimValue", "dimParam"]), set: c.oneOfSetter(t2) }), e4.create = function(t3) {
                return new e4(t3);
              }, e4.encode = function(e5, t3) {
                return t3 || (t3 = l.create()), null != e5.dimValue && e5.hasOwnProperty("dimValue") && t3.uint32(8).int64(e5.dimValue), null != e5.dimParam && e5.hasOwnProperty("dimParam") && t3.uint32(18).string(e5.dimParam), null != e5.denotation && e5.hasOwnProperty("denotation") && t3.uint32(26).string(e5.denotation), t3;
              }, e4.encodeDelimited = function(e5, t3) {
                return this.encode(e5, t3).ldelim();
              }, e4.decode = function(e5, t3) {
                e5 instanceof a || (e5 = a.create(e5));
                for (var n2 = void 0 === t3 ? e5.len : e5.pos + t3, r2 = new u.onnx.TensorShapeProto.Dimension(); e5.pos < n2; ) {
                  var o2 = e5.uint32();
                  switch (o2 >>> 3) {
                    case 1:
                      r2.dimValue = e5.int64();
                      break;
                    case 2:
                      r2.dimParam = e5.string();
                      break;
                    case 3:
                      r2.denotation = e5.string();
                      break;
                    default:
                      e5.skipType(7 & o2);
                  }
                }
                return r2;
              }, e4.decodeDelimited = function(e5) {
                return e5 instanceof a || (e5 = new a(e5)), this.decode(e5, e5.uint32());
              }, e4.verify = function(e5) {
                if ("object" != typeof e5 || null === e5) return "object expected";
                var t3 = {};
                if (null != e5.dimValue && e5.hasOwnProperty("dimValue") && (t3.value = 1, !(c.isInteger(e5.dimValue) || e5.dimValue && c.isInteger(e5.dimValue.low) && c.isInteger(e5.dimValue.high)))) return "dimValue: integer|Long expected";
                if (null != e5.dimParam && e5.hasOwnProperty("dimParam")) {
                  if (1 === t3.value) return "value: multiple values";
                  if (t3.value = 1, !c.isString(e5.dimParam)) return "dimParam: string expected";
                }
                return null != e5.denotation && e5.hasOwnProperty("denotation") && !c.isString(e5.denotation) ? "denotation: string expected" : null;
              }, e4.fromObject = function(e5) {
                if (e5 instanceof u.onnx.TensorShapeProto.Dimension) return e5;
                var t3 = new u.onnx.TensorShapeProto.Dimension();
                return null != e5.dimValue && (c.Long ? (t3.dimValue = c.Long.fromValue(e5.dimValue)).unsigned = false : "string" == typeof e5.dimValue ? t3.dimValue = parseInt(e5.dimValue, 10) : "number" == typeof e5.dimValue ? t3.dimValue = e5.dimValue : "object" == typeof e5.dimValue && (t3.dimValue = new c.LongBits(e5.dimValue.low >>> 0, e5.dimValue.high >>> 0).toNumber())), null != e5.dimParam && (t3.dimParam = String(e5.dimParam)), null != e5.denotation && (t3.denotation = String(e5.denotation)), t3;
              }, e4.toObject = function(e5, t3) {
                t3 || (t3 = {});
                var n2 = {};
                return t3.defaults && (n2.denotation = ""), null != e5.dimValue && e5.hasOwnProperty("dimValue") && ("number" == typeof e5.dimValue ? n2.dimValue = t3.longs === String ? String(e5.dimValue) : e5.dimValue : n2.dimValue = t3.longs === String ? c.Long.prototype.toString.call(e5.dimValue) : t3.longs === Number ? new c.LongBits(e5.dimValue.low >>> 0, e5.dimValue.high >>> 0).toNumber() : e5.dimValue, t3.oneofs && (n2.value = "dimValue")), null != e5.dimParam && e5.hasOwnProperty("dimParam") && (n2.dimParam = e5.dimParam, t3.oneofs && (n2.value = "dimParam")), null != e5.denotation && e5.hasOwnProperty("denotation") && (n2.denotation = e5.denotation), n2;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, s.util.toJSONOptions);
              }, e4;
            })(), e3;
          })(), i.TypeProto = (function() {
            function e3(e4) {
              if (e4) for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2) null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            var t2;
            return e3.prototype.tensorType = null, e3.prototype.denotation = "", Object.defineProperty(e3.prototype, "value", { get: c.oneOfGetter(t2 = ["tensorType"]), set: c.oneOfSetter(t2) }), e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = l.create()), null != e4.tensorType && e4.hasOwnProperty("tensorType") && u.onnx.TypeProto.Tensor.encode(e4.tensorType, t3.uint32(10).fork()).ldelim(), null != e4.denotation && e4.hasOwnProperty("denotation") && t3.uint32(50).string(e4.denotation), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new u.onnx.TypeProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.tensorType = u.onnx.TypeProto.Tensor.decode(e4, e4.uint32());
                    break;
                  case 6:
                    r2.denotation = e4.string();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4) return "object expected";
              if (null != e4.tensorType && e4.hasOwnProperty("tensorType")) {
                var t3 = u.onnx.TypeProto.Tensor.verify(e4.tensorType);
                if (t3) return "tensorType." + t3;
              }
              return null != e4.denotation && e4.hasOwnProperty("denotation") && !c.isString(e4.denotation) ? "denotation: string expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.TypeProto) return e4;
              var t3 = new u.onnx.TypeProto();
              if (null != e4.tensorType) {
                if ("object" != typeof e4.tensorType) throw TypeError(".onnx.TypeProto.tensorType: object expected");
                t3.tensorType = u.onnx.TypeProto.Tensor.fromObject(e4.tensorType);
              }
              return null != e4.denotation && (t3.denotation = String(e4.denotation)), t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.denotation = ""), null != e4.tensorType && e4.hasOwnProperty("tensorType") && (n2.tensorType = u.onnx.TypeProto.Tensor.toObject(e4.tensorType, t3), t3.oneofs && (n2.value = "tensorType")), null != e4.denotation && e4.hasOwnProperty("denotation") && (n2.denotation = e4.denotation), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3.Tensor = (function() {
              function e4(e5) {
                if (e5) for (var t3 = Object.keys(e5), n2 = 0; n2 < t3.length; ++n2) null != e5[t3[n2]] && (this[t3[n2]] = e5[t3[n2]]);
              }
              return e4.prototype.elemType = 0, e4.prototype.shape = null, e4.create = function(t3) {
                return new e4(t3);
              }, e4.encode = function(e5, t3) {
                return t3 || (t3 = l.create()), null != e5.elemType && e5.hasOwnProperty("elemType") && t3.uint32(8).int32(e5.elemType), null != e5.shape && e5.hasOwnProperty("shape") && u.onnx.TensorShapeProto.encode(e5.shape, t3.uint32(18).fork()).ldelim(), t3;
              }, e4.encodeDelimited = function(e5, t3) {
                return this.encode(e5, t3).ldelim();
              }, e4.decode = function(e5, t3) {
                e5 instanceof a || (e5 = a.create(e5));
                for (var n2 = void 0 === t3 ? e5.len : e5.pos + t3, r2 = new u.onnx.TypeProto.Tensor(); e5.pos < n2; ) {
                  var o2 = e5.uint32();
                  switch (o2 >>> 3) {
                    case 1:
                      r2.elemType = e5.int32();
                      break;
                    case 2:
                      r2.shape = u.onnx.TensorShapeProto.decode(e5, e5.uint32());
                      break;
                    default:
                      e5.skipType(7 & o2);
                  }
                }
                return r2;
              }, e4.decodeDelimited = function(e5) {
                return e5 instanceof a || (e5 = new a(e5)), this.decode(e5, e5.uint32());
              }, e4.verify = function(e5) {
                if ("object" != typeof e5 || null === e5) return "object expected";
                if (null != e5.elemType && e5.hasOwnProperty("elemType") && !c.isInteger(e5.elemType)) return "elemType: integer expected";
                if (null != e5.shape && e5.hasOwnProperty("shape")) {
                  var t3 = u.onnx.TensorShapeProto.verify(e5.shape);
                  if (t3) return "shape." + t3;
                }
                return null;
              }, e4.fromObject = function(e5) {
                if (e5 instanceof u.onnx.TypeProto.Tensor) return e5;
                var t3 = new u.onnx.TypeProto.Tensor();
                if (null != e5.elemType && (t3.elemType = 0 | e5.elemType), null != e5.shape) {
                  if ("object" != typeof e5.shape) throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                  t3.shape = u.onnx.TensorShapeProto.fromObject(e5.shape);
                }
                return t3;
              }, e4.toObject = function(e5, t3) {
                t3 || (t3 = {});
                var n2 = {};
                return t3.defaults && (n2.elemType = 0, n2.shape = null), null != e5.elemType && e5.hasOwnProperty("elemType") && (n2.elemType = e5.elemType), null != e5.shape && e5.hasOwnProperty("shape") && (n2.shape = u.onnx.TensorShapeProto.toObject(e5.shape, t3)), n2;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, s.util.toJSONOptions);
              }, e4;
            })(), e3;
          })(), i.OperatorSetIdProto = (function() {
            function e3(e4) {
              if (e4) for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2) null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.domain = "", e3.prototype.version = c.Long ? c.Long.fromBits(0, 0, false) : 0, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              return t2 || (t2 = l.create()), null != e4.domain && e4.hasOwnProperty("domain") && t2.uint32(10).string(e4.domain), null != e4.version && e4.hasOwnProperty("version") && t2.uint32(16).int64(e4.version), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof a || (e4 = a.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new u.onnx.OperatorSetIdProto(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.domain = e4.string();
                    break;
                  case 2:
                    r2.version = e4.int64();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof a || (e4 = new a(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              return "object" != typeof e4 || null === e4 ? "object expected" : null != e4.domain && e4.hasOwnProperty("domain") && !c.isString(e4.domain) ? "domain: string expected" : null != e4.version && e4.hasOwnProperty("version") && !(c.isInteger(e4.version) || e4.version && c.isInteger(e4.version.low) && c.isInteger(e4.version.high)) ? "version: integer|Long expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof u.onnx.OperatorSetIdProto) return e4;
              var t2 = new u.onnx.OperatorSetIdProto();
              return null != e4.domain && (t2.domain = String(e4.domain)), null != e4.version && (c.Long ? (t2.version = c.Long.fromValue(e4.version)).unsigned = false : "string" == typeof e4.version ? t2.version = parseInt(e4.version, 10) : "number" == typeof e4.version ? t2.version = e4.version : "object" == typeof e4.version && (t2.version = new c.LongBits(e4.version.low >>> 0, e4.version.high >>> 0).toNumber())), t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if (t2.defaults) if (n2.domain = "", c.Long) {
                var r2 = new c.Long(0, 0, false);
                n2.version = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else n2.version = t2.longs === String ? "0" : 0;
              return null != e4.domain && e4.hasOwnProperty("domain") && (n2.domain = e4.domain), null != e4.version && e4.hasOwnProperty("version") && ("number" == typeof e4.version ? n2.version = t2.longs === String ? String(e4.version) : e4.version : n2.version = t2.longs === String ? c.Long.prototype.toString.call(e4.version) : t2.longs === Number ? new c.LongBits(e4.version.low >>> 0, e4.version.high >>> 0).toNumber() : e4.version), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, s.util.toJSONOptions);
            }, e3;
          })(), i), e2.exports = u;
        }, 2100: (e2, t, n) => {
          e2.exports = n(9482);
        }, 9482: (e2, t, n) => {
          var r = t;
          function o() {
            r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
          }
          r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = o, o();
        }, 1408: (e2, t, n) => {
          e2.exports = l;
          var r, o = n(9693), i = o.LongBits, s = o.utf8;
          function a(e3, t2) {
            return RangeError("index out of range: " + e3.pos + " + " + (t2 || 1) + " > " + e3.len);
          }
          function l(e3) {
            this.buf = e3, this.pos = 0, this.len = e3.length;
          }
          var c, u = "undefined" != typeof Uint8Array ? function(e3) {
            if (e3 instanceof Uint8Array || Array.isArray(e3)) return new l(e3);
            throw Error("illegal buffer");
          } : function(e3) {
            if (Array.isArray(e3)) return new l(e3);
            throw Error("illegal buffer");
          }, p = function() {
            return o.Buffer ? function(e3) {
              return (l.create = function(e4) {
                return o.Buffer.isBuffer(e4) ? new r(e4) : u(e4);
              })(e3);
            } : u;
          };
          function d() {
            var e3 = new i(0, 0), t2 = 0;
            if (!(this.len - this.pos > 4)) {
              for (; t2 < 3; ++t2) {
                if (this.pos >= this.len) throw a(this);
                if (e3.lo = (e3.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128) return e3;
              }
              return e3.lo = (e3.lo | (127 & this.buf[this.pos++]) << 7 * t2) >>> 0, e3;
            }
            for (; t2 < 4; ++t2) if (e3.lo = (e3.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128) return e3;
            if (e3.lo = (e3.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e3.hi = (e3.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e3;
            if (t2 = 0, this.len - this.pos > 4) {
              for (; t2 < 5; ++t2) if (e3.hi = (e3.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128) return e3;
            } else for (; t2 < 5; ++t2) {
              if (this.pos >= this.len) throw a(this);
              if (e3.hi = (e3.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128) return e3;
            }
            throw Error("invalid varint encoding");
          }
          function _(e3, t2) {
            return (e3[t2 - 4] | e3[t2 - 3] << 8 | e3[t2 - 2] << 16 | e3[t2 - 1] << 24) >>> 0;
          }
          function h() {
            if (this.pos + 8 > this.len) throw a(this, 8);
            return new i(_(this.buf, this.pos += 4), _(this.buf, this.pos += 4));
          }
          l.create = p(), l.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, l.prototype.uint32 = (c = 4294967295, function() {
            if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c;
            if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10);
            return c;
          }), l.prototype.int32 = function() {
            return 0 | this.uint32();
          }, l.prototype.sint32 = function() {
            var e3 = this.uint32();
            return e3 >>> 1 ^ -(1 & e3) | 0;
          }, l.prototype.bool = function() {
            return 0 !== this.uint32();
          }, l.prototype.fixed32 = function() {
            if (this.pos + 4 > this.len) throw a(this, 4);
            return _(this.buf, this.pos += 4);
          }, l.prototype.sfixed32 = function() {
            if (this.pos + 4 > this.len) throw a(this, 4);
            return 0 | _(this.buf, this.pos += 4);
          }, l.prototype.float = function() {
            if (this.pos + 4 > this.len) throw a(this, 4);
            var e3 = o.float.readFloatLE(this.buf, this.pos);
            return this.pos += 4, e3;
          }, l.prototype.double = function() {
            if (this.pos + 8 > this.len) throw a(this, 4);
            var e3 = o.float.readDoubleLE(this.buf, this.pos);
            return this.pos += 8, e3;
          }, l.prototype.bytes = function() {
            var e3 = this.uint32(), t2 = this.pos, n2 = this.pos + e3;
            if (n2 > this.len) throw a(this, e3);
            return this.pos += e3, Array.isArray(this.buf) ? this.buf.slice(t2, n2) : t2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, t2, n2);
          }, l.prototype.string = function() {
            var e3 = this.bytes();
            return s.read(e3, 0, e3.length);
          }, l.prototype.skip = function(e3) {
            if ("number" == typeof e3) {
              if (this.pos + e3 > this.len) throw a(this, e3);
              this.pos += e3;
            } else do {
              if (this.pos >= this.len) throw a(this);
            } while (128 & this.buf[this.pos++]);
            return this;
          }, l.prototype.skipType = function(e3) {
            switch (e3) {
              case 0:
                this.skip();
                break;
              case 1:
                this.skip(8);
                break;
              case 2:
                this.skip(this.uint32());
                break;
              case 3:
                for (; 4 != (e3 = 7 & this.uint32()); ) this.skipType(e3);
                break;
              case 5:
                this.skip(4);
                break;
              default:
                throw Error("invalid wire type " + e3 + " at offset " + this.pos);
            }
            return this;
          }, l._configure = function(e3) {
            r = e3, l.create = p(), r._configure();
            var t2 = o.Long ? "toLong" : "toNumber";
            o.merge(l.prototype, { int64: function() {
              return d.call(this)[t2](false);
            }, uint64: function() {
              return d.call(this)[t2](true);
            }, sint64: function() {
              return d.call(this).zzDecode()[t2](false);
            }, fixed64: function() {
              return h.call(this)[t2](true);
            }, sfixed64: function() {
              return h.call(this)[t2](false);
            } });
          };
        }, 593: (e2, t, n) => {
          e2.exports = i;
          var r = n(1408);
          (i.prototype = Object.create(r.prototype)).constructor = i;
          var o = n(9693);
          function i(e3) {
            r.call(this, e3);
          }
          i._configure = function() {
            o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice);
          }, i.prototype.string = function() {
            var e3 = this.uint32();
            return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e3, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e3, this.len));
          }, i._configure();
        }, 5054: (e2) => {
          e2.exports = {};
        }, 5994: (e2, t, n) => {
          t.Service = n(7948);
        }, 7948: (e2, t, n) => {
          e2.exports = o;
          var r = n(9693);
          function o(e3, t2, n2) {
            if ("function" != typeof e3) throw TypeError("rpcImpl must be a function");
            r.EventEmitter.call(this), this.rpcImpl = e3, this.requestDelimited = Boolean(t2), this.responseDelimited = Boolean(n2);
          }
          (o.prototype = Object.create(r.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e3(t2, n2, o2, i, s) {
            if (!i) throw TypeError("request must be specified");
            var a = this;
            if (!s) return r.asPromise(e3, a, t2, n2, o2, i);
            if (a.rpcImpl) try {
              return a.rpcImpl(t2, n2[a.requestDelimited ? "encodeDelimited" : "encode"](i).finish(), (function(e4, n3) {
                if (e4) return a.emit("error", e4, t2), s(e4);
                if (null !== n3) {
                  if (!(n3 instanceof o2)) try {
                    n3 = o2[a.responseDelimited ? "decodeDelimited" : "decode"](n3);
                  } catch (e5) {
                    return a.emit("error", e5, t2), s(e5);
                  }
                  return a.emit("data", n3, t2), s(null, n3);
                }
                a.end(true);
              }));
            } catch (e4) {
              return a.emit("error", e4, t2), void setTimeout((function() {
                s(e4);
              }), 0);
            }
            else setTimeout((function() {
              s(Error("already ended"));
            }), 0);
          }, o.prototype.end = function(e3) {
            return this.rpcImpl && (e3 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
          };
        }, 1945: (e2, t, n) => {
          e2.exports = o;
          var r = n(9693);
          function o(e3, t2) {
            this.lo = e3 >>> 0, this.hi = t2 >>> 0;
          }
          var i = o.zero = new o(0, 0);
          i.toNumber = function() {
            return 0;
          }, i.zzEncode = i.zzDecode = function() {
            return this;
          }, i.length = function() {
            return 1;
          };
          var s = o.zeroHash = "\0\0\0\0\0\0\0\0";
          o.fromNumber = function(e3) {
            if (0 === e3) return i;
            var t2 = e3 < 0;
            t2 && (e3 = -e3);
            var n2 = e3 >>> 0, r2 = (e3 - n2) / 4294967296 >>> 0;
            return t2 && (r2 = ~r2 >>> 0, n2 = ~n2 >>> 0, ++n2 > 4294967295 && (n2 = 0, ++r2 > 4294967295 && (r2 = 0))), new o(n2, r2);
          }, o.from = function(e3) {
            if ("number" == typeof e3) return o.fromNumber(e3);
            if (r.isString(e3)) {
              if (!r.Long) return o.fromNumber(parseInt(e3, 10));
              e3 = r.Long.fromString(e3);
            }
            return e3.low || e3.high ? new o(e3.low >>> 0, e3.high >>> 0) : i;
          }, o.prototype.toNumber = function(e3) {
            if (!e3 && this.hi >>> 31) {
              var t2 = 1 + ~this.lo >>> 0, n2 = ~this.hi >>> 0;
              return t2 || (n2 = n2 + 1 >>> 0), -(t2 + 4294967296 * n2);
            }
            return this.lo + 4294967296 * this.hi;
          }, o.prototype.toLong = function(e3) {
            return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(e3)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e3) };
          };
          var a = String.prototype.charCodeAt;
          o.fromHash = function(e3) {
            return e3 === s ? i : new o((a.call(e3, 0) | a.call(e3, 1) << 8 | a.call(e3, 2) << 16 | a.call(e3, 3) << 24) >>> 0, (a.call(e3, 4) | a.call(e3, 5) << 8 | a.call(e3, 6) << 16 | a.call(e3, 7) << 24) >>> 0);
          }, o.prototype.toHash = function() {
            return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
          }, o.prototype.zzEncode = function() {
            var e3 = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e3) >>> 0, this.lo = (this.lo << 1 ^ e3) >>> 0, this;
          }, o.prototype.zzDecode = function() {
            var e3 = -(1 & this.lo);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e3) >>> 0, this.hi = (this.hi >>> 1 ^ e3) >>> 0, this;
          }, o.prototype.length = function() {
            var e3 = this.lo, t2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
            return 0 === n2 ? 0 === t2 ? e3 < 16384 ? e3 < 128 ? 1 : 2 : e3 < 2097152 ? 3 : 4 : t2 < 16384 ? t2 < 128 ? 5 : 6 : t2 < 2097152 ? 7 : 8 : n2 < 128 ? 9 : 10;
          };
        }, 9693: function(e2, t, n) {
          var r = t;
          function o(e3, t2, n2) {
            for (var r2 = Object.keys(t2), o2 = 0; o2 < r2.length; ++o2) void 0 !== e3[r2[o2]] && n2 || (e3[r2[o2]] = t2[r2[o2]]);
            return e3;
          }
          function i(e3) {
            function t2(e4, n2) {
              if (!(this instanceof t2)) return new t2(e4, n2);
              Object.defineProperty(this, "message", { get: function() {
                return e4;
              } }), Error.captureStackTrace ? Error.captureStackTrace(this, t2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n2 && o(this, n2);
            }
            return (t2.prototype = Object.create(Error.prototype)).constructor = t2, Object.defineProperty(t2.prototype, "name", { get: function() {
              return e3;
            } }), t2.prototype.toString = function() {
              return this.name + ": " + this.message;
            }, t2;
          }
          r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean(void 0 !== n.g && n.g && n.g.process && n.g.process.versions && n.g.process.versions.node), r.global = r.isNode && n.g || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(e3) {
            return "number" == typeof e3 && isFinite(e3) && Math.floor(e3) === e3;
          }, r.isString = function(e3) {
            return "string" == typeof e3 || e3 instanceof String;
          }, r.isObject = function(e3) {
            return e3 && "object" == typeof e3;
          }, r.isset = r.isSet = function(e3, t2) {
            var n2 = e3[t2];
            return !(null == n2 || !e3.hasOwnProperty(t2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
          }, r.Buffer = (function() {
            try {
              var e3 = r.inquire("buffer").Buffer;
              return e3.prototype.utf8Write ? e3 : null;
            } catch (e4) {
              return null;
            }
          })(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(e3) {
            return "number" == typeof e3 ? r.Buffer ? r._Buffer_allocUnsafe(e3) : new r.Array(e3) : r.Buffer ? r._Buffer_from(e3) : "undefined" == typeof Uint8Array ? e3 : new Uint8Array(e3);
          }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(e3) {
            return e3 ? r.LongBits.from(e3).toHash() : r.LongBits.zeroHash;
          }, r.longFromHash = function(e3, t2) {
            var n2 = r.LongBits.fromHash(e3);
            return r.Long ? r.Long.fromBits(n2.lo, n2.hi, t2) : n2.toNumber(Boolean(t2));
          }, r.merge = o, r.lcFirst = function(e3) {
            return e3.charAt(0).toLowerCase() + e3.substring(1);
          }, r.newError = i, r.ProtocolError = i("ProtocolError"), r.oneOfGetter = function(e3) {
            for (var t2 = {}, n2 = 0; n2 < e3.length; ++n2) t2[e3[n2]] = 1;
            return function() {
              for (var e4 = Object.keys(this), n3 = e4.length - 1; n3 > -1; --n3) if (1 === t2[e4[n3]] && void 0 !== this[e4[n3]] && null !== this[e4[n3]]) return e4[n3];
            };
          }, r.oneOfSetter = function(e3) {
            return function(t2) {
              for (var n2 = 0; n2 < e3.length; ++n2) e3[n2] !== t2 && delete this[e3[n2]];
            };
          }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
            var e3 = r.Buffer;
            e3 ? (r._Buffer_from = e3.from !== Uint8Array.from && e3.from || function(t2, n2) {
              return new e3(t2, n2);
            }, r._Buffer_allocUnsafe = e3.allocUnsafe || function(t2) {
              return new e3(t2);
            }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
          };
        }, 1173: (e2, t, n) => {
          e2.exports = p;
          var r, o = n(9693), i = o.LongBits, s = o.base64, a = o.utf8;
          function l(e3, t2, n2) {
            this.fn = e3, this.len = t2, this.next = void 0, this.val = n2;
          }
          function c() {
          }
          function u(e3) {
            this.head = e3.head, this.tail = e3.tail, this.len = e3.len, this.next = e3.states;
          }
          function p() {
            this.len = 0, this.head = new l(c, 0, 0), this.tail = this.head, this.states = null;
          }
          var d = function() {
            return o.Buffer ? function() {
              return (p.create = function() {
                return new r();
              })();
            } : function() {
              return new p();
            };
          };
          function _(e3, t2, n2) {
            t2[n2] = 255 & e3;
          }
          function h(e3, t2) {
            this.len = e3, this.next = void 0, this.val = t2;
          }
          function f(e3, t2, n2) {
            for (; e3.hi; ) t2[n2++] = 127 & e3.lo | 128, e3.lo = (e3.lo >>> 7 | e3.hi << 25) >>> 0, e3.hi >>>= 7;
            for (; e3.lo > 127; ) t2[n2++] = 127 & e3.lo | 128, e3.lo = e3.lo >>> 7;
            t2[n2++] = e3.lo;
          }
          function m(e3, t2, n2) {
            t2[n2] = 255 & e3, t2[n2 + 1] = e3 >>> 8 & 255, t2[n2 + 2] = e3 >>> 16 & 255, t2[n2 + 3] = e3 >>> 24;
          }
          p.create = d(), p.alloc = function(e3) {
            return new o.Array(e3);
          }, o.Array !== Array && (p.alloc = o.pool(p.alloc, o.Array.prototype.subarray)), p.prototype._push = function(e3, t2, n2) {
            return this.tail = this.tail.next = new l(e3, t2, n2), this.len += t2, this;
          }, h.prototype = Object.create(l.prototype), h.prototype.fn = function(e3, t2, n2) {
            for (; e3 > 127; ) t2[n2++] = 127 & e3 | 128, e3 >>>= 7;
            t2[n2] = e3;
          }, p.prototype.uint32 = function(e3) {
            return this.len += (this.tail = this.tail.next = new h((e3 >>>= 0) < 128 ? 1 : e3 < 16384 ? 2 : e3 < 2097152 ? 3 : e3 < 268435456 ? 4 : 5, e3)).len, this;
          }, p.prototype.int32 = function(e3) {
            return e3 < 0 ? this._push(f, 10, i.fromNumber(e3)) : this.uint32(e3);
          }, p.prototype.sint32 = function(e3) {
            return this.uint32((e3 << 1 ^ e3 >> 31) >>> 0);
          }, p.prototype.uint64 = function(e3) {
            var t2 = i.from(e3);
            return this._push(f, t2.length(), t2);
          }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(e3) {
            var t2 = i.from(e3).zzEncode();
            return this._push(f, t2.length(), t2);
          }, p.prototype.bool = function(e3) {
            return this._push(_, 1, e3 ? 1 : 0);
          }, p.prototype.fixed32 = function(e3) {
            return this._push(m, 4, e3 >>> 0);
          }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(e3) {
            var t2 = i.from(e3);
            return this._push(m, 4, t2.lo)._push(m, 4, t2.hi);
          }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(e3) {
            return this._push(o.float.writeFloatLE, 4, e3);
          }, p.prototype.double = function(e3) {
            return this._push(o.float.writeDoubleLE, 8, e3);
          };
          var g = o.Array.prototype.set ? function(e3, t2, n2) {
            t2.set(e3, n2);
          } : function(e3, t2, n2) {
            for (var r2 = 0; r2 < e3.length; ++r2) t2[n2 + r2] = e3[r2];
          };
          p.prototype.bytes = function(e3) {
            var t2 = e3.length >>> 0;
            if (!t2) return this._push(_, 1, 0);
            if (o.isString(e3)) {
              var n2 = p.alloc(t2 = s.length(e3));
              s.decode(e3, n2, 0), e3 = n2;
            }
            return this.uint32(t2)._push(g, t2, e3);
          }, p.prototype.string = function(e3) {
            var t2 = a.length(e3);
            return t2 ? this.uint32(t2)._push(a.write, t2, e3) : this._push(_, 1, 0);
          }, p.prototype.fork = function() {
            return this.states = new u(this), this.head = this.tail = new l(c, 0, 0), this.len = 0, this;
          }, p.prototype.reset = function() {
            return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new l(c, 0, 0), this.len = 0), this;
          }, p.prototype.ldelim = function() {
            var e3 = this.head, t2 = this.tail, n2 = this.len;
            return this.reset().uint32(n2), n2 && (this.tail.next = e3.next, this.tail = t2, this.len += n2), this;
          }, p.prototype.finish = function() {
            for (var e3 = this.head.next, t2 = this.constructor.alloc(this.len), n2 = 0; e3; ) e3.fn(e3.val, t2, n2), n2 += e3.len, e3 = e3.next;
            return t2;
          }, p._configure = function(e3) {
            r = e3, p.create = d(), r._configure();
          };
        }, 3155: (e2, t, n) => {
          e2.exports = i;
          var r = n(1173);
          (i.prototype = Object.create(r.prototype)).constructor = i;
          var o = n(9693);
          function i() {
            r.call(this);
          }
          function s(e3, t2, n2) {
            e3.length < 40 ? o.utf8.write(e3, t2, n2) : t2.utf8Write ? t2.utf8Write(e3, n2) : t2.write(e3, n2);
          }
          i._configure = function() {
            i.alloc = o._Buffer_allocUnsafe, i.writeBytesBuffer = o.Buffer && o.Buffer.prototype instanceof Uint8Array && "set" === o.Buffer.prototype.set.name ? function(e3, t2, n2) {
              t2.set(e3, n2);
            } : function(e3, t2, n2) {
              if (e3.copy) e3.copy(t2, n2, 0, e3.length);
              else for (var r2 = 0; r2 < e3.length; ) t2[n2++] = e3[r2++];
            };
          }, i.prototype.bytes = function(e3) {
            o.isString(e3) && (e3 = o._Buffer_from(e3, "base64"));
            var t2 = e3.length >>> 0;
            return this.uint32(t2), t2 && this._push(i.writeBytesBuffer, t2, e3), this;
          }, i.prototype.string = function(e3) {
            var t2 = o.Buffer.byteLength(e3);
            return this.uint32(t2), t2 && this._push(s, t2, e3), this;
          }, i._configure();
        }, 7714: (e2, t, n) => {
          t.R = void 0;
          const r = n(6919), o = n(7448);
          t.R = new class {
            async init() {
            }
            async createSessionHandler(e3, t2) {
              const n2 = new r.Session(t2);
              return await n2.loadModel(e3), new o.OnnxjsSessionHandler(n2);
            }
          }();
        }, 4200: (e2, t, n) => {
          t.c8 = t.rX = void 0;
          const r = n(1670), o = n(5381), i = n(2157), s = n(2306);
          t.rX = () => {
            if (("number" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), "boolean" != typeof r.env.wasm.simd && (r.env.wasm.simd = true), "boolean" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = false), "number" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {
              const e3 = "undefined" == typeof navigator ? (0, o.cpus)().length : navigator.hardwareConcurrency;
              r.env.wasm.numThreads = Math.min(4, Math.ceil((e3 || 1) / 2));
            }
          }, t.c8 = new class {
            async init() {
              (0, t.rX)(), await (0, i.initWasm)();
            }
            async createSessionHandler(e3, t2) {
              const n2 = new s.OnnxruntimeWebAssemblySessionHandler();
              return await n2.loadModel(e3, t2), Promise.resolve(n2);
            }
          }();
        }, 6018: function(e2, t, n) {
          var r = this && this.__createBinding || (Object.create ? function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var o2 = Object.getOwnPropertyDescriptor(t2, n2);
            o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
              return t2[n2];
            } }), Object.defineProperty(e3, r2, o2);
          } : function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2), e3[r2] = t2[n2];
          }), o = this && this.__exportStar || function(e3, t2) {
            for (var n2 in e3) "default" === n2 || Object.prototype.hasOwnProperty.call(t2, n2) || r(t2, e3, n2);
          };
          Object.defineProperty(t, "__esModule", { value: true }), o(n(1670), t);
          const i = n(1670);
          {
            const e3 = n(7714).R;
            (0, i.registerBackend)("webgl", e3, -10);
          }
          {
            const e3 = n(4200).c8;
            (0, i.registerBackend)("cpu", e3, 10), (0, i.registerBackend)("wasm", e3, 10), (0, i.registerBackend)("xnnpack", e3, 9);
          }
        }, 246: (e2, t) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createAttributeWithCacheKey = void 0;
          class n {
            constructor(e3) {
              Object.assign(this, e3);
            }
            get cacheKey() {
              return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map(((e3) => `${this[e3]}`)).join(";")), this._cacheKey;
            }
          }
          t.createAttributeWithCacheKey = (e3) => new n(e3);
        }, 7778: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.Attribute = void 0;
          const r = n(1446), o = n(9395), i = n(9162), s = n(2517);
          var a = o.onnxruntime.experimental.fbs;
          class l {
            constructor(e3) {
              if (this._attributes = /* @__PURE__ */ new Map(), null != e3) {
                for (const t2 of e3) t2 instanceof r.onnx.AttributeProto ? this._attributes.set(t2.name, [l.getValue(t2), l.getType(t2)]) : t2 instanceof a.Attribute && this._attributes.set(t2.name(), [l.getValue(t2), l.getType(t2)]);
                if (this._attributes.size < e3.length) throw new Error("duplicated attribute names");
              }
            }
            set(e3, t2, n2) {
              this._attributes.set(e3, [n2, t2]);
            }
            delete(e3) {
              this._attributes.delete(e3);
            }
            getFloat(e3, t2) {
              return this.get(e3, "float", t2);
            }
            getInt(e3, t2) {
              return this.get(e3, "int", t2);
            }
            getString(e3, t2) {
              return this.get(e3, "string", t2);
            }
            getTensor(e3, t2) {
              return this.get(e3, "tensor", t2);
            }
            getFloats(e3, t2) {
              return this.get(e3, "floats", t2);
            }
            getInts(e3, t2) {
              return this.get(e3, "ints", t2);
            }
            getStrings(e3, t2) {
              return this.get(e3, "strings", t2);
            }
            getTensors(e3, t2) {
              return this.get(e3, "tensors", t2);
            }
            get(e3, t2, n2) {
              const r2 = this._attributes.get(e3);
              if (void 0 === r2) {
                if (void 0 !== n2) return n2;
                throw new Error(`required attribute not found: ${e3}`);
              }
              if (r2[1] !== t2) throw new Error(`type mismatch: expected ${t2} but got ${r2[1]}`);
              return r2[0];
            }
            static getType(e3) {
              const t2 = e3 instanceof r.onnx.AttributeProto ? e3.type : e3.type();
              switch (t2) {
                case r.onnx.AttributeProto.AttributeType.FLOAT:
                  return "float";
                case r.onnx.AttributeProto.AttributeType.INT:
                  return "int";
                case r.onnx.AttributeProto.AttributeType.STRING:
                  return "string";
                case r.onnx.AttributeProto.AttributeType.TENSOR:
                  return "tensor";
                case r.onnx.AttributeProto.AttributeType.FLOATS:
                  return "floats";
                case r.onnx.AttributeProto.AttributeType.INTS:
                  return "ints";
                case r.onnx.AttributeProto.AttributeType.STRINGS:
                  return "strings";
                case r.onnx.AttributeProto.AttributeType.TENSORS:
                  return "tensors";
                default:
                  throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[t2]}`);
              }
            }
            static getValue(e3) {
              const t2 = e3 instanceof r.onnx.AttributeProto ? e3.type : e3.type();
              if (t2 === r.onnx.AttributeProto.AttributeType.GRAPH || t2 === r.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error("graph attribute is not supported yet");
              const n2 = this.getValueNoCheck(e3);
              if (t2 === r.onnx.AttributeProto.AttributeType.INT && s.LongUtil.isLong(n2)) return s.LongUtil.longToNumber(n2);
              if (t2 === r.onnx.AttributeProto.AttributeType.INTS) {
                const e4 = n2, t3 = new Array(e4.length);
                for (let n3 = 0; n3 < e4.length; n3++) {
                  const r2 = e4[n3];
                  t3[n3] = s.LongUtil.longToNumber(r2);
                }
                return t3;
              }
              if (t2 === r.onnx.AttributeProto.AttributeType.TENSOR) return e3 instanceof r.onnx.AttributeProto ? i.Tensor.fromProto(n2) : i.Tensor.fromOrtTensor(n2);
              if (t2 === r.onnx.AttributeProto.AttributeType.TENSORS) {
                if (e3 instanceof r.onnx.AttributeProto) return n2.map(((e4) => i.Tensor.fromProto(e4)));
                if (e3 instanceof a.Attribute) return n2.map(((e4) => i.Tensor.fromOrtTensor(e4)));
              }
              if (t2 === r.onnx.AttributeProto.AttributeType.STRING && e3 instanceof r.onnx.AttributeProto) {
                const e4 = n2;
                return (0, s.decodeUtf8String)(e4);
              }
              return t2 === r.onnx.AttributeProto.AttributeType.STRINGS && e3 instanceof r.onnx.AttributeProto ? n2.map(s.decodeUtf8String) : n2;
            }
            static getValueNoCheck(e3) {
              return e3 instanceof r.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e3) : this.getValueNoCheckFromOrtFormat(e3);
            }
            static getValueNoCheckFromOnnxFormat(e3) {
              switch (e3.type) {
                case r.onnx.AttributeProto.AttributeType.FLOAT:
                  return e3.f;
                case r.onnx.AttributeProto.AttributeType.INT:
                  return e3.i;
                case r.onnx.AttributeProto.AttributeType.STRING:
                  return e3.s;
                case r.onnx.AttributeProto.AttributeType.TENSOR:
                  return e3.t;
                case r.onnx.AttributeProto.AttributeType.GRAPH:
                  return e3.g;
                case r.onnx.AttributeProto.AttributeType.FLOATS:
                  return e3.floats;
                case r.onnx.AttributeProto.AttributeType.INTS:
                  return e3.ints;
                case r.onnx.AttributeProto.AttributeType.STRINGS:
                  return e3.strings;
                case r.onnx.AttributeProto.AttributeType.TENSORS:
                  return e3.tensors;
                case r.onnx.AttributeProto.AttributeType.GRAPHS:
                  return e3.graphs;
                default:
                  throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[e3.type]}`);
              }
            }
            static getValueNoCheckFromOrtFormat(e3) {
              switch (e3.type()) {
                case a.AttributeType.FLOAT:
                  return e3.f();
                case a.AttributeType.INT:
                  return e3.i();
                case a.AttributeType.STRING:
                  return e3.s();
                case a.AttributeType.TENSOR:
                  return e3.t();
                case a.AttributeType.GRAPH:
                  return e3.g();
                case a.AttributeType.FLOATS:
                  return e3.floatsArray();
                case a.AttributeType.INTS: {
                  const t2 = [];
                  for (let n2 = 0; n2 < e3.intsLength(); n2++) t2.push(e3.ints(n2));
                  return t2;
                }
                case a.AttributeType.STRINGS: {
                  const t2 = [];
                  for (let n2 = 0; n2 < e3.stringsLength(); n2++) t2.push(e3.strings(n2));
                  return t2;
                }
                case a.AttributeType.TENSORS: {
                  const t2 = [];
                  for (let n2 = 0; n2 < e3.tensorsLength(); n2++) t2.push(e3.tensors(n2));
                  return t2;
                }
                default:
                  throw new Error(`unsupported attribute type: ${a.AttributeType[e3.type()]}`);
              }
            }
          }
          t.Attribute = l;
        }, 7091: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.resolveBackend = t.backend = void 0;
          const r = n(5038), o = /* @__PURE__ */ new Map();
          async function i(e3) {
            const n2 = t.backend;
            if (void 0 !== n2[e3] && (function(e4) {
              const t2 = e4;
              return "initialize" in t2 && "function" == typeof t2.initialize && "createSessionHandler" in t2 && "function" == typeof t2.createSessionHandler && "dispose" in t2 && "function" == typeof t2.dispose;
            })(n2[e3])) {
              const t2 = n2[e3];
              let r2 = t2.initialize();
              if ("object" == typeof r2 && "then" in r2 && (r2 = await r2), r2) return o.set(e3, t2), t2;
            }
          }
          t.backend = { webgl: new r.WebGLBackend() }, t.resolveBackend = async function e3(t2) {
            if (!t2) return e3(["webgl"]);
            {
              const e4 = "string" == typeof t2 ? [t2] : t2;
              for (const t3 of e4) {
                const e5 = o.get(t3);
                if (e5) return e5;
                const n2 = await i(t3);
                if (n2) return n2;
              }
            }
            throw new Error("no available backend to use");
          };
        }, 5038: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.WebGLBackend = void 0;
          const r = n(1670), o = n(6231), i = n(6416), s = n(7305);
          t.WebGLBackend = class {
            get contextId() {
              return r.env.webgl.contextId;
            }
            set contextId(e3) {
              r.env.webgl.contextId = e3;
            }
            get matmulMaxBatchSize() {
              return r.env.webgl.matmulMaxBatchSize;
            }
            set matmulMaxBatchSize(e3) {
              r.env.webgl.matmulMaxBatchSize = e3;
            }
            get textureCacheMode() {
              return r.env.webgl.textureCacheMode;
            }
            set textureCacheMode(e3) {
              r.env.webgl.textureCacheMode = e3;
            }
            get pack() {
              return r.env.webgl.pack;
            }
            set pack(e3) {
              r.env.webgl.pack = e3;
            }
            get async() {
              return r.env.webgl.async;
            }
            set async(e3) {
              r.env.webgl.async = e3;
            }
            initialize() {
              try {
                return this.glContext = (0, s.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), o.Logger.setWithEnv(r.env), o.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
              } catch (e3) {
                return o.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e3}`), false;
              }
            }
            createSessionHandler(e3) {
              return new i.WebGLSessionHandler(this, e3);
            }
            dispose() {
              this.glContext.dispose();
            }
          };
        }, 5107: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.CoordsGlslLib = void 0;
          const r = n(2517), o = n(8520), i = n(5060), s = n(7859), a = n(9390);
          class l extends o.GlslLib {
            constructor(e3) {
              super(e3);
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
            }
            getCustomTypes() {
              return {};
            }
            offsetToCoords() {
              return { offsetToCoords: new o.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
            }
            coordsToOffset() {
              return { coordsToOffset: new o.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
            }
            getOutputSamplingSnippet() {
              const e3 = this.context.outputTextureLayout;
              return e3.isPacked ? this.getPackedOutputSamplingSnippet(e3) : this.getUnpackedOutputSamplingSnippet(e3);
            }
            getPackedOutputSamplingSnippet(e3) {
              const t2 = e3.unpackedShape, n2 = [e3.width, e3.height], r2 = {}, s2 = "getOutputCoords";
              switch (t2.length) {
                case 0:
                  r2[s2] = this.getOutputScalarCoords();
                  break;
                case 1:
                  r2[s2] = this.getOutputPacked1DCoords(t2, n2);
                  break;
                case 2:
                  r2[s2] = this.getOutputPacked2DCoords(t2, n2);
                  break;
                case 3:
                  r2[s2] = this.getOutputPacked3DCoords(t2, n2);
                  break;
                default:
                  r2[s2] = this.getOutputPackedNDCoords(t2, n2);
              }
              const a2 = `
      void setOutput(vec4 val) {
        ${(0, i.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
              return r2.floatTextureSetRGBA = new o.GlslLibRoutine(a2), r2;
            }
            getUnpackedOutputSamplingSnippet(e3) {
              const t2 = e3.unpackedShape, n2 = [e3.width, e3.height], r2 = {}, s2 = "getOutputCoords";
              switch (t2.length) {
                case 0:
                  r2[s2] = this.getOutputScalarCoords();
                  break;
                case 1:
                  r2[s2] = this.getOutputUnpacked1DCoords(t2, n2);
                  break;
                case 2:
                  r2[s2] = this.getOutputUnpacked2DCoords(t2, n2);
                  break;
                case 3:
                  r2[s2] = this.getOutputUnpacked3DCoords(t2, n2);
                  break;
                case 4:
                  r2[s2] = this.getOutputUnpacked4DCoords(t2, n2);
                  break;
                case 5:
                  r2[s2] = this.getOutputUnpacked5DCoords(t2, n2);
                  break;
                case 6:
                  r2[s2] = this.getOutputUnpacked6DCoords(t2, n2);
                  break;
                default:
                  throw new Error(`Unsupported output dimensionality: ${t2.length}`);
              }
              const a2 = `
        void setOutput(float val) {
          ${(0, i.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
              return r2.floatTextureSetR = new o.GlslLibRoutine(a2), r2;
            }
            getOutputScalarCoords() {
              return new o.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
            }
            getOutputPacked1DCoords(e3, t2) {
              const n2 = t2;
              let r2 = "";
              return 1 === n2[0] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n2[1]}.0);
          }
        `, new o.GlslLibRoutine(r2)) : 1 === n2[1] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n2[0]}.0);
          }
        `, new o.GlslLibRoutine(r2)) : (r2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n2[0]}, ${n2[1]}));
          return 2 * (resTexRC.y * ${n2[0]} + resTexRC.x);
        }
      `, new o.GlslLibRoutine(r2));
            }
            getOutputPacked2DCoords(e3, t2) {
              let n2 = "";
              if (r.ArrayUtil.arraysEqual(e3, t2)) return n2 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t2[0]}, ${t2[1]}));
        }
      `, new o.GlslLibRoutine(n2);
              const i2 = t2, s2 = Math.ceil(e3[1] / 2);
              return n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i2[0]}, ${i2[1]}));

          int index = resTexRC.y * ${i2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${s2}) * 2;
          int c = 2 * (index / ${s2});

          return ivec2(r, c);
        }
      `, new o.GlslLibRoutine(n2);
            }
            getOutputPacked3DCoords(e3, t2) {
              const n2 = [t2[0], t2[1]], r2 = Math.ceil(e3[2] / 2), i2 = r2 * Math.ceil(e3[1] / 2), s2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n2[0]}, ${n2[1]}));
          int index = resTexRC.y * ${n2[0]} + resTexRC.x;

          int b = index / ${i2};
          index -= b * ${i2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r2}) * 2;
          int c = 2 * (index / ${r2});

          return ivec3(b, r, c);
        }
      `;
              return new o.GlslLibRoutine(s2);
            }
            getOutputPackedNDCoords(e3, t2) {
              const n2 = [t2[0], t2[1]], r2 = Math.ceil(e3[e3.length - 1] / 2), i2 = r2 * Math.ceil(e3[e3.length - 2] / 2);
              let s2 = i2, a2 = "", l2 = "b, r, c";
              for (let t3 = 2; t3 < e3.length - 1; t3++) s2 *= e3[e3.length - t3 - 1], a2 = `
      int b${t3} = index / ${s2};
      index -= b${t3} * ${s2};
    ` + a2, l2 = `b${t3}, ` + l2;
              const c = `
      ivec${e3.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n2[0]}, ${n2[1]}));
        int index = resTexRC.y * ${n2[0]} + resTexRC.x;

        ${a2}

        int b = index / ${i2};
        index -= b * ${i2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r2}) * 2;
        int c = 2 * (index / ${r2});

        return ivec${e3.length}(${l2});
      }
    `;
              return new o.GlslLibRoutine(c);
            }
            getOutputUnpacked1DCoords(e3, t2) {
              const n2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          return resTexRC.y * ${t2[0]} + resTexRC.x;
        }
      `;
              return new o.GlslLibRoutine(n2);
            }
            getOutputUnpacked2DCoords(e3, t2) {
              const n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          int r = index / ${e3[1]};
          int c = index - r * ${e3[1]};
          return ivec2(r, c);
        }
      `;
              return new o.GlslLibRoutine(n2);
            }
            getOutputUnpacked3DCoords(e3, t2) {
              let n2 = "";
              const r2 = e3.length;
              let i2 = null;
              r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e3[r2 - 1];
              for (let t3 = r2 - 3; t3 >= 0; --t3) i2[t3] = i2[t3 + 1] * e3[t3 + 1];
              const s2 = ["r", "c", "d"], a2 = i2.map(((e4, t3) => `int ${s2[t3]} = index / ${e4}; ${t3 === i2.length - 1 ? `int ${s2[t3 + 1]} = index - ${s2[t3]} * ${e4}` : `index -= ${s2[t3]} * ${e4}`};`)).join("");
              return n2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${a2}
          return ivec3(r, c, d);
        }
      `, new o.GlslLibRoutine(n2);
            }
            getOutputUnpacked4DCoords(e3, t2) {
              let n2 = "";
              const r2 = e3.length;
              let i2 = null;
              r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e3[r2 - 1];
              for (let t3 = r2 - 3; t3 >= 0; --t3) i2[t3] = i2[t3 + 1] * e3[t3 + 1];
              const s2 = ["r", "c", "d", "d2"], a2 = i2.map(((e4, t3) => `int ${s2[t3]} = index / ${e4}; ${t3 === i2.length - 1 ? `int ${s2[t3 + 1]} = index - ${s2[t3]} * ${e4}` : `index -= ${s2[t3]} * ${e4}`};`)).join("");
              return n2 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${a2}
          return ivec4(r, c, d, d2);
        }
      `, new o.GlslLibRoutine(n2);
            }
            getOutputUnpacked5DCoords(e3, t2) {
              let n2 = "";
              const r2 = e3.length;
              let i2 = null;
              r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e3[r2 - 1];
              for (let t3 = r2 - 3; t3 >= 0; --t3) i2[t3] = i2[t3 + 1] * e3[t3 + 1];
              const s2 = ["r", "c", "d", "d2", "d3"], a2 = i2.map(((e4, t3) => `int ${s2[t3]} = index / ${e4}; ${t3 === i2.length - 1 ? `int ${s2[t3 + 1]} = index - ${s2[t3]} * ${e4}` : `index -= ${s2[t3]} * ${e4}`};`)).join("");
              return n2 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${a2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new o.GlslLibRoutine(n2);
            }
            getOutputUnpacked6DCoords(e3, t2) {
              let n2 = "";
              const r2 = e3.length;
              let i2 = null;
              r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e3[r2 - 1];
              for (let t3 = r2 - 3; t3 >= 0; --t3) i2[t3] = i2[t3 + 1] * e3[t3 + 1];
              const s2 = ["r", "c", "d", "d2", "d3", "d4"], a2 = i2.map(((e4, t3) => `int ${s2[t3]} = index / ${e4}; ${t3 === i2.length - 1 ? `int ${s2[t3 + 1]} = index - ${s2[t3]} * ${e4}` : `index -= ${s2[t3]} * ${e4}`};`)).join("");
              return n2 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t2[0]}, ${t2[1]}));
         int index = resTexRC.y * ${t2[0]} + resTexRC.x;
         ${a2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new o.GlslLibRoutine(n2);
            }
            getCommonUtilFuncs() {
              const e3 = {};
              let t2 = "uvFromFlat";
              e3[t2] = new o.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), t2 = "packedUVfrom1D", e3[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom2D", e3[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom3D", e3[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "sampleTexture";
              const n2 = (0, i.getGlsl)(this.context.glContext.version);
              return e3[t2] = new o.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n2.texture2D}(textureSampler, uv).r;
        }`), e3;
            }
            getInputsSamplingSnippets() {
              const e3 = {}, t2 = this.context.outputTextureLayout;
              return this.context.programInfo.inputNames.forEach(((n2, r2) => {
                const o2 = this.context.inputTextureLayouts[r2], i2 = (0, a.generateShaderFuncNameFromInputSamplerName)(n2);
                o2.isPacked ? e3[i2] = this.getPackedSamplerFromInput(i2, n2, o2) : e3[i2] = this.getUnpackedSamplerFromInput(i2, n2, o2);
                const s2 = (0, a.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n2);
                o2.unpackedShape.length <= t2.unpackedShape.length && (o2.isPacked ? e3[s2] = this.getPackedSamplerAtOutputCoords(s2, o2, t2, n2) : e3[s2] = this.getUnpackedSamplerAtOutputCoords(s2, o2, t2, n2));
              })), e3;
            }
            getPackedSamplerAtOutputCoords(e3, t2, n2, i2) {
              const s2 = t2.unpackedShape, l2 = n2.unpackedShape, c = i2, u = (0, a.generateShaderFuncNameFromInputSamplerName)(c), p = s2.length, d = l2.length, _ = r.BroadcastUtil.getBroadcastDims(s2, l2), h = (0, a.getCoordsDataType)(d), f = d - p;
              let m;
              const g = (0, a.getGlChannels)();
              m = 0 === p ? "" : d < 2 && _.length >= 1 ? "coords = 0;" : _.map(((e4) => `coords.${g[e4 + f]} = 0;`)).join("\n");
              let b = "";
              b = d < 2 && p > 0 ? "coords" : s2.map(((e4, t3) => `coords.${g[t3 + f]}`)).join(", ");
              let w = "return outputValue;";
              const x = 1 === r.ShapeUtil.size(s2), y = 1 === r.ShapeUtil.size(l2);
              if (1 !== p || x || y) {
                if (x && !y) w = 1 === d ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
                else if (_.length) {
                  const e4 = p - 2, t3 = p - 1;
                  _.indexOf(e4) > -1 && _.indexOf(t3) > -1 ? w = "return vec4(outputValue.x);" : _.indexOf(e4) > -1 ? w = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : _.indexOf(t3) > -1 && (w = "return vec4(outputValue.xx, outputValue.zz);");
                }
              } else w = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
              const T = `
      vec4 ${e3}() {
        ${h} coords = getOutputCoords();
        
        int lastDim = coords.${g[d - 1]};
        coords.${g[d - 1]} = coords.${g[d - 2]};
        coords.${g[d - 2]} = lastDim;
      
        ${m}
        vec4 outputValue = ${u}(${b});
        ${w}
      }
    `;
              return new o.GlslLibRoutine(T, ["coordinates.getOutputCoords"]);
            }
            getUnpackedSamplerAtOutputCoords(e3, t2, n2, i2) {
              const s2 = [n2.width, n2.height], l2 = [t2.width, t2.height], c = t2.unpackedShape.length, u = n2.unpackedShape.length, p = t2.unpackedShape, d = n2.unpackedShape, _ = (0, a.generateShaderFuncNameFromInputSamplerName)(i2);
              if (c === u && r.ArrayUtil.arraysEqual(l2, s2)) {
                const t3 = `
          float ${e3}() {
            return sampleTexture(${i2}, TexCoords);
          }
        `;
                return new o.GlslLibRoutine(t3, ["coordinates.sampleTexture"]);
              }
              const h = (0, a.getCoordsDataType)(u), f = r.BroadcastUtil.getBroadcastDims(p, d), m = u - c;
              let g;
              const b = (0, a.getGlChannels)();
              g = 0 === c ? "" : u < 2 && f.length >= 1 ? "coords = 0;" : f.map(((e4) => `coords.${b[e4 + m]} = 0;`)).join("\n");
              let w = "";
              w = u < 2 && c > 0 ? "coords" : t2.unpackedShape.map(((e4, t3) => `coords.${b[t3 + m]}`)).join(", ");
              const x = `
        float ${e3}() {
          ${h} coords = getOutputCoords();
          ${g}
          return ${_}(${w});
        }
      `;
              return new o.GlslLibRoutine(x, ["coordinates.getOutputCoords"]);
            }
            getPackedSamplerFromInput(e3, t2, n2) {
              switch (n2.unpackedShape.length) {
                case 0:
                  return this.getPackedSamplerScalar(e3, t2);
                case 1:
                  return this.getPackedSampler1D(e3, t2, n2);
                case 2:
                  return this.getPackedSampler2D(e3, t2, n2);
                case 3:
                  return this.getPackedSampler3D(e3, t2, n2);
                default:
                  return this.getPackedSamplerND(e3, t2, n2);
              }
            }
            getUnpackedSamplerFromInput(e3, t2, n2) {
              const r2 = n2.unpackedShape;
              switch (r2.length) {
                case 0:
                  return this.getUnpackedSamplerScalar(e3, t2, n2);
                case 1:
                  return this.getUnpackedSampler1D(e3, t2, n2);
                case 2:
                  return this.getUnpackedSampler2D(e3, t2, n2);
                case 3:
                  return this.getUnpackedSampler3D(e3, t2, n2);
                case 4:
                  return this.getUnpackedSampler4D(e3, t2, n2);
                case 5:
                  return this.getUnpackedSampler5D(e3, t2, n2);
                case 6:
                  return this.getUnpackedSampler6D(e3, t2, n2);
                default:
                  throw new Error(`Unsupported dimension ${r2.length}-D`);
              }
            }
            getPackedSamplerScalar(e3, t2) {
              const n2 = `
          vec4 ${e3}() {
            return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${t2}, halfCR);
          }
        `;
              return new o.GlslLibRoutine(n2);
            }
            getPackedSampler1D(e3, t2, n2) {
              const r2 = [n2.width, n2.height], s2 = [r2[1], r2[0]], a2 = (0, i.getGlsl)(this.context.glContext.version), l2 = `vec4 ${e3}(int index) {
      vec2 uv = packedUVfrom1D(
      ${s2[0]}, ${s2[1]}, index);
      return ${a2.texture2D}(${t2}, uv);
    }`;
              return new o.GlslLibRoutine(l2, ["coordinates.packedUVfrom1D"]);
            }
            getPackedSampler2D(e3, t2, n2) {
              const s2 = n2.unpackedShape, a2 = [n2.width, n2.height], l2 = (0, i.getGlsl)(this.context.glContext.version), c = a2[0], u = a2[1];
              if (null != a2 && r.ArrayUtil.arraysEqual(s2, a2)) {
                const n3 = `vec4 ${e3}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${c}.0);
        return ${l2.texture2D}(${t2}, uv);
      }`;
                return new o.GlslLibRoutine(n3);
              }
              const p = a2, d = Math.ceil(s2[1] / 2), _ = `vec4 ${e3}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);
      return ${l2.texture2D}(${t2}, uv);
    }`;
              return new o.GlslLibRoutine(_, ["coordinates.packedUVfrom2D"]);
            }
            getPackedSampler3D(e3, t2, n2) {
              const r2 = n2.unpackedShape, s2 = [n2.width, n2.height], l2 = [s2[0], s2[1]], c = (0, i.getGlsl)(this.context.glContext.version);
              if (1 === r2[0]) {
                const i2 = r2.slice(1), s3 = [1, 2], l3 = (0, a.squeezeInputShape)(r2, i2), c2 = ["b", "row", "col"], u2 = JSON.parse(JSON.stringify(n2));
                u2.unpackedShape = l3;
                const p2 = this.getPackedSamplerFromInput(e3, t2, u2), d2 = `${p2.routineBody}
      vec4 ${e3}(int b, int row, int col) {
        return ${e3}(${(0, a.getSqueezedParams)(c2, s3)});
      } `;
                return new o.GlslLibRoutine(d2, p2.dependencies);
              }
              const u = l2[0], p = l2[1], d = Math.ceil(r2[2] / 2), _ = `vec4 ${e3}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${u}, ${d * Math.ceil(r2[1] / 2)}, ${d}, b, row, col);
      return ${c.texture2D}(${t2}, uv);}`;
              return new o.GlslLibRoutine(_, ["coordinates.packedUVfrom3D"]);
            }
            getPackedSamplerND(e3, t2, n2) {
              const r2 = n2.unpackedShape, s2 = r2.length, a2 = [n2.width, n2.height], l2 = (0, i.getGlsl)(this.context.glContext.version), c = [a2[0], a2[1]], u = c[1], p = c[0], d = Math.ceil(r2[s2 - 1] / 2);
              let _ = d * Math.ceil(r2[s2 - 2] / 2), h = "int b, int row, int col", f = `b * ${_} + (row / 2) * ${d} + (col / 2)`;
              for (let e4 = 2; e4 < s2 - 1; e4++) h = `int b${e4}, ` + h, _ *= r2[s2 - e4 - 1], f = `b${e4} * ${_} + ` + f;
              const m = `vec4 ${e3}(${h}) {
      int index = ${f};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});
      return ${l2.texture2D}(${t2}, uv);
    }`;
              return new o.GlslLibRoutine(m);
            }
            getUnpackedSamplerScalar(e3, t2, n2) {
              const [r2, i2] = [n2.width, n2.height];
              if (1 === r2 && 1 === i2) {
                const n3 = `
          float ${e3}() {
            return sampleTexture(${t2}, halfCR);
          }
        `;
                return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const s2 = `
        float ${e3}() {
          int offset_${t2} = coordsToOffset(TexCoords, ${r2}, ${i2});
          vec2 uv = uvFromFlat(${r2}, ${i2}, offset_${t2});
          return sampleTexture(${t2}, uv);
        }
      `;
              return new o.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler1D(e3, t2, n2) {
              const r2 = n2.width, i2 = n2.height;
              if (1 === i2 && 1 === r2) {
                const n3 = `
        float ${e3}(int index) {
          return sampleTexture(${t2}, halfCR);
        }
      `;
                return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              if (1 === i2) {
                const n3 = `
          float ${e3}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r2}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
                return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              if (1 === r2) {
                const n3 = `
          float ${e3}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i2}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
                return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const s2 = `
        float ${e3}(int index) {
          vec2 uv = uvFromFlat(${r2}, ${i2}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
              return new o.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
            }
            getUnpackedSampler2D(e3, t2, n2) {
              const i2 = n2.unpackedShape, l2 = [n2.height, n2.width];
              if (null != l2 && r.ArrayUtil.arraysEqual(i2, l2)) {
                const n3 = `
          float ${e3}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${l2[1]}.0, ${l2[0]}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
                return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const { newShape: c, keptDims: u } = (0, s.squeezeShape)(i2), p = c;
              if (p.length < i2.length) {
                const r2 = (0, a.squeezeInputShape)(i2, p), s2 = JSON.parse(JSON.stringify(n2));
                s2.unpackedShape = r2;
                const l3 = ["col", "row"], c2 = `
          ${this.getUnpackedSamplerFromInput(e3, t2, s2).routineBody}
          float ${e3}(int row, int col) {
            return ${e3}(${(0, a.getSqueezedParams)(l3, u)});
          }
        `;
                return new o.GlslLibRoutine(c2, ["coordinates.sampleTexture"]);
              }
              const d = l2[1], _ = l2[0];
              if (1 === _) {
                const n3 = `
          float ${e3}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${_});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${i2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
                return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
              }
              if (1 === d) {
                const n3 = `
          float ${e3}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${_});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${i2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${_}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
                return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
              }
              const h = `
        float ${e3}(int row, int col) {
          int index = col * ${i2[1]} + row;
          vec2 uv = uvFromFlat(${d}, ${_}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
              return new o.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler3D(e3, t2, n2) {
              const r2 = n2.unpackedShape, i2 = r2[1] * r2[2], l2 = r2[2], { newShape: c, keptDims: u } = (0, s.squeezeShape)(r2), p = c;
              if (p.length < r2.length) {
                const i3 = (0, a.squeezeInputShape)(r2, p), s2 = ["batch", "col", "row"], l3 = JSON.parse(JSON.stringify(n2));
                l3.unpackedShape = i3;
                const c2 = this.getUnpackedSamplerFromInput(e3, t2, l3), d2 = u.reverse(), _ = `
          ${c2.routineBody}
          float ${e3}(int batch, int row, int col) {
            return ${e3}(${(0, a.getSqueezedParams)(s2, d2)});
          }
        `;
                return new o.GlslLibRoutine(_, c2.dependencies);
              }
              const d = `
          float ${e3}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${i2} + col * ${l2} + row;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
      `;
              return new o.GlslLibRoutine(d, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler4D(e3, t2, n2) {
              const r2 = n2.unpackedShape, i2 = r2[3], s2 = r2[2] * i2, a2 = `
        float ${e3}(int row, int col, int depth, int depth2) {
          int index = row * ${r2[1] * s2} + col * ${s2} +
              depth2 * ${i2} + depth;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
              return new o.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
            }
            getUnpackedSampler5D(e3, t2, n2) {
              const r2 = n2.unpackedShape, i2 = r2[4], l2 = r2[3] * i2, c = r2[2] * l2, u = r2[1] * c, { newShape: p, keptDims: d } = (0, s.squeezeShape)(r2);
              if (p.length < r2.length) {
                const i3 = (0, a.squeezeInputShape)(r2, p), s2 = ["row", "col", "depth", "depth2", "depth3"], l3 = JSON.parse(JSON.stringify(n2));
                l3.unpackedShape = i3;
                const c2 = `
          ${this.getUnpackedSamplerFromInput(e3, t2, l3).routineBody}
          float ${e3}(int row, int col, int depth, int depth2, int depth3) {
            return ${e3}(${(0, a.getSqueezedParams)(s2, d)});
          }
        `;
                return new o.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
              }
              const _ = `
        float ${e3}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${u} + col * ${c} + depth * ${l2} +
          depth3 * ${i2} + depth2;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
              return new o.GlslLibRoutine(_, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            getUnpackedSampler6D(e3, t2, n2) {
              const r2 = n2.unpackedShape, i2 = r2[5], l2 = r2[4] * i2, c = r2[3] * l2, u = r2[2] * c, p = r2[1] * u, { newShape: d, keptDims: _ } = (0, s.squeezeShape)(r2);
              if (d.length < r2.length) {
                const i3 = (0, a.squeezeInputShape)(r2, d), s2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], l3 = JSON.parse(JSON.stringify(n2));
                l3.unpackedShape = i3;
                const c2 = `
            ${this.getUnpackedSamplerFromInput(e3, t2, l3).routineBody}
            float ${e3}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e3}(${(0, a.getSqueezedParams)(s2, _)});
            }
          `;
                return new o.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
              }
              const h = `
          float ${e3}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${u} + depth * ${c} +
            depth2 * ${l2} + depth3 * ${i2} + depth4;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            toVec() {
              const e3 = this.context.outputTextureLayout, t2 = e3.shape.length, n2 = e3.strides, r2 = e3.width, i2 = e3.height, s2 = [];
              for (let e4 = 0; e4 < t2 - 1; ++e4) s2.push(`
        c[${e4}] = offset / ${n2[e4]};`), s2.push(`
        offset -= c[${e4}] * ${n2[e4]};`);
              s2.push(`
        c[${t2 - 1}] = offset;`);
              const a2 = `
      void toVec(vec2 texCoords, out int c[${t2}]) {
        int offset = coordsToOffset(texCoords, ${r2}, ${i2});
        ${s2.join("")}
      }
      void toVec(int offset, out int c[${t2}]) {
        ${s2.join("")}
      }
    `;
              return { toVec: new o.GlslLibRoutine(a2, ["coordinates.coordsToOffset"]) };
            }
            valueFrom() {
              const e3 = {};
              return this.context.programInfo.inputNames.forEach(((t2, n2) => {
                const r2 = this.context.inputTextureLayouts[n2], i2 = (r2.unpackedShape.length > 0 ? r2.unpackedShape : r2.shape).length;
                let s2 = `_${t2}`;
                e3[s2] = new o.GlslLibRoutine(this.getValueFromSingle(t2, i2, r2.width, r2.height, false), [`shapeUtils.indicesToOffset${s2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), s2 += "_T", e3[s2] = new o.GlslLibRoutine(this.getValueFromSingle(t2, i2, r2.width, r2.height, true), [`shapeUtils.indicesToOffset${s2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
              })), e3;
            }
            getValueFromSingle(e3, t2, n2, r2, o2) {
              let s2 = `_${e3}`;
              return o2 && (s2 += "_T"), `
        float ${s2}(int m[${t2}]) {
          int offset = indicesToOffset${s2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          float value = getColorAsFloat(${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e3}, coords));
          return value;
        }
        `;
            }
            getPackedValueFrom(e3, t2, n2, r2, o2) {
              let s2 = `_${e3}_Pack`;
              return o2 && (s2 += "_T"), `
        vec4 ${s2}(int m[${t2}]) {
          int offset = indicesToOffset_${e3}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e3}, coords);
        }
        `;
            }
          }
          t.CoordsGlslLib = l;
        }, 8520: (e2, t) => {
          var n;
          Object.defineProperty(t, "__esModule", { value: true }), t.TopologicalSortGlslRoutines = t.GlslLibRoutineNode = t.GlslLibRoutine = t.GlslLib = t.GlslContext = t.FunctionType = void 0, (n = t.FunctionType || (t.FunctionType = {}))[n.ValueBased = 0] = "ValueBased", n[n.Positional = 1] = "Positional", t.GlslContext = class {
            constructor(e3, t2, n2, r) {
              this.glContext = e3, this.programInfo = t2, this.inputTextureLayouts = n2, this.outputTextureLayout = r;
            }
          }, t.GlslLib = class {
            constructor(e3) {
              this.context = e3;
            }
          }, t.GlslLibRoutine = class {
            constructor(e3, t2) {
              this.routineBody = e3, this.dependencies = t2;
            }
          }, t.GlslLibRoutineNode = class {
            constructor(e3, t2, n2) {
              this.name = e3, this.dependencies = n2 || [], t2 && (this.routineBody = t2);
            }
            addDependency(e3) {
              e3 && this.dependencies.push(e3);
            }
          }, t.TopologicalSortGlslRoutines = class {
            static returnOrderedNodes(e3) {
              if (!e3 || 0 === e3.length) return [];
              if (1 === e3.length) return e3;
              const t2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), r = new Array();
              return this.createOrderedNodes(e3, t2, n2, r), r;
            }
            static createOrderedNodes(e3, t2, n2, r) {
              for (let o = 0; o < e3.length; ++o) this.dfsTraverse(e3[o], t2, n2, r);
            }
            static dfsTraverse(e3, t2, n2, r) {
              if (!e3 || n2.has(e3.name)) return;
              if (t2.has(e3.name)) throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
              t2.add(e3.name);
              const o = e3.dependencies;
              if (o && o.length > 0) for (let e4 = 0; e4 < o.length; ++e4) this.dfsTraverse(o[e4], t2, n2, r);
              r.push(e3), n2.add(e3.name), t2.delete(e3.name);
            }
          };
        }, 7341: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.EncodingGlslLib = void 0;
          const r = n(8520);
          class o extends r.GlslLib {
            constructor(e3) {
              super(e3);
            }
            getFunctions() {
              return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
            }
            getCustomTypes() {
              return {};
            }
            encodeFloat32() {
              return { encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
            }
            decodeFloat32() {
              return { decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
            }
            encodeUint8() {
              const e3 = o.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return { encode: new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e3}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
            }
            decodeUint8() {
              const e3 = o.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return { decode: new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e3}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
            }
            static isLittleEndian() {
              const e3 = new ArrayBuffer(4), t2 = new Uint32Array(e3), n2 = new Uint8Array(e3);
              if (t2[0] = 3735928559, 239 === n2[0]) return true;
              if (222 === n2[0]) return false;
              throw new Error("unknown endianness");
            }
          }
          t.EncodingGlslLib = o;
        }, 9894: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.FragColorGlslLib = void 0;
          const r = n(8520), o = n(5060);
          class i extends r.GlslLib {
            constructor(e3) {
              super(e3);
            }
            getFunctions() {
              return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
            }
            getCustomTypes() {
              return {};
            }
            setFragColor() {
              const e3 = (0, o.getGlsl)(this.context.glContext.version);
              return { setFragColor: new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${e3.output} = encode(value);
        }
        `, ["encoding.encode"]) };
            }
            getColorAsFloat() {
              return { getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
            }
          }
          t.FragColorGlslLib = i;
        }, 2848: (e2, t) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.replaceInlines = void 0;
          const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
          t.replaceInlines = function(e3) {
            const t2 = {};
            let r;
            for (; null !== (r = n.exec(e3)); ) {
              const e4 = r[3].split(",").map(((e5) => {
                const t3 = e5.trim().split(" ");
                return t3 && 2 === t3.length ? { type: t3[0], name: t3[1] } : null;
              })).filter(((e5) => null !== e5));
              t2[r[2]] = { params: e4, body: r[4] };
            }
            for (const n2 in t2) {
              const o = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n2), i = new RegExp(o, "gm");
              for (; null !== (r = i.exec(e3)); ) {
                const o2 = r[1], i2 = r[2], s = r[3].split(","), a = o2 ? `${o2} ${i2};` : "";
                let l = t2[n2].body, c = "";
                t2[n2].params.forEach(((e4, t3) => {
                  e4 && (c += `${e4.type} ${e4.name} = ${s[t3]};
`);
                })), l = `${c}
 ${l}`, l = l.replace("return", `${i2} = `);
                const u = `
      ${a}
      {
        ${l}
      }
      `;
                e3 = e3.replace(r[0], u);
              }
            }
            return e3.replace(n, "");
          };
        }, 8879: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.GlslPreprocessor = void 0;
          const r = n(8520), o = n(2848), i = n(5483), s = n(5060);
          t.GlslPreprocessor = class {
            constructor(e3, t2, n2, o2) {
              this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(e3, t2, n2, o2), Object.keys(i.glslRegistry).forEach(((e4) => {
                const t3 = new i.glslRegistry[e4](this.context);
                this.libs[e4] = t3;
              }));
              const s2 = this.glslLibRoutineDependencyGraph;
              for (const e4 in this.libs) {
                const t3 = this.libs[e4].getFunctions();
                for (const n3 in t3) {
                  const o3 = e4 + "." + n3;
                  let i2;
                  s2[o3] ? (i2 = s2[o3], i2.routineBody = t3[n3].routineBody) : (i2 = new r.GlslLibRoutineNode(o3, t3[n3].routineBody), s2[o3] = i2);
                  const a = t3[n3].dependencies;
                  if (a) for (let e5 = 0; e5 < a.length; ++e5) if (s2[a[e5]]) i2.addDependency(s2[a[e5]]);
                  else {
                    const t4 = new r.GlslLibRoutineNode(a[e5]);
                    s2[a[e5]] = t4, i2.addDependency(t4);
                  }
                }
              }
            }
            preprocess() {
              const e3 = this.context.programInfo;
              let t2 = e3.shaderSource;
              return this.context.programInfo.hasMain || (t2 = `${t2}
      ${(0, s.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), t2 = (0, o.replaceInlines)(t2), `${(0, s.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(e3.inputNames, e3.variables)}
    ${this.getImports(t2)}
    ${t2}`;
            }
            getImports(e3) {
              const t2 = this.selectGlslLibRoutinesToBeIncluded(e3);
              if (0 === t2.length) return "";
              let n2 = "";
              for (let e4 = 0; e4 < t2.length; ++e4) {
                if (!t2[e4].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${t2[e4].name}`);
                n2 += t2[e4].routineBody + "\n";
              }
              return n2;
            }
            selectGlslLibRoutinesToBeIncluded(e3) {
              const t2 = [];
              return Object.keys(this.glslLibRoutineDependencyGraph).forEach(((n2) => {
                const r2 = n2.split(".")[1];
                -1 !== e3.indexOf(r2) && t2.push(this.glslLibRoutineDependencyGraph[n2]);
              })), r.TopologicalSortGlslRoutines.returnOrderedNodes(t2);
            }
            getUniforms(e3, t2) {
              const n2 = [];
              if (e3) for (const t3 of e3) n2.push(`uniform sampler2D ${t3};`);
              if (t2) for (const e4 of t2) n2.push(`uniform ${e4.type} ${e4.name}${e4.arrayLength ? `[${e4.arrayLength}]` : ""};`);
              return n2.join("\n");
            }
          };
        }, 5483: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.glslRegistry = void 0;
          const r = n(5107), o = n(7341), i = n(9894), s = n(2655), a = n(3891);
          t.glslRegistry = { encoding: o.EncodingGlslLib, fragcolor: i.FragColorGlslLib, vec: a.VecGlslLib, shapeUtils: s.ShapeUtilsGlslLib, coordinates: r.CoordsGlslLib };
        }, 2655: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.ShapeUtilsGlslLib = void 0;
          const r = n(8520);
          class o extends r.GlslLib {
            constructor(e3) {
              super(e3);
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
            }
            getCustomTypes() {
              return {};
            }
            bcastIndex() {
              const e3 = this.context.outputTextureLayout.shape.length, t2 = {};
              return this.context.programInfo.inputNames.forEach(((n2, o2) => {
                const i = this.context.inputTextureLayouts[o2].unpackedShape;
                if (i.length <= e3) {
                  const o3 = i.length, s = e3 - o3, a = `bcastIndices_${n2}`;
                  let l = "";
                  for (let e4 = 0; e4 < o3; ++e4) l += `
          realIndices[${e4}] = int( mod(float(bcastedIndices[${s + e4}]), ${i[e4]}.0) );
          `;
                  const c = `
        void ${a} (int bcastedIndices[${e3}], out int realIndices[${o3}]) {
          ${l}
        }
        `;
                  t2[a] = new r.GlslLibRoutine(c);
                }
              })), t2;
            }
            bcastMatmulIndex() {
              const e3 = this.context.outputTextureLayout.shape.length, t2 = {};
              return this.context.programInfo.inputNames.forEach(((n2, o2) => {
                const i = this.context.inputTextureLayouts[o2].shape;
                if (!(i.length < 2 || i.length > e3)) {
                  const o3 = i.length, s = e3 - o3, a = `bcastMatmulIndices_${n2}`;
                  let l = "";
                  for (let e4 = 0; e4 < o3 - 2; ++e4) l += `
          realIndices[${e4}] = int( mod(float(bcastedIndices[${s + e4}]), ${i[e4]}.0) );
          `;
                  const c = `
        void ${a}(int bcastedIndices[${e3}], out int realIndices[${o3}]) {
          ${l}
          realIndices[${o3 - 1}] = bcastedIndices[${e3 - 1}];
          realIndices[${o3 - 2}] = bcastedIndices[${e3 - 2}];
        }
        `;
                  t2[a] = new r.GlslLibRoutine(c);
                }
              })), t2;
            }
            indicesToOffset() {
              const e3 = {};
              return this.context.programInfo.inputNames.forEach(((t2, n2) => {
                const i = this.context.inputTextureLayouts[n2].shape, s = this.context.inputTextureLayouts[n2].strides, a = i.length;
                let l = `indicesToOffset_${t2}`;
                e3[l] = new r.GlslLibRoutine(o.indexToOffsetSingle(l, a, s)), l = `indicesToOffset_${t2}_T`, e3[l] = new r.GlslLibRoutine(o.indexToOffsetSingle(l, a, s.slice().reverse()));
              })), e3;
            }
            static indexToOffsetSingle(e3, t2, n2) {
              let r2 = "";
              for (let e4 = t2 - 1; e4 >= 0; --e4) r2 += `
        offset += indices[${e4}] * ${n2[e4]};
        `;
              return `
      int ${e3}(int indices[${t2}]) {
        int offset = 0;
        ${r2}
        return offset;
      }
      `;
            }
            offsetToIndices() {
              const e3 = {};
              return this.context.programInfo.inputNames.forEach(((t2, n2) => {
                const i = this.context.inputTextureLayouts[n2].shape, s = this.context.inputTextureLayouts[n2].strides, a = i.length;
                let l = `offsetToIndices_${t2}`;
                e3[l] = new r.GlslLibRoutine(o.offsetToIndicesSingle(l, a, s)), l = `offsetToIndices_${t2}_T`, e3[l] = new r.GlslLibRoutine(o.offsetToIndicesSingle(l, a, s.slice().reverse()));
              })), e3;
            }
            static offsetToIndicesSingle(e3, t2, n2) {
              const r2 = [];
              for (let e4 = 0; e4 < t2 - 1; ++e4) r2.push(`
      indices[${e4}] = offset / ${n2[e4]};`), r2.push(`
        offset -= indices[${e4}] * ${n2[e4]};`);
              return r2.push(`
      indices[${t2 - 1}] = offset;`), `
      void ${e3}(int offset, out int indices[${t2}]) {
        ${r2.join("")}
      }
      `;
            }
            incrementIndices() {
              const e3 = {};
              return this.context.programInfo.inputNames.forEach(((t2, n2) => {
                const o2 = this.context.inputTextureLayouts[n2].shape, i = o2.length, s = `incrementIndices_${t2}`;
                let a = "";
                for (let e4 = 0; e4 < i; ++e4) a += `
        shape[${e4}] = ${o2[e4]};`;
                const l = `
        void ${s}(int axis, out int indices[${i}]) {
          int shape[${i}];
          ${a};
          for(int i = ${i} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
                e3[s] = new r.GlslLibRoutine(l);
              })), e3;
            }
          }
          t.ShapeUtilsGlslLib = o;
        }, 5060: (e2, t) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.getDefaultFragShaderMain = t.getFragShaderPreamble = t.getVertexShaderSource = t.getGlsl = void 0;
          const n = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
          function o(e3) {
            return 1 === e3 ? n : r;
          }
          t.getGlsl = o, t.getVertexShaderSource = function(e3) {
            const t2 = o(e3);
            return `${t2.version}
      precision highp float;
      ${t2.attribute} vec3 position;
      ${t2.attribute} vec2 textureCoord;

      ${t2.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
          }, t.getFragShaderPreamble = function(e3) {
            const t2 = o(e3);
            return `${t2.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t2.varyingFrag} vec2 TexCoords;
    ${t2.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
          }, t.getDefaultFragShaderMain = function(e3, t2) {
            return `
  void main() {
    int indices[${t2}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o(e3).output} = result;
  }
  `;
          };
        }, 3891: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.VecGlslLib = void 0;
          const r = n(8520);
          class o extends r.GlslLib {
            constructor(e3) {
              super(e3);
            }
            getCustomTypes() {
              return {};
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
            }
            binaryVecFunctions() {
              const e3 = this.context.outputTextureLayout.shape.length, t2 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n2 = {};
              for (const o2 in t2) {
                const i = `${o2}Vec`;
                let s = "";
                for (let n3 = 0; n3 < e3; ++n3) s += `
          dest[${n3}] ${t2[o2]} src[${n3}];
          `;
                const a = `
        void ${i}(int src[${e3}], out int dest[${e3}]) {
          ${s}
        }
        `;
                n2[i] = new r.GlslLibRoutine(a);
              }
              return n2;
            }
            copyVec() {
              const e3 = this.context.outputTextureLayout.shape.length;
              let t2 = "";
              for (let n3 = 0; n3 < e3; ++n3) t2 += `
        dest[${n3}] = src[${n3}];
        `;
              const n2 = `
      void copyVec(int src[${e3}], out int dest[${e3}]) {
        ${t2}
      }
      `;
              return { copyVec: new r.GlslLibRoutine(n2) };
            }
            setVecItem() {
              const e3 = this.context.outputTextureLayout.shape.length;
              let t2 = `
        if(index < 0)
            index =${e3} + index;
        if (index == 0)
            m[0] = value;
        `;
              for (let n3 = 1; n3 < e3 - 1; ++n3) t2 += `
        else if (index == ${n3})
            m[${n3}] = value;
            `;
              t2 += `
        else
            m[${e3 - 1}] = value;
        `;
              const n2 = `
      void setVecItem(out int m[${e3}], int index, int value) {
        ${t2}
      }
        `;
              return { setVecItem: new r.GlslLibRoutine(n2) };
            }
            getVecItem() {
              const e3 = this.context.outputTextureLayout.shape.length;
              let t2 = `
        if(index < 0)
            index = ${e3} + index;
        if (index == 0)
            return m[0];
      `;
              for (let n3 = 1; n3 < e3 - 1; ++n3) t2 += `
        else if (index == ${n3})
            return m[${n3}];
      `;
              t2 += `
        else
            return m[${e3 - 1}];
        `;
              const n2 = `
      int getVecItem(int m[${e3}], int index) {
        ${t2}
      }
    `;
              return { getVecItem: new r.GlslLibRoutine(n2) };
            }
          }
          t.VecGlslLib = o;
        }, 8316: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.WebGLInferenceHandler = void 0;
          const r = n(6231), o = n(9162), i = n(2517), s = n(2403), a = n(7019), l = n(8710), c = n(5611), u = n(4057), p = n(2039);
          t.WebGLInferenceHandler = class {
            constructor(e3) {
              this.session = e3, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            calculateTextureWidthAndHeight(e3, t2) {
              return (0, u.calculateTextureWidthAndHeight)(this.session.layoutStrategy, e3, t2);
            }
            executeProgram(e3, t2) {
              if (t2.length < e3.inputNames.length) throw new Error(`Input size mustn't be less than ${e3.inputNames.length}.`);
              if (e3.inputNames.length !== e3.inputTypes.length) throw new Error("input names size does not match input types");
              const n2 = [];
              for (let r3 = 0; r3 < e3.inputNames.length; ++r3) n2[r3] = this.getOrCreateTextureData(t2[r3], e3.inputTypes[r3]);
              const r2 = ((e4, t3) => {
                const n3 = t3.map(((e5) => `${e5.unpackedShape.join(",")};${e5.width}x${e5.height}`)).join("_");
                let r3 = e4.name;
                return e4.cacheHint && (r3 += "[" + e4.cacheHint + "]"), r3 += ":" + n3, r3;
              })(e3, n2);
              let o2 = this.session.programManager.getArtifact(r2);
              const i2 = o2 ? o2.programInfo : "function" == typeof e3.get ? e3.get() : e3, s2 = (0, u.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i2.output.dims, i2.output.textureType), a2 = this.createTextureData(s2, i2.output.type);
              return o2 || (o2 = this.session.programManager.build(i2, n2, a2), this.session.programManager.setArtifact(r2, o2)), this.runProgram(o2, n2, a2), a2;
            }
            run(e3, t2) {
              return this.executeProgram(e3, t2).tensor;
            }
            runProgram(e3, t2, n2) {
              for (let n3 = 0; n3 < t2.length; ++n3) if (!!t2[n3].isPacked != (e3.programInfo.inputTypes[n3] === p.TextureType.packed)) throw new Error(`input[${n3}] property packed inconsistent`);
              if (!!n2.isPacked != (e3.programInfo.output.textureType === p.TextureType.packed)) throw new Error("output property packed inconsistent");
              this.session.programManager.run(e3, t2, n2);
            }
            getOrCreateTextureData(e3, t2) {
              let n2 = this.getTextureData(e3.dataId, t2 === p.TextureType.packed);
              if (!n2 && (n2 = this.getTextureData(e3.dataId, t2 !== p.TextureType.packed), n2)) return t2 === p.TextureType.packed ? this.pack(n2) : this.unpack(n2);
              if (!n2) {
                const r2 = (0, u.createTextureLayoutFromTextureType)(this.session.layoutStrategy, e3.dims, t2);
                if (t2 === p.TextureType.packedLastDimension) {
                  const n3 = 1, r3 = 4, o2 = e3.dims;
                  if (4 === o2.length) {
                    const i2 = [o2[0], Math.ceil(o2[1] * o2[2] * o2[3] / r3)], s2 = (0, u.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i2, t2);
                    let a2 = e3.numberData;
                    if (o2[1] * o2[2] * o2[3] % r3 != 0) {
                      const t3 = o2[0], i3 = o2[1] * o2[2] * o2[3], s3 = Math.ceil(i3 * n3 / r3) * r3;
                      a2 = new Float32Array(t3 * s3);
                      for (let r4 = 0; r4 < t3; ++r4) {
                        const t4 = r4 * i3, o3 = r4 * s3 + r4 % n3 * i3;
                        a2.set(e3.numberData.subarray(t4, t4 + i3), o3);
                      }
                    }
                    return this.createTextureData(s2, e3.type, a2, e3, 1);
                  }
                }
                if (t2 === p.TextureType.packed) {
                  const t3 = (0, u.createTextureLayoutFromShape)(this.session.layoutStrategy, e3.dims, 1, [], { reverseWH: true }), r3 = this.createTextureData(t3, e3.type, e3.numberData, e3, 1);
                  n2 = this.pack(r3);
                } else n2 = this.createTextureData(r2, e3.type, e3.numberData, e3, 1);
              }
              return n2;
            }
            createTextureDataFromLayoutBindTensor(e3, t2, n2, r2) {
              return this.createTextureData(e3, t2, n2, r2, 1);
            }
            createTextureData(e3, t2, n2, o2, i2) {
              r.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(e3)}]`);
              const s2 = this.session.textureManager.createTextureFromLayout(t2, e3, n2, i2);
              return this.createTextureDataFromTexture(e3, t2, s2, o2);
            }
            reshapeUnpacked(e3, t2) {
              const n2 = this.getOrCreateTextureData(e3, p.TextureType.unpacked), r2 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: i.ShapeUtil.computeStrides(t2), unpackedShape: t2 };
              return this.createTextureDataFromTexture(r2, e3.type, n2.texture).tensor;
            }
            reshapePacked(e3, t2) {
              const n2 = this.getOrCreateTextureData(e3, p.TextureType.packed);
              if ((0, a.isReshapeCheap)(e3.dims, t2)) {
                const r3 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: i.ShapeUtil.computeStrides(t2), unpackedShape: t2, isPacked: true };
                return this.createTextureDataFromTexture(r3, e3.type, n2.texture).tensor;
              }
              const r2 = (0, a.processDims3D)(e3.dims), o2 = (0, a.processDims3D)(t2), s2 = this.reshapePacked(e3, r2), l2 = this.run((0, a.createPackedReshape3DProgramInfoLoader)(this, s2, o2), [s2]);
              return this.reshapePacked(l2, t2);
            }
            cast(e3, t2) {
              const n2 = this.getOrCreateTextureData(e3, p.TextureType.unpacked);
              return this.createTextureDataFromTexture(n2, t2, n2.texture).tensor;
            }
            createTextureDataFromTexture(e3, t2, n2, r2, i2) {
              const s2 = Object.assign(Object.assign({}, e3), { tensor: r2 || new o.Tensor(e3.unpackedShape, t2, ((e4) => this.readTexture(s2)), (async (e4) => this.readTextureAsync(s2)), void 0, i2), texture: n2 });
              return this.setTextureData(s2.tensor.dataId, s2, e3.isPacked), s2;
            }
            getTextureData(e3, t2 = false) {
              return this.session.isInitializer(e3) ? this.session.getTextureData(e3, t2) : t2 ? this.packedTextureDataCache.get(e3) : this.unpackedTextureDataCache.get(e3);
            }
            setTextureData(e3, t2, n2 = false) {
              this.session.isInitializer(e3) ? this.session.setTextureData(e3, t2, n2) : (n2 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e3, t2);
            }
            isTextureLayoutCached(e3, t2 = false) {
              return !!this.getTextureData(e3.dataId, t2);
            }
            dispose() {
              this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(((e3) => this.session.textureManager.releaseTexture(e3))), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach(((e3) => this.session.textureManager.releaseTexture(e3))), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            readTexture(e3) {
              return e3.isPacked ? this.readTexture(this.unpack(e3)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e3, e3.tensor.type, e3.channels) : this.session.textureManager.readUint8TextureAsFloat((0, l.encodeAsUint8)(this, e3));
            }
            async readTextureAsync(e3) {
              return e3.isPacked ? this.readTextureAsync(this.unpack(e3)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e3, e3.tensor.type, e3.channels) : this.session.textureManager.readUint8TextureAsFloat((0, l.encodeAsUint8)(this, e3));
            }
            pack(e3) {
              return this.executeProgram((0, s.createPackProgramInfoLoader)(this, e3.tensor), [e3.tensor]);
            }
            unpack(e3) {
              return this.executeProgram((0, c.createUnpackProgramInfoLoader)(this, e3.tensor), [e3.tensor]);
            }
          };
        }, 1640: function(e2, t, n) {
          var r = this && this.__createBinding || (Object.create ? function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var o2 = Object.getOwnPropertyDescriptor(t2, n2);
            o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
              return t2[n2];
            } }), Object.defineProperty(e3, r2, o2);
          } : function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2), e3[r2] = t2[n2];
          }), o = this && this.__setModuleDefault || (Object.create ? function(e3, t2) {
            Object.defineProperty(e3, "default", { enumerable: true, value: t2 });
          } : function(e3, t2) {
            e3.default = t2;
          }), i = this && this.__importStar || function(e3) {
            if (e3 && e3.__esModule) return e3;
            var t2 = {};
            if (null != e3) for (var n2 in e3) "default" !== n2 && Object.prototype.hasOwnProperty.call(e3, n2) && r(t2, e3, n2);
            return o(t2, e3), t2;
          };
          Object.defineProperty(t, "__esModule", { value: true }), t.WEBGL_OP_RESOLVE_RULES = void 0;
          const s = n(2898), a = i(n(7839)), l = n(4196), c = n(2069), u = n(8138), p = n(9663), d = n(5193), _ = n(7992), h = n(1253), f = n(4776), m = n(6572), g = n(3346), b = n(5623), w = n(2870), x = n(2143), y = n(4939), T = n(718), v = n(2268), k = n(8117), M = n(2278), S = n(5524), P = n(5975), A = n(3933), F = n(6558), C = n(5723), E = n(3738), O = i(n(4909)), I = n(8428), D = n(9793);
          t.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", O.abs], ["Acos", "", "7+", O.acos], ["Add", "", "7+", a.add], ["And", "", "7+", a.and], ["Asin", "", "7+", O.asin], ["Atan", "", "7+", O.atan], ["AveragePool", "", "7+", x.averagePool, x.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", s.batchNormalization, s.parseBatchNormalizationAttributes], ["Cast", "", "6+", l.cast, l.parseCastAttributes], ["Ceil", "", "6+", O.ceil], ["Clip", "", "6-10", O.clip, O.parseClipAttributes], ["Clip", "", "11+", O.clipV11], ["Concat", "", "4+", c.concat, c.parseConcatAttributes], ["Conv", "", "1+", u.conv, u.parseConvAttributes], ["ConvTranspose", "", "1+", p.convTranspose, p.parseConvTransposeAttributes], ["Cos", "", "7+", O.cos], ["Div", "", "7+", a.div], ["Dropout", "", "7+", O.identity], ["DepthToSpace", "", "1+", d.depthToSpace, d.parseDepthToSpaceAttributes], ["Equal", "", "7+", a.equal], ["Elu", "", "6+", O.elu, O.parseEluAttributes], ["Exp", "", "6+", O.exp], ["Flatten", "", "1+", _.flatten, _.parseFlattenAttributes], ["Floor", "", "6+", O.floor], ["FusedConv", "com.microsoft", "1+", u.conv, u.parseConvAttributes], ["Gather", "", "1+", h.gather, h.parseGatherAttributes], ["Gemm", "", "7-10", f.gemm, f.parseGemmAttributesV7], ["Gemm", "", "11+", f.gemm, f.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", x.globalAveragePool, x.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", x.globalMaxPool], ["Greater", "", "7+", a.greater], ["Identity", "", "1+", O.identity], ["ImageScaler", "", "1+", m.imageScaler, m.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", g.instanceNormalization, g.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", O.leakyRelu, O.parseLeakyReluAttributes], ["Less", "", "7+", a.less], ["Log", "", "6+", O.log], ["MatMul", "", "1+", b.matMul, b.parseMatMulAttributes], ["MaxPool", "", "1+", x.maxPool, x.parseMaxPoolAttributes], ["Mul", "", "7+", a.mul], ["Neg", "", "6+", O.neg], ["Not", "", "1+", O.not], ["Or", "", "7+", a.or], ["Pad", "", "2-10", w.padV2, w.parsePadAttributesV2], ["Pad", "", "11+", w.padV11, w.parsePadAttributesV11], ["Pow", "", "7+", a.pow], ["PRelu", "", "7+", a.pRelu], ["ReduceLogSum", "", "1+", y.reduceLogSum, y.parseReduceAttributes], ["ReduceMax", "", "1+", y.reduceMax, y.parseReduceAttributes], ["ReduceMean", "", "1+", y.reduceMean, y.parseReduceAttributes], ["ReduceMin", "", "1+", y.reduceMin, y.parseReduceAttributes], ["ReduceProd", "", "1+", y.reduceProd, y.parseReduceAttributes], ["ReduceSum", "", "1-12", y.reduceSum, y.parseReduceAttributes], ["ReduceSumSquare", "", "1+", y.reduceLogSumSquare, y.parseReduceAttributes], ["Relu", "", "6+", O.relu], ["Reshape", "", "5+", T.reshape], ["Resize", "", "10", v.resize, v.parseResizeAttributesV10], ["Resize", "", "11+", v.resize, v.parseResizeAttributesV11], ["Shape", "", "1+", k.shape], ["Sigmoid", "", "6+", O.sigmoid], ["Sin", "", "7+", O.sin], ["Slice", "", "10+", M.sliceV10], ["Slice", "", "1-9", M.slice, M.parseSliceAttributes], ["Softmax", "", "1-12", S.softmax, S.parseSoftmaxAttributes], ["Softmax", "", "13+", S.softmaxV13, S.parseSoftmaxAttributesV13], ["Split", "", "2-12", P.split, P.parseSplitAttributes], ["Sqrt", "", "6+", O.sqrt], ["Squeeze", "", "1-12", A.squeeze, A.parseSqueezeAttributes], ["Squeeze", "", "13+", A.squeezeV13], ["Sub", "", "7+", a.sub], ["Sum", "", "6+", F.sum], ["Tan", "", "7+", O.tan], ["Tanh", "", "6+", O.tanh], ["Tile", "", "6+", C.tile], ["Transpose", "", "1+", E.transpose, E.parseTransposeAttributes], ["Upsample", "", "7-8", D.upsample, D.parseUpsampleAttributesV7], ["Upsample", "", "9", D.upsample, D.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", I.unsqueeze, I.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", I.unsqueezeV13], ["Xor", "", "7+", a.xor]];
        }, 2898: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseBatchNormalizationAttributes = t.batchNormalization = void 0;
          const r = n(246), o = n(5060), i = n(2039), s = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] };
          t.batchNormalization = (e3, t2, n2) => (l(t2), [e3.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => a(e3, t2, n2) }), t2)]), t.parseBatchNormalizationAttributes = (e3) => {
            const t2 = e3.attributes.getFloat("epsilon", 1e-5), n2 = e3.attributes.getFloat("momentum", 0.9), o2 = e3.attributes.getInt("spatial", 1);
            return (0, r.createAttributeWithCacheKey)({ epsilon: t2, momentum: n2, spatial: o2 });
          };
          const a = (e3, t2, n2) => {
            const r2 = (0, o.getGlsl)(e3.session.backend.glContext.version), a2 = t2[0].dims.length, [l2, c] = e3.calculateTextureWidthAndHeight(t2[1].dims, i.TextureType.unpacked), u = `
  float process(int[${a2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${l2}, ${c});
    float scale = getColorAsFloat(${r2.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r2.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r2.texture2D}(Variance, position));
    float b = getColorAsFloat(${r2.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n2.epsilon})) ) + b;
  }`;
            return Object.assign(Object.assign({}, s), { output: { dims: t2[0].dims, type: t2[0].type, textureType: i.TextureType.unpacked }, shaderSource: u });
          }, l = (e3) => {
            if (!e3 || 5 !== e3.length) throw new Error("BatchNormalization requires 5 inputs.");
            const t2 = e3[0], n2 = e3[1], r2 = e3[2], o2 = e3[3], i2 = e3[4];
            if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length || 1 !== o2.dims.length || 1 !== i2.dims.length) throw new Error("invalid input shape.");
            if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1] || o2.dims[0] !== t2.dims[1] || i2.dims[0] !== t2.dims[1]) throw new Error("invalid input shape.");
            if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type || "float32" !== o2.type && "float64" !== o2.type || "float32" !== i2.type && "float64" !== i2.type) throw new Error("invalid input tensor types.");
          };
        }, 7839: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.xor = t.sub = t.pRelu = t.pow = t.or = t.mul = t.less = t.greater = t.equal = t.div = t.and = t.add = t.glslPRelu = t.glslPow = t.glslXor = t.glslOr = t.glslAnd = t.glslLess = t.glslGreater = t.glslEqual = t.glslSub = t.glslMul = t.glslDiv = t.glslAdd = void 0;
          const r = n(2517), o = n(8520), i = n(5060), s = n(2039);
          function a() {
            const e3 = "add_";
            return { body: `
  float ${e3}(float a, float b) {
    return a + b;
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function l() {
            const e3 = "div_";
            return { body: `
  float ${e3}(float a, float b) {
    return a / b;
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function c() {
            const e3 = "mul_";
            return { body: `
  float ${e3}(float a, float b) {
    return a * b;
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function u() {
            const e3 = "sub_";
            return { body: `
  float ${e3}(float a, float b) {
    return a - b;
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function p() {
            const e3 = "equal_";
            return { body: `
  float ${e3}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function d() {
            const e3 = "greater_";
            return { body: `
  float ${e3}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function _() {
            const e3 = "less_";
            return { body: `
  float ${e3}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function h() {
            const e3 = "and_";
            return { body: `
  float ${e3}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function f() {
            const e3 = "or_";
            return { body: `
  float ${e3}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function m() {
            const e3 = "xor_";
            return { body: `
  float ${e3}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          function g() {
            return (function(e3) {
              const t2 = `${e3}_`;
              return { body: `
  float ${t2}(float a, float b) {
    return ${e3}(a, b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return ${e3}(v1, v2);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
            })("pow");
          }
          function b() {
            const e3 = "prelu_";
            return { body: `
  float ${e3}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: e3, type: o.FunctionType.ValueBased };
          }
          t.glslAdd = a, t.glslDiv = l, t.glslMul = c, t.glslSub = u, t.glslEqual = p, t.glslGreater = d, t.glslLess = _, t.glslAnd = h, t.glslOr = f, t.glslXor = m, t.glslPow = g, t.glslPRelu = b;
          const w = (e3, t2, n2, r2 = t2[0].type, o2) => {
            const i2 = e3.session.pack ? s.TextureType.packed : s.TextureType.unpacked;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [i2, i2], cacheHint: o2, get: () => x(e3, t2, n2, r2) };
          }, x = (e3, t2, n2, o2 = t2[0].type) => {
            const a2 = e3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, l2 = !r.ShapeUtil.areEqual(t2[0].dims, t2[1].dims);
            let c2 = t2[0].dims;
            const u2 = e3.session.pack;
            if (l2) {
              const s2 = r.BroadcastUtil.calcShape(t2[0].dims, t2[1].dims, false);
              if (!s2) throw new Error("Can't perform binary op on the given tensors");
              c2 = s2;
              const l3 = c2.length, p3 = 0 !== t2[0].dims.length ? t2[0].dims.length : 1, d3 = 0 !== t2[1].dims.length ? t2[1].dims.length : 1, _2 = 0 !== t2[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h2 = 0 !== t2[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", f2 = (0, i.getGlsl)(e3.session.backend.glContext.version), m2 = u2 ? `
      ${n2.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n2.name}(a, b);
        ${f2.output} = result;
      }` : `
      ${n2.body}
      float process(int indices[${l3}]) {
        int aindices[${p3}];
        int bindices[${d3}];
        ${_2}
        ${h2}
        return ${n2.name}(_A(aindices), _B(bindices));
      }`;
              return { name: n2.name, inputNames: ["A", "B"], inputTypes: [a2, a2], output: { dims: c2, type: o2, textureType: a2 }, shaderSource: m2, hasMain: u2 };
            }
            const p2 = (0, i.getGlsl)(e3.session.backend.glContext.version), d2 = `
    ${n2.body}
    void main() {
      vec4 v1 = ${p2.texture2D}(A, TexCoords);
      vec4 v2 = ${p2.texture2D}(B, TexCoords);
      vec4 result = ${n2.name}(v1, v2);
      ${p2.output} = result;
    }
    `;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [a2, a2], output: { dims: t2[0].dims, type: o2, textureType: a2 }, shaderSource: d2, hasMain: true };
          };
          t.add = (e3, t2) => [e3.run(w(e3, t2, a()), t2)], t.and = (e3, t2) => [e3.run(w(e3, t2, h(), "bool"), t2)], t.div = (e3, t2) => [e3.run(w(e3, t2, l()), t2)], t.equal = (e3, t2) => [e3.run(w(e3, t2, p(), "bool"), t2)], t.greater = (e3, t2) => [e3.run(w(e3, t2, d(), "bool"), t2)], t.less = (e3, t2) => [e3.run(w(e3, t2, _(), "bool"), t2)], t.mul = (e3, t2) => [e3.run(w(e3, t2, c()), t2)], t.or = (e3, t2) => [e3.run(w(e3, t2, f(), "bool"), t2)], t.pow = (e3, t2) => [e3.run(w(e3, t2, g()), t2)], t.pRelu = (e3, t2) => [e3.run(w(e3, t2, b()), t2)], t.sub = (e3, t2) => [e3.run(w(e3, t2, u()), t2)], t.xor = (e3, t2) => [e3.run(w(e3, t2, m(), "bool"), t2)];
        }, 4196: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseCastAttributes = t.cast = void 0;
          const r = n(2517);
          t.cast = (e3, t2, n2) => (o(t2), [e3.cast(t2[0], n2)]), t.parseCastAttributes = (e3) => r.ProtoUtil.tensorDataTypeFromProto(e3.attributes.getInt("to"));
          const o = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Cast requires 1 input.");
            if ("string" === e3[0].type) throw new Error("Invalid input type.");
          };
        }, 1163: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createPackedConcatProgramInfoLoader = void 0;
          const r = n(5060), o = n(2039), i = n(9390), s = n(2827);
          t.createPackedConcatProgramInfoLoader = (e3, t2, n2) => {
            const l = (c = t2.length, u = n2.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: c }, ((e4, t3) => `X${t3}`)), inputTypes: Array(c).fill(o.TextureType.packed), cacheHint: u });
            var c, u;
            return Object.assign(Object.assign({}, l), { get: () => ((e4, t3, n3, l2) => {
              const c2 = n3[0].dims.slice();
              if (l2 >= c2.length || l2 < -1 * c2.length) throw new Error("axis specified for concat doesn't match input dimensionality");
              l2 < 0 && (l2 = c2.length + l2);
              const u2 = c2.slice(0);
              for (let e5 = 1; e5 < n3.length; e5++) {
                const t4 = n3[e5].dims.slice();
                for (let e6 = 0; e6 < c2.length; e6++) if (e6 === l2) u2[l2] += t4[e6];
                else if (c2[e6] !== t4[e6]) throw new Error("non concat dimensions must match");
              }
              const p = u2.length, d = (0, s.getChannels)("coords", p), _ = (0, i.getCoordsDataType)(p), h = (0, s.unpackFromChannel)(), f = n3.map(((e5) => e5.dims)), m = (0, i.getGlChannels)(p), g = new Array(f.length - 1);
              g[0] = f[0][l2];
              for (let e5 = 1; e5 < g.length; e5++) g[e5] = g[e5 - 1] + f[e5][l2];
              const b = m[l2], w = m.slice(-2), x = m.join();
              let y = `if (${b} < ${g[0]}) {
        return getChannel(
            getX0(${x}), vec2(${w.join()}));
        }`;
              for (let e5 = 1; e5 < g.length; e5++) {
                const t4 = g[e5 - 1];
                y += `
            if (${b} < ${g[e5]}  && ${b} >= ${g[e5 - 1]}) {
              return getChannel(
                getX${e5}(${a(m, b, t4)}),
                vec2(${a(w, b, t4)}));
            }`;
              }
              const T = g.length, v = g[g.length - 1];
              y += `
            return getChannel(
              getX${T}(${a(m, b, v)}),
              vec2(${a(w, b, v)}));`;
              const k = (0, r.getGlsl)(e4.session.backend.glContext.version), M = `
          ${h}
          float getValue(${m.map(((e5) => "int " + e5))}) {
            ${y}
          }

          void main() {
            ${_} coords = getOutputCoords();
            int lastDim = coords.${m[p - 1]};
            coords.${m[p - 1]} = coords.${m[p - 2]};
            coords.${m[p - 2]} = lastDim;

            vec4 result = vec4(getValue(${d}), 0., 0., 0.);

            ${d[p - 1]} = ${d[p - 1]} + 1;
            if (${d[p - 1]} < ${u2[p - 1]}) {
              result.g = getValue(${d});
            }

            ${d[p - 2]} = ${d[p - 2]} + 1;
            if (${d[p - 2]} < ${u2[p - 2]}) {
              result.a = getValue(${d});
            }

            ${d[p - 1]} = ${d[p - 1]} - 1;
            if (${d[p - 2]} < ${u2[p - 2]} &&
                ${d[p - 1]} < ${u2[p - 1]}) {
              result.b = getValue(${d});
            }
            ${k.output} = result;
          }
        `;
              return Object.assign(Object.assign({}, t3), { output: { dims: u2, type: n3[0].type, textureType: o.TextureType.packed }, shaderSource: M, hasMain: true });
            })(e3, l, t2, n2.axis) });
          };
          const a = (e3, t2, n2) => {
            const r2 = e3.indexOf(t2);
            return e3.map(((e4, t3) => t3 === r2 ? `${e4} - ${n2}` : e4)).join();
          };
        }, 2069: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseConcatAttributes = t.concat = void 0;
          const r = n(246), o = n(2039), i = n(1163);
          t.concat = (e3, t2, n2) => (p(t2), e3.session.pack && t2[0].dims.length > 1 ? [e3.run((0, i.createPackedConcatProgramInfoLoader)(e3, t2, n2), t2)] : [e3.run(s(e3, t2, n2), t2)]);
          const s = (e3, t2, n2) => {
            const r2 = (i2 = t2.length, s2 = n2.cacheKey, { name: "Concat", inputNames: Array.from({ length: i2 }, ((e4, t3) => `X${t3}`)), inputTypes: Array(i2).fill(o.TextureType.unpacked), cacheHint: s2 });
            var i2, s2;
            return Object.assign(Object.assign({}, r2), { get: () => ((e4, t3, n3, r3) => {
              const i3 = n3[0].dims.slice();
              if (r3 >= i3.length || r3 < -1 * i3.length) throw new Error("axis specified for concat doesn't match input dimensionality");
              r3 < 0 && (r3 = i3.length + r3);
              const s3 = i3.slice(0);
              for (let e5 = 1; e5 < n3.length; e5++) {
                const t4 = n3[e5].dims.slice();
                for (let e6 = 0; e6 < i3.length; e6++) if (e6 === r3) s3[r3] += t4[e6];
                else if (i3[e6] !== t4[e6]) throw new Error("non concat dimensions must match");
              }
              const p2 = s3.length, d = new Array(n3.length);
              let _ = 0;
              for (let e5 = 0; e5 < d.length; ++e5) _ += n3[e5].dims[r3], d[e5] = _;
              let h = "";
              h = n3.length < 5 ? a(d) : l(d);
              const f = `
        ${c(n3.length, p2)}
        ${u(d)}
        ${h}
        float process(int indices[${p2}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r3}]);

          if(textureIndex != 0) {
            indices[${r3}] = indices[${r3}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
              return Object.assign(Object.assign({}, t3), { output: { dims: s3, type: n3[0].type, textureType: o.TextureType.unpacked }, shaderSource: f });
            })(0, r2, t2, n2.axis) });
          }, a = (e3) => `int getTextureWhereDataResides(int index) {
      ${e3.map(((e4, t2) => `if(index<${e4}) {return ${t2};}
`)).join("")}
    }`, l = (e3) => a(e3), c = (e3, t2) => {
            const n2 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t2}]) {`];
            for (let t3 = 0; t3 < e3; ++t3) 0 === t3 ? n2.push(`	if (textureIndex == ${t3}) { return _X${t3}(indices); }`) : t3 === e3 - 1 ? n2.push(`	else { return _X${t3}(indices); }`) : n2.push(`	else if (textureIndex == ${t3}) { return _X${t3}(indices); }`);
            return n2.push("	}"), n2.join("\n");
          }, u = (e3) => {
            const t2 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
            for (let n2 = 0; n2 < e3.length; ++n2) 0 === n2 ? t2.push(`	if (index == ${n2}) { return ${e3[n2]}; }`) : n2 === e3.length - 1 ? t2.push(`	else { return ${e3[n2]}; }`) : t2.push(`	else if (index == ${n2}) { return ${e3[n2]}; }`);
            return t2.push("	}"), t2.join("\n");
          };
          t.parseConcatAttributes = (e3) => (0, r.createAttributeWithCacheKey)({ axis: e3.attributes.getInt("axis") });
          const p = (e3) => {
            if (!e3 || e3.length < 1) throw new Error("too few inputs");
            const t2 = e3[0].type, n2 = e3[0].dims.length;
            if ("string" === t2) throw new Error("string tensor is not supported yet");
            for (const r2 of e3) {
              if (r2.type !== t2) throw new Error("input tensors should be one type");
              if (r2.dims.length !== n2) throw new Error("input tensors should have the same shape");
            }
          };
        }, 4770: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackedGroupedConvProgramInfoLoader = void 0;
          const r = n(6231), o = n(5060), i = n(2039), s = n(8138), a = n(2823);
          t.createUnpackedGroupedConvProgramInfoLoader = (e3, t2, n2) => {
            const l = (c = t2.length > 2, u = n2.cacheKey, { name: "GroupedConv", inputNames: c ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: c ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: u });
            var c, u;
            return Object.assign(Object.assign({}, l), { get: () => ((e4, t3, n3, l2) => {
              const c2 = t3.length > 2 ? "value += getBias(output_channel);" : "", u2 = t3[0].dims.slice(), p = t3[1].dims.slice(), d = p[0] / l2.group;
              r.Logger.verbose("GroupedConv", `autpPad:${l2.autoPad}, dilations:${l2.dilations}, group:${l2.group}, kernelShape:${l2.kernelShape}, pads:${l2.pads}, strides:${l2.strides}`);
              const _ = (0, s.calculateOutputShape)(u2, p, l2.dilations, l2.pads, l2.strides), h = (0, o.getGlsl)(e4.session.backend.glContext.version), { activationFunction: f, applyActivation: m } = (0, a.getActivationSnippet)(l2), g = `
  const ivec2 strides = ivec2(${l2.strides[0]}, ${l2.strides[1]});
  const ivec2 pads = ivec2(${l2.pads[0]}, ${l2.pads[1]});
  ${f}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${d};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${l2.dilations[0]};

        if (xHeight < 0 || xHeight >= ${u2[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${l2.dilations[1]};
          if (xWidth < 0 || xWidth >= ${u2[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${c2}
    ${m}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
              return Object.assign(Object.assign({}, n3), { output: { dims: _, type: t3[0].type, textureType: i.TextureType.unpacked }, shaderSource: g, hasMain: true });
            })(e3, t2, l, n2) });
          };
        }, 1386: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.conv2DPacked = t.conv2DPackedPointwise = void 0;
          const r = n(8138), o = n(8555), i = n(708);
          t.conv2DPackedPointwise = (e3, t2, n2) => {
            const o2 = t2[0].dims, s = t2[1].dims, a = (0, r.calculateOutputShape)(o2, s, n2.dilations, n2.pads, n2.strides), l = e3.reshapePacked(t2[0], [o2[1], o2[2] * o2[3]]), c = e3.reshapePacked(t2[1], [s[0], s[1]]), u = t2.length > 2 ? [c, l, t2[2]] : [c, l], p = e3.run((0, i.createPackedMatmulProgramInfoLoader)(e3, u, n2), u);
            return e3.reshapePacked(p, a);
          }, t.conv2DPacked = (e3, t2, n2) => {
            const s = t2[0].dims, a = t2[1].dims, l = (0, r.calculateOutputShape)(s, a, n2.dilations, n2.pads, n2.strides), c = e3.run((0, o.createPackedIm2ColProgramInfoLoader)(e3, t2[0], t2[1], l, n2), [t2[0]]), u = e3.reshapePacked(t2[1], [a[0], a[1] * a[2] * a[3]]), p = 3 === t2.length ? [u, c, t2[2]] : [u, c], d = e3.run((0, i.createPackedMatmulProgramInfoLoader)(e3, p, n2), p);
            return e3.reshapePacked(d, l);
          };
        }, 9663: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseConvTransposeAttributes = t.convTranspose = void 0;
          const r = n(246), o = n(5060), i = n(2039), s = n(2823), a = (e3, t2, n2, r2, o2, i2) => (e3 - 1) * t2 + n2 + (r2 - 1) * o2 + 1 - i2, l = (e3, t2, n2, r2, o2) => {
            const i2 = Math.floor(e3 / 2);
            "SAME_UPPER" === t2 ? (n2[r2] = i2, n2[o2] = e3 - i2) : "SAME_LOWER" === t2 && (n2[r2] = e3 - i2, n2[o2] = i2);
          };
          t.convTranspose = (e3, t2, n2) => (d(t2, n2), c(e3, t2, n2));
          const c = (e3, t2, n2) => {
            const r2 = p(n2, t2);
            return [u(e3, t2, r2)];
          }, u = (e3, t2, n2) => e3.run(((e4, t3, n3) => {
            const r2 = (a2 = t3.length > 2, l2 = n3.cacheKey, { name: "ConvTranspose", inputNames: a2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: a2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: l2 });
            var a2, l2;
            return Object.assign(Object.assign({}, r2), { get: () => ((e5, t4, n4, r3) => {
              const a3 = t4.length > 2 ? "getB(output_channel)" : "0.0", l3 = t4[0].dims, c2 = t4[1].dims, u2 = c2[1], p2 = c2[0] / r3.group, d2 = [t4[0].dims[0], t4[1].dims[1] * r3.group, ...r3.outputShape], _ = (0, o.getGlsl)(e5.session.backend.glContext.version), { activationFunction: h, applyActivation: f } = (0, s.getActivationSnippet)(r3), m = `
  const ivec2 strides = ivec2(${r3.strides[0]}, ${r3.strides[1]});
  const ivec2 pads = ivec2(${r3.pads[0]}, ${r3.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${u2};
    int wOutChannel = output_channel - group_id * ${u2};

    float value = ${a3};
    for (int inChannelOffset = 0; inChannelOffset < ${p2}; inChannelOffset++) {
      int input_channel = group_id * ${p2} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c2[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c2[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r3.dilations[0]}, wHOff * ${r3.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${l3[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${l3[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${f}
    ${_.output} = vec4(value, .0, .0, .0);
  }
`;
              return Object.assign(Object.assign({}, n4), { output: { dims: d2, type: t4[0].type, textureType: i.TextureType.unpacked }, shaderSource: m, hasMain: true });
            })(e4, t3, r2, n3) });
          })(e3, t2, n2), t2), p = (e3, t2) => {
            const n2 = e3.kernelShape.slice();
            if (0 === e3.kernelShape.length) for (let e4 = 2; e4 < t2[1].dims.length; ++e4) n2.push(t2[1].dims[e4]);
            const r2 = e3.pads.slice(), o2 = e3.outputShape.slice();
            ((e4, t3, n3, r3, o3, i3, s2, c2) => {
              const u2 = e4.length - 2, p2 = 0 === c2.length;
              for (let d2 = 0; d2 < u2; ++d2) {
                const _ = p2 ? e4[d2 + 2] * i3[d2] : c2[d2], h = a(e4[d2 + 2], i3[d2], o3[d2], t3[d2], n3[d2], _);
                l(h, r3, o3, d2, d2 + u2), p2 && c2.push(i3[d2] * (e4[d2 + 2] - 1) + s2[d2] + (t3[d2] - 1) * n3[d2] + 1 - o3[d2] - o3[d2 + u2]);
              }
            })(t2[0].dims, n2, e3.dilations, e3.autoPad, r2, e3.strides, e3.outputPadding, o2);
            const i2 = Object.assign({}, e3);
            return Object.assign(i2, { kernelShape: n2, pads: r2, outputShape: o2, cacheKey: e3.cacheKey }), i2;
          };
          t.parseConvTransposeAttributes = (e3) => {
            const t2 = e3.attributes, n2 = (0, s.parseInternalActivationAttributes)(t2), o2 = t2.getString("auto_pad", "NOTSET"), i2 = t2.getInts("dilations", [1, 1]), a2 = t2.getInt("group", 1), l2 = t2.getInts("kernel_shape", []), c2 = t2.getInts("output_padding", [0, 0]), u2 = t2.getInts("output_shape", []), p2 = t2.getInts("pads", [0, 0, 0, 0]), d2 = t2.getInts("strides", [1, 1]);
            return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: o2, dilations: i2, group: a2, kernelShape: l2, outputPadding: c2, outputShape: u2, pads: p2, strides: d2 }, n2));
          };
          const d = (e3, t2) => {
            if (!e3 || 2 !== e3.length && 3 !== e3.length) throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== e3[0].dims.length || 4 !== e3[1].dims.length) throw new Error("currently only support 2-dimensional conv");
            if (e3[0].dims[1] !== e3[1].dims[0]) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            const n2 = e3[1].dims[1] * t2.group;
            if (3 === e3.length && (1 !== e3[2].dims.length || e3[2].dims[0] !== n2)) throw new Error("invalid bias");
            const r2 = e3[0].dims.length - 2;
            if (t2.dilations.length !== r2) throw new Error(`dilations should be ${r2}D`);
            if (t2.strides.length !== r2) throw new Error(`strides should be ${r2}D`);
            if (t2.pads.length !== 2 * r2) throw new Error(`pads should be ${2 * r2}D`);
            if (t2.outputPadding.length !== r2) throw new Error(`output_padding should be ${r2}D`);
            if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e3[1].dims.length - 2) throw new Error("invalid kernel shape");
            if (0 !== t2.outputShape.length && t2.outputShape.length !== e3[0].dims.length - 2) throw new Error("invalid output shape");
            if ("float32" !== e3[0].type || "float32" !== e3[1].type) throw new Error("ConvTranspose input(X,W) should be float tensor");
            if (3 === e3.length && "float32" !== e3[2].type) throw new Error("ConvTranspose input(bias) should be float tensor");
          };
        }, 8138: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseConvAttributes = t.conv = t.calculateOutputShape = void 0;
          const r = n(246), o = n(2517), i = n(4770), s = n(1386), a = n(9828), l = n(2823), c = n(3248), u = n(5623);
          t.calculateOutputShape = (e3, t2, n2, r2, o2) => {
            const i2 = e3[0], s2 = e3.slice(2), a2 = s2.length, l2 = t2[0], c2 = t2.slice(2).map(((e4, t3) => e4 + (e4 - 1) * (n2[t3] - 1))), u2 = s2.map(((e4, t3) => e4 + r2[t3] + r2[t3 + a2])).map(((e4, t3) => Math.floor((e4 - c2[t3] + o2[t3]) / o2[t3])));
            return [i2, l2].concat(...u2);
          }, t.conv = (e3, t2, n2) => (f(t2, n2), p(e3, t2, n2));
          const p = (e3, t2, n2) => {
            const r2 = h(n2, t2), o2 = e3.session.pack, a2 = 1 === r2.kernelShape[0] && 1 === r2.kernelShape[1];
            return r2.group > 1 ? [e3.run((0, i.createUnpackedGroupedConvProgramInfoLoader)(e3, t2, r2), t2)] : a2 && o2 ? [d(e3, t2, r2)] : o2 && 4 === t2[0].dims.length && 1 === t2[0].dims[0] && !a2 ? [(0, s.conv2DPacked)(e3, t2, r2)] : [_(e3, t2, r2)];
          }, d = (e3, n2, r2) => {
            const o2 = n2[0].dims, i2 = n2[1].dims, s2 = (0, t.calculateOutputShape)(o2, i2, r2.dilations, r2.pads, r2.strides), a2 = e3.reshapeUnpacked(n2[0], [o2[1], o2[2] * o2[3]]), l2 = e3.reshapeUnpacked(n2[1], [i2[0], i2[1]]), c2 = n2.length > 2 ? [l2, a2, n2[2]] : [l2, a2], p2 = e3.run((0, u.createMatmulProgramInfoLoader)(c2, r2), c2);
            return e3.reshapeUnpacked(p2, s2);
          }, _ = (e3, n2, r2) => {
            const o2 = n2[0].dims, i2 = n2[1].dims, s2 = (0, t.calculateOutputShape)(o2, i2, r2.dilations, r2.pads, r2.strides), l2 = e3.run((0, c.createIm2ColProgramInfoLoader)(e3, n2[0], n2[1], s2, r2), [n2[0]]), u2 = 3 === n2.length ? [l2, n2[1], n2[2]] : [l2, n2[1]];
            return e3.run((0, a.createDotProductProgramInfoLoader)(e3, n2, s2, r2), u2);
          }, h = (e3, t2) => {
            const n2 = e3.kernelShape.slice();
            if (0 === e3.kernelShape.length) for (let e4 = 2; e4 < t2[1].dims.length; ++e4) n2.push(t2[1].dims[e4]);
            const r2 = e3.pads.slice();
            o.PoolConvUtil.adjustPadsBasedOnAutoPad(t2[0].dims, e3.strides, e3.dilations, n2, r2, e3.autoPad);
            const i2 = Object.assign({}, e3);
            return Object.assign(i2, { kernelShape: n2, pads: r2, cacheKey: e3.cacheKey }), i2;
          };
          t.parseConvAttributes = (e3) => {
            const t2 = e3.attributes, n2 = (0, l.parseInternalActivationAttributes)(t2), o2 = t2.getString("auto_pad", "NOTSET"), i2 = t2.getInts("dilations", [1, 1]), s2 = t2.getInt("group", 1), a2 = t2.getInts("kernel_shape", []), c2 = t2.getInts("pads", [0, 0, 0, 0]), u2 = t2.getInts("strides", [1, 1]);
            return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: o2, dilations: i2, group: s2, kernelShape: a2, pads: c2, strides: u2 }, n2));
          };
          const f = (e3, t2) => {
            if (!e3 || 2 !== e3.length && 3 !== e3.length) throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== e3[0].dims.length || 4 !== e3[1].dims.length) throw new Error("currently only support 2-dimensional conv");
            if (e3[0].dims[1] !== e3[1].dims[1] * t2.group) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            if (3 === e3.length && (1 !== e3[2].dims.length || e3[1].dims[0] !== e3[2].dims[0])) throw new Error("invalid bias");
            const n2 = e3[0].dims.length - 2;
            if (t2.dilations.length !== n2) throw new Error(`dilations should be ${n2}D`);
            if (t2.strides.length !== n2) throw new Error(`strides should be ${n2}D`);
            if (t2.pads.length !== 2 * n2) throw new Error(`pads should be ${2 * n2}D`);
            if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e3[1].dims.length - 2) throw new Error("invalid kernel shape");
            if ("float32" !== e3[0].type || "float32" !== e3[1].type) throw new Error("Conv input(X,W) should be float tensor");
            if (3 === e3.length && "float32" !== e3[2].type) throw new Error("Conv input(bias) should be float tensor");
          };
        }, 5193: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseDepthToSpaceAttributes = t.depthToSpace = void 0;
          const r = n(3738);
          t.depthToSpace = (e3, t2, n2) => {
            o(t2);
            const i = n2.blocksize, s = i * i, a = "DCR" === n2.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], l = "DCR" === n2.mode ? [t2[0].dims[0], i, i, t2[0].dims[1] / s, t2[0].dims[2], t2[0].dims[3]] : [t2[0].dims[0], t2[0].dims[1] / s, i, i, t2[0].dims[2], t2[0].dims[3]], c = e3.reshapeUnpacked(t2[0], l), u = { perm: a, cacheKey: `${a}` }, [p] = (0, r.transpose)(e3, [c], u), d = [t2[0].dims[0], t2[0].dims[1] / s, t2[0].dims[2] * i, t2[0].dims[3] * i];
            return [e3.reshapeUnpacked(p, d)];
          }, t.parseDepthToSpaceAttributes = (e3) => {
            const t2 = e3.attributes.getInt("blocksize");
            if (t2 < 1) throw new Error(`blocksize must be >= 1, but got : ${t2} for DepthToSpace`);
            const n2 = e3.attributes.getString("mode", "DCR");
            if ("DCR" !== n2 && "CRD" !== n2) throw new Error(`unrecognized mode: ${n2} for DepthToSpace`);
            return { mode: n2, blocksize: t2 };
          };
          const o = (e3) => {
            if (1 !== e3.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${e3.length}`);
            if ("string" === e3[0].type || 4 !== e3[0].dims.length) throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
          };
        }, 9828: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createDotProductProgramInfoLoader = void 0;
          const r = n(2517), o = n(5060), i = n(2039), s = n(2823), a = n(3248);
          t.createDotProductProgramInfoLoader = (e3, t2, n2, l) => {
            const c = ((e4, t3) => ({ name: "ConvDotProduct", inputNames: e4 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: e4 ? [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.packedLastDimension], cacheKey: t3.activationCacheKey }))(t2.length > 2, l);
            return Object.assign(Object.assign({}, c), { get: () => ((e4, t3, n3, l2, c2) => {
              const u = n3[0].dims, p = n3[1].dims, d = [p[0], Math.ceil(u[1] * p[2] * p[3] / 4)], _ = (0, a.calculateIm2ColDims)(u, p, l2), [h, f] = e4.calculateTextureWidthAndHeight(d, i.TextureType.packedLastDimension), m = r.ShapeUtil.computeStrides(_), [g, b] = e4.calculateTextureWidthAndHeight(_, i.TextureType.packedLastDimension), w = l2.length, x = n3.length < 3 ? "0.0" : "_B(b)", y = Math.ceil(u[1] * p[2] * p[3] / 4), { activationFunction: T, applyActivation: v } = (0, s.getActivationSnippet)(c2), k = (0, o.getGlsl)(e4.session.backend.glContext.version), M = `
${T}
float process(int indices[${w}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${m[0]} + im2col[1] * ${m[1]} + im2col[2] * ${m[2]};
  int kernelOffset = indices[1] * ${d[1]};
  float value = ${x};
  for (int i = 0; i < ${y}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${g}, ${b});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${f});
    value += dot(${k.texture2D}(Im2Col, im2colCoords), ${k.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${v}
  return value;
}`;
              return Object.assign(Object.assign({}, t3), { output: { dims: l2, type: n3[0].type, textureType: i.TextureType.unpacked }, shaderSource: M });
            })(e3, c, t2, n2, l) });
          };
        }, 7992: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseFlattenAttributes = t.flatten = void 0;
          const r = n(2517);
          t.flatten = (e3, t2, n2) => {
            o(t2, n2);
            const i = r.ShapeUtil.flattenShape(t2[0].dims, n2);
            return [e3.reshapeUnpacked(t2[0], i)];
          }, t.parseFlattenAttributes = (e3) => e3.attributes.getInt("axis", 1);
          const o = (e3, t2) => {
            if (!e3 || 1 !== e3.length) throw new Error("Flatten requires 1 input.");
            const n2 = e3[0].dims.length;
            if (0 === n2) throw new Error("scalar tensor is not supported.");
            if (t2 < -n2 || t2 > n2) throw new Error("Invalid axis");
            if ("string" === e3[0].type) throw new Error("string tensor is not supported.");
          };
        }, 2823: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseInternalActivationAttributes = t.getActivationSnippet = void 0;
          const r = n(2517), o = n(4909);
          t.getActivationSnippet = function(e3) {
            let t2;
            switch (e3.activation) {
              case "Relu":
                t2 = (0, o.glslRelu)();
                break;
              case "Sigmoid":
                t2 = (0, o.glslSigmoid)();
                break;
              case "Clip":
                t2 = (0, o.glslClip)(e3.clipMin, e3.clipMax);
                break;
              default:
                return { activationFunction: "", applyActivation: "" };
            }
            const n2 = t2.name;
            return { activationFunction: t2.body, applyActivation: `value = ${n2}_(value);` };
          }, t.parseInternalActivationAttributes = (e3) => {
            const t2 = e3.getString("activation", "");
            if ("Clip" === t2) {
              const [n2, o2] = e3.getFloats("activation_params", [r.MIN_CLIP, r.MAX_CLIP]);
              return { activation: t2, clipMax: o2, clipMin: n2, activationCacheKey: `${t2}:${n2},${o2}` };
            }
            return { activation: t2, activationCacheKey: t2 };
          };
        }, 1253: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseGatherAttributes = t.gather = void 0;
          const r = n(246), o = n(782), i = n(2517), s = n(2039);
          t.gather = (e3, t2, n2) => (c(t2, n2.axis), [e3.run(l(e3, t2, n2), t2)]), t.parseGatherAttributes = (e3) => (0, r.createAttributeWithCacheKey)({ axis: e3.attributes.getInt("axis", 0) });
          const a = { name: "Gather", inputNames: ["A", "B"], inputTypes: [s.TextureType.unpacked, s.TextureType.unpacked] }, l = (e3, t2, n2) => {
            const r2 = Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey });
            return Object.assign(Object.assign({}, r2), { get: () => ((e4, t3, n3, r3) => {
              const o2 = n3[0].dims.slice(), a2 = n3[1].dims.slice(), l2 = new Array(o2.length + a2.length - 1);
              r3 = i.ShapeUtil.normalizeAxis(r3, o2.length);
              const c2 = [];
              for (let e5 = 0; e5 < l2.length; e5++) e5 < r3 ? (l2[e5] = o2[e5], c2.push(`inputIdx[${e5}] = outputIdx[${e5}];`)) : e5 < r3 + a2.length ? (l2[e5] = a2[e5 - r3], c2.push(`indexDataIdx[${e5 - r3}] = outputIdx[${e5}];`)) : (l2[e5] = o2[e5 - a2.length + 1], c2.push(`inputIdx[${e5 - a2.length + 1}] = outputIdx[${e5}];`));
              const u = `
      float process(int outputIdx[${l2.length || 1}]) {
        int inputIdx[${o2.length}];
        int indexDataIdx[${a2.length || 1}];
        indexDataIdx[0] = 0;
        ${c2.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r3}] = idx < 0 ? idx + ${o2[r3]} : idx;
        return _A(inputIdx);
      }`;
              return Object.assign(Object.assign({}, t3), { output: { dims: l2, type: n3[0].type, textureType: s.TextureType.unpacked }, shaderSource: u });
            })(0, r2, t2, n2.axis) });
          }, c = (e3, t2) => {
            if (!e3 || 2 !== e3.length) throw new Error("Gather requires 2 inputs.");
            const n2 = e3[0].dims.length;
            if (n2 < 1) throw new Error("Invalid input shape.");
            if (t2 < -n2 || t2 > n2 - 1) throw new Error("Invalid axis.");
            if (-1 === o.NUMBER_TYPES.indexOf(e3[0].type)) throw new Error("Invaid input type.");
            if ("int32" !== e3[1].type && "int16" !== e3[1].type) throw new Error("Invaid input type.");
          };
        }, 4776: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseGemmAttributesV11 = t.parseGemmAttributesV7 = t.gemm = void 0;
          const r = n(246), o = n(2517), i = n(2039);
          t.gemm = (e3, t2, n2) => (c(t2, n2), [e3.run(a(t2, n2), t2)]);
          const s = (e3, t2) => {
            const n2 = 0 !== e3.attributes.getInt("transA", 0), o2 = 0 !== e3.attributes.getInt("transB", 0), i2 = e3.attributes.getFloat("alpha", 1), s2 = e3.attributes.getFloat("beta", 1);
            return (0, r.createAttributeWithCacheKey)({ transA: n2, transB: o2, alpha: i2, beta: s2, isOptionalC: t2 });
          };
          t.parseGemmAttributesV7 = (e3) => s(e3, false), t.parseGemmAttributesV11 = (e3) => s(e3, true);
          const a = (e3, t2) => {
            const n2 = { name: "Gemm", inputNames: 3 === e3.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === e3.length ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], key: t2.cacheKey };
            return Object.assign(Object.assign({}, n2), { get: () => l(n2, e3, t2) });
          }, l = (e3, t2, n2) => {
            const r2 = t2[0].dims.slice(), s2 = t2[1].dims.slice(), [a2, l2] = o.GemmUtil.getShapeOfGemmResult(r2, n2.transA, s2, n2.transB, 3 === t2.length ? t2[2].dims : void 0), c2 = [a2, l2];
            if (!c2) throw new Error("Can't use gemm on the given tensors");
            let u = r2[r2.length - 1], p = "";
            n2.transA && (u = r2[0]), n2.transA && n2.transB ? p = "value += _A_T(a) * _B_T(b);" : n2.transA && !n2.transB ? p = "value += _A_T(a) * _B(b);" : !n2.transA && n2.transB ? p = "value += _A(a) * _B_T(b);" : n2.transA || n2.transB || (p = "value += _A(a) * _B(b);");
            const d = c2.length, _ = `
      float process(int indices[${d}]) {
          int a[${d}];
          int b[${d}];
          ${3 === t2.length ? `int c[${t2[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === t2.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${u}; ++k) {
              a[${d - 1}] = k;
              b[${d - 2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3 === t2.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
            return Object.assign(Object.assign({}, e3), { output: { dims: c2, type: t2[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n2.alpha }, { name: "beta", type: "float", data: n2.beta }], shaderSource: _ });
          }, c = (e3, t2) => {
            if (!e3) throw new Error("Input is missing");
            if (t2.isOptionalC && (e3.length < 2 || e3.length > 3)) throw new Error("Invaid input shape.");
            if (!t2.isOptionalC && 3 !== e3.length) throw new Error("Gemm requires 3 inputs");
            if (3 === e3.length && 1 !== e3[2].dims.length && 2 !== e3[2].dims.length) throw new Error("Invalid input shape of C");
            if ("float32" !== e3[0].type && "float64" !== e3[0].type || "float32" !== e3[1].type && "float64" !== e3[1].type || 3 === e3.length && "float32" !== e3[2].type && "float64" !== e3[2].type) throw new Error("Invalid input type.");
            if (e3[0].type !== e3[1].type || 3 === e3.length && e3[0].type !== e3[2].type) throw new Error("Input types are mismatched");
          };
        }, 8555: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createPackedIm2ColProgramInfoLoader = void 0;
          const r = n(5060), o = n(2039), i = n(2827);
          t.createPackedIm2ColProgramInfoLoader = (e3, t2, n2, s, a) => {
            const l = (c = a.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [o.TextureType.packed], cacheHint: c });
            var c;
            return Object.assign(Object.assign({}, l), { get: () => ((e4, t3, n3, s2, a2, l2) => {
              const c2 = n3.dims, u = s2.dims, p = a2.length, d = [u[1] * u[2] * u[3], a2[2] * a2[3]], _ = u[2] * u[3], h = (0, i.unpackFromChannel)(), f = (0, r.getGlsl)(e4.session.backend.glContext.version);
              let m = "";
              for (let e5 = 0; e5 <= 1; e5++) for (let t4 = 0; t4 <= 1; t4++) m += `
            blockIndex = rc.x + ${t4};
            pos = rc.y + ${e5};

            if(blockIndex < ${d[1]} && pos < ${d[0]}) {
              offsetY = int(blockIndex / (${a2[p - 1]})) * ${l2.strides[0]} -
                ${l2.pads[0]};
              d0 = offsetY + ${l2.dilations[0]} * (imod(pos, ${_}) / ${u[2]});

              if(d0 < ${c2[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${a2[p - 1]}) * ${l2.strides[1]} -
                  ${l2.pads[1]};
                d1 = offsetX + ${l2.dilations[1]} * imod(imod(pos, ${_}), ${u[2]});

                if(d1 < ${c2[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${_}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * e5 + t4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
              const g = `
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${m}
          ${f.output} = result;
      }
            `;
              return Object.assign(Object.assign({}, t3), { output: { dims: d, type: n3.type, textureType: o.TextureType.packed }, shaderSource: g, hasMain: true });
            })(e3, l, t2, n2, s, a) });
          };
        }, 3248: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.calculateIm2ColDims = t.createIm2ColProgramInfoLoader = void 0;
          const r = n(2039);
          t.createIm2ColProgramInfoLoader = (e3, n2, o, i, s) => {
            const a = (l = s.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r.TextureType.unpacked], cacheHint: l });
            var l;
            return Object.assign(Object.assign({}, a), { get: () => ((e4, n3, o2, i2, s2, a2) => {
              const l2 = o2.dims, c = i2.dims, u = s2.length, p = (0, t.calculateIm2ColDims)(l2, c, s2, 4), d = `
        const int XC = ${l2[1]};
        const int XH = ${l2[2]};
        const int XW = ${l2[3]};
        const int KH = ${a2.kernelShape[0]};
        const int KW = ${a2.kernelShape[1]};
        const int dilationH = ${a2.dilations[0]};
        const int dilationW = ${a2.dilations[1]};
        const int strideH = ${a2.strides[0]};
        const int strideW = ${a2.strides[1]};
        const int padH = ${a2.pads[0]};
        const int padW = ${a2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${u}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${l2.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
              return Object.assign(Object.assign({}, n3), { output: { dims: p, type: o2.type, textureType: r.TextureType.packedLastDimension }, shaderSource: d });
            })(0, a, n2, o, i, s) });
          }, t.calculateIm2ColDims = (e3, t2, n2, r2 = 4) => [n2[0], n2[2], n2[3], Math.ceil(e3[1] * t2[2] * t2[3] / r2)];
        }, 6572: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseImageScalerAttributes = t.imageScaler = void 0;
          const r = n(246), o = n(2039);
          t.imageScaler = (e3, t2, n2) => (l(t2), [e3.run(s(e3, t2, n2), t2)]), t.parseImageScalerAttributes = (e3) => {
            const t2 = e3.attributes.getFloat("scale"), n2 = e3.attributes.getFloats("bias");
            return (0, r.createAttributeWithCacheKey)({ scale: t2, bias: n2 });
          };
          const i = { name: "ImageScaler", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] }, s = (e3, t2, n2) => {
            const r2 = Object.assign(Object.assign({}, i), { cacheHint: n2.cacheKey });
            return Object.assign(Object.assign({}, r2), { get: () => ((e4, t3, n3, r3) => {
              const i2 = n3[0].dims.slice(), s2 = i2.length, l2 = `
      ${a(r3.bias.length)}
      float process(int indices[${s2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
              return Object.assign(Object.assign({}, t3), { output: { dims: i2, type: n3[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r3.bias.length, data: r3.bias }, { name: "scale", type: "float", data: r3.scale }], shaderSource: l2 });
            })(0, r2, t2, n2) });
          }, a = (e3) => {
            const t2 = [`float getBias(float bias[${e3}], int channel) {`];
            for (let n2 = 0; n2 < e3; ++n2) 0 === n2 ? t2.push(`	if (channel == ${n2}) { return bias[${n2}]; }`) : n2 === e3 - 1 ? t2.push(`	else { return bias[${n2}]; }`) : t2.push(`	else if (channel == ${n2}) { return bias[${n2}]; }`);
            return t2.push("	}"), t2.join("\n");
          }, l = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("ImageScaler requires 1 input.");
            if (4 !== e3[0].dims.length) throw new Error("Invalid input shape.");
            if ("float32" !== e3[0].type && "float64" !== e3[0].type) throw new Error("Invalid input type.");
          };
        }, 3346: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseInstanceNormalizationAttributes = t.instanceNormalization = void 0;
          const r = n(5060), o = n(2039);
          t.instanceNormalization = (e3, t2, n2) => {
            c(t2);
            const r2 = e3.run(s(t2[0]), t2);
            return [e3.run(l(e3, t2[0], n2, r2.dims), [t2[0], r2, t2[1], t2[2]])];
          }, t.parseInstanceNormalizationAttributes = (e3) => e3.attributes.getFloat("epsilon", 1e-5);
          const i = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] }, s = (e3) => Object.assign(Object.assign({}, i), { get: () => ((e4, t2) => {
            const n2 = t2.dims.slice(), r2 = n2[1], i2 = n2[2] * n2[3], s2 = [n2[0], r2], a2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i2});
        temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i2});

        return v;
      }`;
            return Object.assign(Object.assign({}, e4), { output: { dims: s2, type: t2.type, textureType: o.TextureType.packedLastDimension }, shaderSource: a2 });
          })(i, e3) }), a = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked, o.TextureType.unpacked] }, l = (e3, t2, n2, i2) => {
            const s2 = Object.assign(Object.assign({}, a), { cacheHint: `${n2}` });
            return Object.assign(Object.assign({}, s2), { get: () => ((e4, t3, n3, i3, s3) => {
              const a2 = (0, r.getGlsl)(e4.session.backend.glContext.version), [l2, c2] = e4.calculateTextureWidthAndHeight(s3, o.TextureType.packedLastDimension), [u, p] = [l2 / 4, c2], d = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${u}, ${p});
        return ${a2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
              return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: o.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: i3 }], shaderSource: d });
            })(e3, s2, t2, n2, i2) });
          }, c = (e3) => {
            if (!e3 || 3 !== e3.length) throw new Error("InstanceNormalization requires 3 inputs.");
            const t2 = e3[0], n2 = e3[1], r2 = e3[2];
            if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length) throw new Error("Invalid input shape.");
            if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1]) throw new Error("Input shapes are mismatched.");
            if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type) throw new Error("Invalid input type.");
            if (4 !== e3[0].dims.length) throw new Error("Only support 4-D input shape.");
          };
        }, 708: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createPackedMatmulProgramInfoLoader = void 0;
          const r = n(2517), o = n(5060), i = n(2039), s = n(9390), a = n(2823), l = n(5623);
          t.createPackedMatmulProgramInfoLoader = (e3, t2, n2) => {
            const c = (u = t2.length > 2, p = n2.activationCacheKey, { name: "MatMul (packed)", inputNames: u ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: u ? [i.TextureType.packed, i.TextureType.packed, i.TextureType.packed] : [i.TextureType.packed, i.TextureType.packed], cacheHint: p });
            var u, p;
            return Object.assign(Object.assign({}, c), { get: () => ((e4, t3, n3, c2) => {
              const u2 = n3.length > 2, p2 = u2 ? "value += getBiasForMatmul();" : "", d = n3[0].dims, _ = n3[1].dims, h = r.BroadcastUtil.calcShape(d, _, true), f = !r.ShapeUtil.areEqual(n3[0].dims, n3[1].dims);
              if (!h) throw new Error("Can't use matmul on the given tensors");
              const m = d[d.length - 1], g = Math.ceil(m / 2), b = d.length, w = _.length, x = (0, o.getGlsl)(e4.session.backend.glContext.version), y = (0, s.getCoordsDataType)(h.length), T = h.length, v = (0, s.getGlChannels)(), { activationFunction: k, applyActivation: M } = (0, a.getActivationSnippet)(c2), S = u2 ? `${(0, l.getBiasForMatmul)(y, v, n3[2].dims, h, true)}` : "", P = f ? `${(function(e5, t4, n4, o2) {
                let i2 = [], s2 = [];
                const a2 = n4[0].dims, l2 = n4[1].dims, c3 = a2.length, u3 = l2.length, p3 = o2.length, d2 = p3 - c3, _2 = p3 - u3;
                i2 = a2.map(((e6, n5) => `coords.${t4[n5 + d2]}`)), i2[c3 - 1] = "i*2", i2.join(", "), s2 = l2.map(((e6, n5) => `coords.${t4[n5 + _2]}`)), s2[u3 - 2] = "i*2", s2.join(", ");
                const h2 = r.BroadcastUtil.getBroadcastDims(a2, o2), f2 = r.BroadcastUtil.getBroadcastDims(l2, o2), m2 = h2.map(((e6) => `coords.${t4[e6 + d2]} = 0;`)).join("\n"), g2 = f2.map(((e6) => `coords.${t4[e6 + _2]} = 0;`)).join("\n"), b2 = `int lastDim = coords.${t4[p3 - 1]};
  coords.${t4[p3 - 1]} = coords.${t4[p3 - 2]};
  coords.${t4[p3 - 2]} = lastDim;`;
                return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${e5} coords = getOutputCoords();
  ${b2}
  ${m2}
  vec4 outputValue = getA(${i2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e5} coords = getOutputCoords();
  ${b2}
  ${g2}
  vec4 outputValue = getB(${s2});
  return outputValue;
}`;
              })(y, v, n3, h)}` : "", A = f ? "getAAtOutCoordsMatmul(i)" : `getA(${(function(e5, t4) {
                let n4 = "";
                for (let r2 = 0; r2 < t4 - 2; r2++) n4 += `rc.${e5[r2]}, `;
                return n4 += `rc.${e5[t4 - 2]}, i*2`, n4;
              })(v, b)})`, F = f ? "getBAtOutCoordsMatmul(i)" : `getB(${(function(e5, t4) {
                let n4 = "";
                for (let r2 = 0; r2 < t4 - 2; r2++) n4 += `rc.${e5[r2]}, `;
                return n4 += `i*2, rc.${e5[t4 - 1]}`, n4;
              })(v, w)})`, C = `
            ${P}
            ${S}
            ${k}
            void main() {
              ${f ? "" : `${y} rc =
          getOutputCoords(); int lastDim = rc.${v[T - 1]}; rc.${v[T - 1]} =
          rc.${v[T - 2]}; rc.${v[T - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${g}; i++) {
                vec4 a = ${A};
                vec4 b = ${F};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p2}
              ${M}
              ${x.output} = value;
            }`;
              return Object.assign(Object.assign({}, t3), { output: { dims: h, type: n3[0].type, textureType: i.TextureType.packed }, shaderSource: C, hasMain: true });
            })(e3, c, t2, n2) });
          };
        }, 5623: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.getBiasForMatmul = t.createMatmulProgramInfoLoader = t.parseMatMulAttributes = t.matMul = void 0;
          const r = n(2517), o = n(2039), i = n(9390), s = n(2823), a = n(708);
          function l(e3, t2) {
            const n2 = (a2 = e3.length > 2, l2 = t2.activationCacheKey, { name: "MatMul", inputNames: a2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: a2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: l2 });
            var a2, l2;
            return Object.assign(Object.assign({}, n2), { get: () => (function(e4, t3, n3) {
              const a3 = t3[0].dims, l3 = t3[1].dims, c2 = r.BroadcastUtil.calcShape(a3, l3, true);
              if (!c2) throw new Error("Can't use matmul on the given tensors");
              const p = (0, i.getCoordsDataType)(c2.length), d = (0, i.getGlChannels)(), { activationFunction: _, applyActivation: h } = (0, s.getActivationSnippet)(n3), f = t3.length > 2, m = f ? "value += getBiasForMatmul();" : "", g = f ? `${u(p, d, t3[2].dims, c2, false)}` : "", b = c2.length, w = a3.length, x = l3.length, y = `
    ${_}
    ${g}
    float process(int indices[${b}]) {
        int a[${w}];
        int b[${x}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${a3[a3.length - 1]}; ++k) {
            a[${w - 1}] = k;
            b[${x - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${m}
        ${h}
        return value;
    }`;
              return Object.assign(Object.assign({}, e4), { output: { dims: c2, type: t3[0].type, textureType: o.TextureType.unpacked }, shaderSource: y });
            })(n2, e3, t2) });
          }
          t.matMul = (e3, t2, n2) => (c(t2), e3.session.pack ? [e3.run((0, a.createPackedMatmulProgramInfoLoader)(e3, t2, n2), t2)] : [e3.run(l(t2, n2), t2)]), t.parseMatMulAttributes = (e3) => (0, s.parseInternalActivationAttributes)(e3.attributes), t.createMatmulProgramInfoLoader = l;
          const c = (e3) => {
            if (!e3 || 2 !== e3.length) throw new Error("MatMul requires 2 inputs.");
            if (e3[0].dims[e3[0].dims.length - 1] !== e3[1].dims[e3[1].dims.length - 2]) throw new Error("shared dimension does not match.");
            if ("float32" !== e3[0].type && "float64" !== e3[0].type || "float32" !== e3[1].type && "float64" !== e3[1].type) throw new Error("inputs should be float type");
            if (e3[0].type !== e3[1].type) throw new Error("inputs types should match");
          };
          function u(e3, t2, n2, o2, i2) {
            let s2 = "";
            const a2 = n2.length, l2 = o2.length, c2 = l2 - a2;
            s2 = l2 < 2 && a2 > 0 ? "coords" : n2.map(((e4, n3) => `coords.${t2[n3 + c2]}`)).join(", ");
            const u2 = r.BroadcastUtil.getBroadcastDims(n2, o2).map(((e4) => `coords.${t2[e4 + c2]} = 0;`)).join("\n");
            let p = "vec4(outputValue.xx, outputValue.yy)";
            return 1 === r.ShapeUtil.size(n2) && (p = "vec4(outputValue.x)"), i2 ? `
vec4 getBiasForMatmul() {
  ${e3} coords = getOutputCoords();
  ${u2}
  vec4 outputValue = getBias(${s2});
  return ${p};
}` : `
float getBiasForMatmul() {
  ${e3} coords = getOutputCoords();
  ${u2}
  return getBias(coords.x);
}`;
          }
          t.getBiasForMatmul = u;
        }, 2403: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createPackProgramInfoLoader = void 0;
          const r = n(5060), o = n(2039), i = n(9390), s = n(2827), a = { name: "pack", inputNames: ["A"], inputTypes: [o.TextureType.unpackedReversed] };
          t.createPackProgramInfoLoader = (e3, t2) => Object.assign(Object.assign({}, a), { get: () => ((e4, t3) => {
            const n2 = (0, r.getGlsl)(e4.session.backend.glContext.version), l = t3.dims, c = l.length, u = t3.dims.length, p = (0, i.getCoordsDataType)(u), d = (0, s.getChannels)("rc", u), _ = (h = u, f = d, m = l[l.length - 2], g = l[l.length - 1], 0 === h || 1 === h ? "" : `
    int r = ${f[h - 2]};
    int c = ${f[h - 1]};
    int rp1 = ${f[h - 2]} + 1;
    int cp1 = ${f[h - 1]} + 1;
    bool rEdge = rp1 >= ${g};
    bool cEdge = cp1 >= ${m};
    `);
            var h, f, m, g;
            let b;
            b = 0 === c ? [1, 1] : 1 === c ? [l[0], 1] : [l[u - 1], l[u - 2]];
            const w = (function(e5, t4, n3) {
              if (0 === e5) return "false";
              if (1 === e5) return `rc > ${t4[0]}`;
              let r2 = "";
              for (let o2 = e5 - 2; o2 < e5; o2++) r2 += `${n3[o2]} >= ${t4[o2 - e5 + 2]}`, o2 < e5 - 1 && (r2 += "||");
              return r2;
            })(u, b, d), x = (function(e5, t4) {
              const n3 = e5.length;
              if (0 === n3) return "getA(), 0, 0, 0";
              if (1 === n3) return `getA(rc),
            rc + 1 >= ${e5[0]} ? 0. : getA(rc + 1),
            0, 0`;
              let r2 = "";
              if (n3 > 2) for (let e6 = 0; e6 < n3 - 2; ++e6) r2 += `${t4[e6]},`;
              return `getA(${r2}r, c),
          rEdge ? 0. : getA(${r2}rp1, c),
          cEdge ? 0. : getA(${r2}r, cp1),
          rEdge || cEdge ? 0. : getA(${r2}rp1, cp1)`;
            })(l, d), y = `
        void main() {
          ${p} rc = getOutputCoords();

          if(${w}) {
            ${n2.output} = vec4(0);
          } else {
            ${_}

            ${n2.output} = vec4(${x});
          }
        }
      `;
            return Object.assign(Object.assign({}, a), { hasMain: true, output: { dims: t3.dims, type: t3.type, textureType: o.TextureType.packed }, shaderSource: y });
          })(e3, t2) });
        }, 2827: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.unpackFromChannel = t.getChannels = t.getVecChannels = void 0;
          const r = n(9390);
          function o(e3, t2) {
            return (0, r.getGlChannels)(t2).map(((t3) => `${e3}.${t3}`));
          }
          t.getVecChannels = o, t.getChannels = function(e3, t2) {
            return 1 === t2 ? [e3] : o(e3, t2);
          }, t.unpackFromChannel = function() {
            return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
          };
        }, 2870: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parsePadAttributesV11 = t.padV11 = t.parsePadAttributesV2 = t.padV2 = void 0;
          const r = n(246), o = n(2517), i = n(5060), s = n(2039), a = { name: "Pad", inputNames: ["A"], inputTypes: [s.TextureType.unpacked] };
          t.padV2 = (e3, t2, n2) => (u(t2), [e3.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => c(e3, t2[0], n2) }), t2)]), t.parsePadAttributesV2 = (e3) => {
            const t2 = e3.attributes.getString("mode", "constant"), n2 = e3.attributes.getFloat("value", 0), o2 = e3.attributes.getInts("pads");
            return (0, r.createAttributeWithCacheKey)({ mode: t2, value: n2, pads: o2 });
          }, t.padV11 = (e3, n2, r2) => {
            p(n2);
            const o2 = l(e3, n2, r2);
            return (0, t.padV2)(e3, [n2[0]], o2);
          }, t.parsePadAttributesV11 = (e3) => e3.attributes.getString("mode", "constant");
          const l = (e3, t2, n2) => {
            if (!e3.session.isInitializer(t2[1].dataId) || t2.length >= 3 && !e3.session.isInitializer(t2[2].dataId)) throw new Error("dynamic pad attributes are not allowed");
            const o2 = Array.from(t2[1].integerData), i2 = t2.length >= 3 ? t2[2].floatData[0] : 0;
            return (0, r.createAttributeWithCacheKey)({ mode: n2, pads: o2, value: i2 });
          }, c = (e3, t2, n2) => {
            const r2 = o.ShapeUtil.padShape(t2.dims.slice(), n2.pads), i2 = r2.length, a2 = `
      ${d(e3, t2, n2)}
      float process(int[${i2}] indices) {
          return padA(indices);
      }`;
            return { name: "Pad", inputNames: ["A"], inputTypes: [s.TextureType.unpacked], output: { dims: r2, type: t2.type, textureType: s.TextureType.unpacked }, shaderSource: a2 };
          }, u = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Pad requires 1 input");
            if ("float32" !== e3[0].type && "float64" !== e3[0].type) throw new Error("Invalid input type.");
          }, p = (e3) => {
            if (!e3 || 2 !== e3.length && 3 !== e3.length) throw new Error("Pad requires 2 or 3 inputs");
            if ("int32" !== e3[1].type) throw new Error("Invalid input type.");
            if (e3.length >= 3 && "string" === e3[2].type) throw new Error("Invalid input type.");
          }, d = (e3, t2, n2) => {
            const r2 = (0, i.getGlsl)(e3.session.backend.glContext.version), [a2, l2] = e3.calculateTextureWidthAndHeight(t2.dims, s.TextureType.unpacked), c2 = o.ShapeUtil.computeStrides(t2.dims);
            switch (n2.mode) {
              case "constant":
                return _(r2, t2.dims, c2, a2, l2, n2.pads, n2.value);
              case "reflect":
                return h(r2, t2.dims, c2, a2, l2, n2.pads);
              case "edge":
                return f(r2, t2.dims, c2, a2, l2, n2.pads);
              default:
                throw new Error("Invalid mode");
            }
          }, _ = (e3, t2, n2, r2, o2, i2, s2) => {
            const a2 = t2.length;
            let l2 = "";
            for (let e4 = a2 - 1; e4 >= 0; --e4) l2 += `
        k = m[${e4}] - ${i2[e4]};
        if (k < 0)  return constant;
        if (k >= ${t2[e4]}) return constant;
        offset += k * ${n2[e4]};
        `;
            return `
      float padA(int m[${a2}]) {
        const float constant = float(${s2});
        int offset = 0;
        int k = 0;
        ${l2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e3.texture2D}(A, coords));
        return value;
      }
      `;
          }, h = (e3, t2, n2, r2, o2, i2) => {
            const s2 = t2.length;
            let a2 = "";
            for (let e4 = s2 - 1; e4 >= 0; --e4) a2 += `
        k = m[${e4}] - ${i2[e4]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (t2[e4] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${t2[e4]}) { k = _2n_1 - k; }
        }
        offset += k * ${n2[e4]};
        `;
            return `
      float padA(int m[${s2}]) {
        int offset = 0;
        int k = 0;
        ${a2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e3.texture2D}(A, coords));
        return value;
      }
      `;
          }, f = (e3, t2, n2, r2, o2, i2) => {
            const s2 = t2.length;
            let a2 = "";
            for (let e4 = s2 - 1; e4 >= 0; --e4) a2 += `
        k = m[${e4}] - ${i2[e4]};
        if (k < 0)  k = 0;
        if (k >= ${t2[e4]}) k = ${t2[e4] - 1};
        offset += k * ${n2[e4]};
      `;
            return `
      float padA(int m[${s2}]) {
        int offset = 0;
        int k = 0;
        ${a2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e3.texture2D}(A, coords));
        return value;
      }
      `;
          };
        }, 2143: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.globalMaxPool = t.parseMaxPoolAttributes = t.maxPool = t.parseGlobalAveragePoolAttributes = t.globalAveragePool = t.parseAveragePoolAttributes = t.averagePool = void 0;
          const r = n(246), o = n(2517), i = n(2039);
          t.averagePool = (e3, t2, n2) => {
            p(t2);
            const r2 = { name: "AveragePool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: n2.cacheKey };
            return [e3.run(Object.assign(Object.assign({}, r2), { get: () => s(t2, r2, false, n2) }), t2)];
          }, t.parseAveragePoolAttributes = (e3) => {
            const t2 = e3.attributes.getString("auto_pad", "NOTSET"), n2 = e3.attributes.getInt("ceil_mode", 0), o2 = 0 !== e3.attributes.getInt("count_include_pad", 0), i2 = e3.attributes.getInts("kernel_shape"), s2 = e3.attributes.getInts("strides", []), a2 = e3.attributes.getInts("pads", []);
            if (0 !== n2) throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
            return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: o2, kernelShape: i2, strides: s2, pads: a2 });
          };
          const s = (e3, t2, n2, r2) => {
            const [s2, a2] = l(e3, r2, n2), c2 = o.ShapeUtil.size(s2.kernelShape);
            let u2 = "";
            s2.countIncludePad ? u2 += `value /= float(${c2});` : u2 += `value /= float(${c2} - pad);`;
            const p2 = `
        ${d(e3[0].dims, s2, "value += _X(x);", u2, "0.0")}
      `;
            return Object.assign(Object.assign({}, t2), { output: { dims: a2, type: e3[0].type, textureType: i.TextureType.unpacked }, shaderSource: p2 });
          };
          t.globalAveragePool = (e3, t2, n2) => {
            p(t2);
            const r2 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: `${n2.countIncludePad}` };
            return [e3.run(Object.assign(Object.assign({}, r2), { get: () => s(t2, r2, true, n2) }), t2)];
          }, t.parseGlobalAveragePoolAttributes = (e3) => {
            const t2 = 0 !== e3.attributes.getInt("count_include_pad", 0);
            return (0, r.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: t2, kernelShape: [], strides: [], pads: [] });
          }, t.maxPool = (e3, t2, n2) => {
            p(t2);
            const r2 = { name: "MaxPool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: n2.cacheKey };
            return [e3.run(Object.assign(Object.assign({}, r2), { get: () => a(t2, r2, false, n2) }), t2)];
          }, t.parseMaxPoolAttributes = (e3) => {
            const t2 = e3.attributes.getString("auto_pad", "NOTSET"), n2 = e3.attributes.getInt("ceil_mode", 0), o2 = e3.attributes.getInts("kernel_shape"), i2 = e3.attributes.getInts("strides", []), s2 = e3.attributes.getInts("pads", []), a2 = e3.attributes.getInt("storage_order", 0), l2 = e3.attributes.getInts("dilations", []);
            if (0 !== a2) throw new Error("column major storage order is not yet supported for MaxPool");
            if (0 !== n2) throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
            return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: false, kernelShape: o2, strides: i2, pads: s2, storageOrder: a2, dilations: l2 });
          };
          const a = (e3, t2, n2, r2) => {
            const [o2, s2] = l(e3, r2, n2), a2 = `
      ${d(e3[0].dims, o2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
            return Object.assign(Object.assign({}, t2), { output: { dims: s2, type: e3[0].type, textureType: i.TextureType.unpacked }, shaderSource: a2 });
          }, l = (e3, t2, n2) => {
            const r2 = e3[0].dims.slice(), i2 = Object.hasOwnProperty.call(t2, "dilations"), s2 = t2.kernelShape.slice(), a2 = t2.strides.slice(), l2 = i2 ? t2.dilations.slice() : [], c2 = t2.pads.slice();
            o.PoolConvUtil.adjustPoolAttributes(n2, r2, s2, a2, l2, c2);
            const u2 = o.PoolConvUtil.computePoolOutputShape(n2, r2, a2, l2, s2, c2, t2.autoPad), p2 = Object.assign({}, t2);
            return i2 ? Object.assign(p2, { kernelShape: s2, strides: a2, pads: c2, dilations: l2, cacheKey: t2.cacheKey }) : Object.assign(p2, { kernelShape: s2, strides: a2, pads: c2, cacheKey: t2.cacheKey }), [p2, u2];
          }, c = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, u = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] };
          t.globalMaxPool = (e3, t2) => (p(t2), [e3.run(Object.assign(Object.assign({}, u), { get: () => a(t2, u, true, c) }), t2)]);
          const p = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Pool ops requires 1 input.");
            if ("float32" !== e3[0].type && "float64" !== e3[0].type) throw new Error("Invalid input type.");
          }, d = (e3, t2, n2, r2, i2) => {
            const s2 = e3.length;
            if (t2.kernelShape.length <= 2) {
              const o2 = t2.kernelShape[t2.kernelShape.length - 1], a2 = t2.strides[t2.strides.length - 1], l2 = t2.pads[t2.pads.length / 2 - 1], c2 = t2.pads[t2.pads.length - 1], u2 = e3[s2 - 1];
              let p2 = "", d2 = "", _2 = "";
              if (p2 = l2 + c2 !== 0 ? `
          for (int i = 0; i < ${o2}; i++) {
            x[${s2} - 1] = indices[${s2} - 1] * ${a2} - ${l2} + i;
            if (x[${s2} - 1] < 0 || x[${s2} - 1] >= ${u2}) {
              pad++;
              continue;
            }
            ${n2}
          }` : `
          for (int i = 0; i < ${o2}; i++) {
            x[${s2} - 1] = indices[${s2} - 1] * ${a2} - ${l2} + i;
            ${n2}
          }`, 2 === t2.kernelShape.length) {
                const n3 = t2.kernelShape[t2.kernelShape.length - 2], r3 = t2.strides[t2.strides.length - 2], i3 = t2.pads[t2.pads.length / 2 - 2], a3 = t2.pads[t2.pads.length - 2], l3 = e3[s2 - 2];
                d2 = i3 + a3 !== 0 ? `
            for (int j = 0; j < ${n3}; j++) {
              x[${s2} - 2] = indices[${s2} - 2] * ${r3} - ${i3} + j;
              if (x[${s2} - 2] < 0 || x[${s2} - 2] >= ${l3}) {
                pad+= ${o2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n3}; j++) {
              x[${s2} - 2] = indices[${s2} - 2] * ${r3} - ${i3} + j;
            `, _2 = "\n          }\n        ";
              }
              return `
        float process(int indices[${s2}]) {
          int x[${s2}];
          copyVec(indices, x);

          float value = ${i2};
          int pad = 0;
          ${d2}
          ${p2}
          ${_2}
          ${r2}
          return value;
        }
      `;
            }
            {
              const a2 = o.ShapeUtil.size(t2.kernelShape), l2 = o.ShapeUtil.computeStrides(t2.kernelShape), c2 = l2.length, u2 = t2.pads.length, p2 = h(c2), d2 = _(e3, "inputDims"), f = _(t2.pads, "pads"), m = _(l2, "kernelStrides"), g = _(t2.strides, "strides");
              let b = "";
              return b = t2.pads.reduce(((e4, t3) => e4 + t3)) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n2}
          }` : `
          }
          ${n2}
        `, `
        ${p2}
        float process(int indices[${s2}]) {
          int x[${s2}];
          copyVec(indices, x);
          int offset[${c2}];
          int pads[${u2}];
          int inputDims[${s2}];
          int kernelStrides[${c2}];
          int strides[${c2}];
          ${f}
          ${d2}
          ${g}
          ${m}

          float value = ${i2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${a2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${s2} - ${c2}; j < ${s2}; j++) {
              x[j] = indices[j] * strides[j - ${s2} + ${c2}]
                + offset[j - ${s2} + ${c2}] - pads[j - 2];
              ${b}
          }
          ${r2}

          return value;
        }
      `;
            }
          }, _ = (e3, t2) => {
            let n2 = "";
            for (let r2 = 0; r2 < e3.length; r2++) n2 += `
      ${t2}[${r2}] = ${e3[r2]};
    `;
            return n2;
          }, h = (e3) => `
  void offsetToIndices(int offset, int[${e3}] strides, out int[${e3}] indices) {
    if (${e3} == 0) {
      return;
    }
    for (int i = 0; i < ${e3} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e3} - 1] = offset;
  }`;
        }, 4939: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.reduceLogSumSquare = t.reduceLogSum = t.reduceProd = t.reduceMin = t.reduceMax = t.reduceMean = t.reduceSum = t.parseReduceAttributes = void 0;
          const r = n(246), o = n(782), i = n(2517), s = n(2039), a = (e3, t2, n2, r2, o2) => {
            c(t2);
            const i2 = { name: r2, inputNames: ["A"], inputTypes: [s.TextureType.unpacked] };
            return [e3.run(Object.assign(Object.assign({}, i2), { cacheHint: n2.cacheKey, get: () => l(e3, t2, n2, r2, o2, i2) }), t2)];
          };
          t.parseReduceAttributes = (e3) => {
            const t2 = e3.attributes.getInts("axes", []), n2 = 1 === e3.attributes.getInt("keepdims", 1);
            return (0, r.createAttributeWithCacheKey)({ axes: t2, keepDims: n2 });
          };
          const l = (e3, t2, n2, r2, o2, a2) => {
            const l2 = [], c2 = t2[0].dims.length || 1, u = [], p = i.ShapeUtil.normalizeAxes(n2.axes, t2[0].dims.length), d = o2(t2, p);
            let _ = d[1];
            for (let e4 = 0; e4 < t2[0].dims.length; e4++) p.indexOf(e4) >= 0 || 0 === p.length ? (n2.keepDims && l2.push(1), _ = `
          for(int j${e4} = 0; j${e4} < ${t2[0].dims[e4]}; j${e4}++) {
            inputIdx[${e4}] = j${e4};
            ${_}
          }`) : (u.push(`inputIdx[${e4}] = outputIdx[${l2.length}];`), l2.push(t2[0].dims[e4]));
            const h = `
      float process(int outputIdx[${l2.length || 1}]) {
        float value;                 // final result
        int inputIdx[${c2}];      // addressing input data
        ${u.join("\n")}
        ${d[0]}       // init ops for reduce max/min
        ${_}
        ${d[2]}       // final computation for reduce mean
        return value;
      }`;
            return Object.assign(Object.assign({}, a2), { output: { dims: l2, type: t2[0].type, textureType: s.TextureType.unpacked }, shaderSource: h });
          }, c = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Reduce op requires 1 input.");
            if (-1 === o.NUMBER_TYPES.indexOf(e3[0].type)) throw new Error("Invalid input type.");
          };
          t.reduceSum = (e3, t2, n2) => a(e3, t2, n2, "ReduceSum", (() => ["value = 0.0;", "value += _A(inputIdx);", ""])), t.reduceMean = (e3, t2, n2) => a(e3, t2, n2, "ReduceMean", ((e4, t3) => {
            let n3 = 1;
            for (let r2 = 0; r2 < e4[0].dims.length; r2++) (t3.indexOf(r2) >= 0 || 0 === t3.length) && (n3 *= e4[0].dims[r2]);
            return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n3}.;`];
          })), t.reduceMax = (e3, t2, n2) => a(e3, t2, n2, "ReduceMax", ((e4, t3) => {
            const n3 = [];
            for (let r2 = 0; r2 < e4[0].dims.length; r2++) (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
            return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
          })), t.reduceMin = (e3, t2, n2) => a(e3, t2, n2, "ReduceMin", ((e4, t3) => {
            const n3 = [];
            for (let r2 = 0; r2 < e4[0].dims.length; r2++) (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
            return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
          })), t.reduceProd = (e3, t2, n2) => a(e3, t2, n2, "ReduceProd", (() => ["value = 1.0;", "value *= _A(inputIdx);", ""])), t.reduceLogSum = (e3, t2, n2) => a(e3, t2, n2, "ReduceLogSum", (() => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"])), t.reduceLogSumSquare = (e3, t2, n2) => a(e3, t2, n2, "ReduceLogSumSquare", (() => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]));
        }, 7019: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.isReshapeCheap = t.processDims3D = t.createPackedReshape3DProgramInfoLoader = void 0;
          const r = n(2517), o = n(5060), i = n(2039), s = n(2827);
          t.createPackedReshape3DProgramInfoLoader = (e3, t2, n2) => {
            const a = ((e4) => ({ name: "Reshape (packed)", inputTypes: [i.TextureType.packed], inputNames: ["A"], cacheHint: `${e4}` }))(n2);
            return Object.assign(Object.assign({}, a), { get: () => ((e4, t3, n3, a2) => {
              const l = t3.dims, c = a2;
              let u = "";
              for (let e5 = 0; e5 < 4; e5++) {
                let t4 = "";
                switch (e5) {
                  case 0:
                    t4 = "outputCoords = rc;";
                    break;
                  case 1:
                    t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                    break;
                  case 2:
                    t4 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                    break;
                  case 3:
                    t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                    break;
                  default:
                    throw new Error();
                }
                u += `
        ${t4}
        ${e5 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e5}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${e5 > 0 ? "}" : ""}
      `;
              }
              const p = (0, o.getGlsl)(e4.session.backend.glContext.version), d = `
      ${(function(e5) {
                const t4 = r.ShapeUtil.computeStrides(e5), n4 = ["b", "r", "c"], o2 = "index";
                return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t4.map(((e6, r2) => `int ${n4[r2]} = ${o2} / ${e6}; ${r2 === t4.length - 1 ? `int ${n4[r2 + 1]} = ${o2} - ${n4[r2]} * ${e6}` : `index -= ${n4[r2]} * ${e6}`};`)).join("")}
      return ivec3(b, r, c);
    }
  `;
              })(l)}
      ${(function(e5) {
                const t4 = r.ShapeUtil.computeStrides(e5);
                return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${t4[0]} + coords.z * ${t4[1]} + coords.y;
  }
`;
              })(c)}
      ${(0, s.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c[2]};
        int cols = ${c[1]};

        ${u}
        ${p.output} = result;
      }
    `;
              return Object.assign(Object.assign({}, n3), { output: { dims: c, type: t3.type, textureType: i.TextureType.packed }, shaderSource: d, hasMain: true });
            })(e3, t2, a, n2) });
          }, t.processDims3D = function(e3) {
            if (0 === e3.length) return [1, 1, 1];
            let t2 = 1;
            for (let n2 = 0; n2 < e3.length - 2; ++n2) t2 *= e3[n2];
            return [t2, e3.length > 1 ? e3[e3.length - 2] : 1, e3[e3.length - 1]];
          }, t.isReshapeCheap = function(e3, t2) {
            let n2 = false;
            return n2 = 0 === e3.length || 0 === t2.length || (e3.length < 2 || t2.length < 2 ? e3[e3.length - 1] === t2[t2.length - 1] : e3[e3.length - 1] === t2[t2.length - 1] && e3[e3.length - 2] === t2[t2.length - 2]), n2;
          };
        }, 718: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.reshape = void 0;
          const r = n(2517);
          t.reshape = (e3, t2) => {
            const n2 = r.ShapeUtil.calculateReshapedDims(t2[0].dims, t2[1].integerData);
            return e3.session.pack ? [e3.reshapePacked(t2[0], n2)] : [e3.reshapeUnpacked(t2[0], n2)];
          };
        }, 2268: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseResizeAttributesV11 = t.parseResizeAttributesV10 = t.resize = void 0;
          const r = n(5060), o = n(2039), i = n(9390), s = n(2827), a = n(9793), l = { name: "Resize", inputNames: ["A"], inputTypes: [o.TextureType.packed] };
          t.resize = (e3, t2, n2) => ((0, a.validateInputs)(t2, n2), [e3.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => c(e3, t2, n2) }), t2)]), t.parseResizeAttributesV10 = (e3) => (0, a.parseUpsampleAttributes)(e3, 10), t.parseResizeAttributesV11 = (e3) => (0, a.parseUpsampleAttributes)(e3, 11);
          const c = (e3, t2, n2) => {
            const a2 = (0, r.getGlsl)(e3.session.backend.glContext.version), [c2, p2] = u(t2, n2);
            if (c2.every(((e4) => 1 === e4)) && "tf_crop_and_resize" !== n2.coordinateTransformMode) return Object.assign(Object.assign({}, l), { output: { dims: p2, type: t2[0].type, textureType: o.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${a2.texture2D}(X, TexCoords);
                    ${a2.output} = v;
                }` });
            const d2 = p2.length;
            if (d2 < 2) throw new Error(`output dimension should be at least 2, but got ${d2}`);
            const _ = p2[d2 - 2], h = p2[d2 - 1], f = t2[0].dims;
            if (d2 !== f.length) throw new Error(`output dimension should match input ${f.length}, but got ${d2}`);
            const m = f[d2 - 2], g = f[d2 - 1], b = c2[d2 - 2], w = c2[d2 - 1];
            let x = "";
            if ("linear" !== n2.mode) throw new Error(`resize (packed) does not support mode: '${n2.mode}'`);
            switch (n2.coordinateTransformMode) {
              case "asymmetric":
                x = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
                break;
              case "half_pixel":
                x = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
                break;
              case "pytorch_half_pixel":
                x = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${_}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${_}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
                break;
              case "align_corners":
                x = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h}.0 - 1.0, ${_}.0 - 1.0, ${h}.0 - 1.0,
                            ${_}.0 - 1.0);
                        vec4 original = vec4(${g}.0 - 1.0, ${m}.0 - 1.0, ${g}.0 - 1.0,
                            ${m}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
                break;
              default:
                throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n2.coordinateTransformMode}'`);
            }
            const y = (0, i.getCoordsDataType)(d2), T = `
            const vec2 inputWH = vec2(${m}.0, ${g}.0);
            const vec4 scaleWHWH = vec4(float(${b}), float(${w}), float(${b}), float(${w}));
            ${(0, s.unpackFromChannel)()}
            ${x}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${y} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${_ - 1};
                bool hasNextCol = rc.z < ${h - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${a2.output} = vec4(newValue);
            }
        `;
            return Object.assign(Object.assign({}, l), { output: { dims: p2, type: t2[0].type, textureType: o.TextureType.packed }, hasMain: true, shaderSource: T });
          }, u = (e3, t2) => {
            const n2 = e3[0].dims;
            let r2, o2 = t2.scales;
            if (0 === o2.length) {
              const i3 = e3[t2.scalesInputIdx];
              if (i3 && 0 !== i3.size) {
                if (e3[t2.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
                o2 = p(i3, t2.mode, t2.isResize);
              } else {
                const i4 = e3[t2.sizesInputIdx];
                if (!i4 || 0 === i4.size) throw new Error("Either scales or sizes MUST be provided as input.");
                r2 = Array.from(i4.integerData), o2 = d(r2, n2, t2.mode, t2.isResize);
              }
            } else if (e3[t2.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
            const i2 = r2 || n2.map(((e4, t3) => Math.floor(e4 * o2[t3])));
            return [o2, i2];
          }, p = (e3, t2, n2) => {
            const r2 = Array.from(e3.floatData);
            return (0, a.scalesValidation)(r2, t2, n2), r2;
          }, d = (e3, t2, n2, r2) => {
            const o2 = t2.length, i2 = new Array(o2);
            for (let n3 = 0, r3 = o2; n3 < r3; n3++) if (0 === t2[n3]) {
              if (0 !== e3[n3]) throw new Error("Input dim is zero but required output dim is non-zero.");
              i2[n3] = 1;
            } else i2[n3] = e3[n3] / t2[n3];
            return (0, a.scalesValidation)(i2, n2, r2), i2;
          };
        }, 8117: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.shape = void 0;
          const r = n(9162);
          t.shape = (e3, t2) => (o(t2), [new r.Tensor([t2[0].dims.length], "int32", void 0, void 0, new Int32Array(t2[0].dims))]);
          const o = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Shape requires 1 input.");
          };
        }, 2278: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.sliceV10 = t.parseSliceAttributes = t.slice = void 0;
          const r = n(246), o = n(782), i = n(2517), s = n(2039), a = { name: "Slice", inputNames: ["A"], inputTypes: [s.TextureType.unpacked] };
          t.slice = (e3, t2, n2) => (c(t2), [e3.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => l(e3, t2[0], n2) }), t2)]), t.parseSliceAttributes = (e3) => {
            const t2 = e3.attributes.getInts("starts"), n2 = e3.attributes.getInts("ends"), o2 = e3.attributes.getInts("axes", []);
            return (0, r.createAttributeWithCacheKey)({ starts: t2, ends: n2, axes: o2 });
          };
          const l = (e3, t2, n2) => {
            const r2 = 0 === n2.axes.length ? t2.dims.slice(0).map(((e4, t3) => t3)) : n2.axes, o2 = i.ShapeUtil.normalizeAxes(r2, t2.dims.length), l2 = n2.starts.map(((e4, n3) => e4 > t2.dims[o2[n3]] - 1 ? t2.dims[o2[n3]] : i.ShapeUtil.normalizeAxis(e4, t2.dims[o2[n3]]))), c2 = n2.ends.map(((e4, n3) => e4 > t2.dims[o2[n3]] - 1 ? t2.dims[o2[n3]] : i.ShapeUtil.normalizeAxis(e4, t2.dims[o2[n3]]))), u2 = t2.dims.slice(), p2 = [];
            for (let e4 = 0; e4 < o2.length; e4++) u2[o2[e4]] = c2[e4] - l2[e4], l2[e4] > 0 && p2.push(`outputIdx[${o2[e4]}] += ${l2[e4]};`);
            const d = `
      float process(int outputIdx[${u2.length}]) {
        ${p2.join("\n      ")}
        return _A(outputIdx);
      }`;
            return Object.assign(Object.assign({}, a), { output: { dims: u2, type: t2.type, textureType: s.TextureType.unpacked }, shaderSource: d });
          }, c = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Slice requires 1 input.");
            if (-1 === o.NUMBER_TYPES.indexOf(e3[0].type)) throw new Error("Invalid input type.");
          };
          t.sliceV10 = (e3, t2) => {
            p(t2);
            const n2 = u(e3, t2);
            return [e3.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => l(e3, t2[0], n2) }), [t2[0]])];
          };
          const u = (e3, t2) => {
            if (!e3.session.isInitializer(t2[1].dataId) || !e3.session.isInitializer(t2[2].dataId) || t2.length >= 4 && !e3.session.isInitializer(t2[3].dataId) || t2.length >= 5 && !e3.session.isInitializer(t2[4].dataId)) throw new Error("dynamic slice attributes are not allowed");
            if (t2.length >= 5 && t2[4].integerData.some(((e4) => 1 !== e4))) throw new Error("currently non-1 steps is not supported for Slice");
            const n2 = Array.from(t2[1].integerData), r2 = Array.from(t2[2].integerData), o2 = t2.length >= 4 ? Array.from(t2[3].integerData) : [];
            return { starts: n2, ends: r2, axes: o2, cacheKey: `${o2};${n2};${r2}` };
          }, p = (e3) => {
            if (!e3 || e3.length < 3 || e3.length > 5) throw new Error("Invalid input number.");
            if ("int32" !== e3[1].type || 1 !== e3[1].dims.length) throw new Error("Invalid input type.");
            if ("int32" !== e3[2].type || 1 !== e3[2].dims.length) throw new Error("Invalid input type.");
            if (e3.length >= 4 && ("int32" !== e3[3].type || 1 !== e3[3].dims.length)) throw new Error("Invalid input type.");
            if (e3.length >= 5 && ("int32" !== e3[4].type || 1 !== e3[4].dims.length)) throw new Error("Invalid input type.");
          };
        }, 5524: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.softmaxV13 = t.parseSoftmaxAttributesV13 = t.parseSoftmaxAttributes = t.softmax = void 0;
          const r = n(246), o = n(2517), i = n(5060), s = n(2039), a = n(3738), l = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [s.TextureType.unpacked] }, c = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [s.TextureType.unpacked, s.TextureType.unpacked] }, u = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [s.TextureType.unpacked, s.TextureType.unpacked, s.TextureType.unpacked] };
          t.softmax = (e3, t2, n2) => {
            f(t2);
            const r2 = t2[0].dims.slice(), i2 = o.ShapeUtil.normalizeAxis(n2.axis, r2.length), s2 = o.ShapeUtil.sizeToDimension(r2, i2), a2 = o.ShapeUtil.sizeFromDimension(r2, i2);
            return p(e3, t2, n2, s2, a2);
          }, t.parseSoftmaxAttributes = (e3) => (0, r.createAttributeWithCacheKey)({ axis: e3.attributes.getInt("axis", 1) }), t.parseSoftmaxAttributesV13 = (e3) => (0, r.createAttributeWithCacheKey)({ axis: e3.attributes.getInt("axis", -1) }), t.softmaxV13 = (e3, t2, n2) => {
            f(t2);
            const i2 = t2[0].dims.slice(), s2 = o.ShapeUtil.normalizeAxis(n2.axis, i2.length), l2 = i2.length, c2 = s2 !== l2 - 1, u2 = [];
            let d2, _2 = [], h2 = [];
            c2 && (_2 = Array.from({ length: l2 }).map(((e4, t3) => t3)), _2[s2] = l2 - 1, _2[l2 - 1] = s2, _2.map(((e4) => u2.push(i2[e4]))), d2 = (0, r.createAttributeWithCacheKey)({ perm: _2 }), h2 = (0, a.transpose)(e3, t2, d2));
            const m = c2 ? o.ShapeUtil.sizeToDimension(u2, l2 - 1) : o.ShapeUtil.sizeToDimension(i2, l2 - 1), g = c2 ? o.ShapeUtil.sizeFromDimension(u2, l2 - 1) : o.ShapeUtil.sizeFromDimension(i2, l2 - 1), b = p(e3, c2 ? h2 : t2, n2, m, g);
            return c2 ? (0, a.transpose)(e3, b, d2) : b;
          };
          const p = (e3, t2, n2, r2, o2) => {
            const i2 = d(e3, t2[0], r2, o2, [r2]), s2 = e3.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => i2 }), t2), a2 = _(e3, t2[0], r2, o2, i2.output.dims, [r2]), p2 = e3.run(Object.assign(Object.assign({}, c), { cacheHint: n2.cacheKey, get: () => a2 }), [t2[0], s2]), f2 = h(e3, t2[0], r2, o2, i2.output.dims, a2.output.dims);
            return [e3.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => f2 }), [t2[0], s2, p2])];
          }, d = (e3, t2, n2, r2, o2) => {
            const [a2, c2] = e3.calculateTextureWidthAndHeight(t2.dims, s.TextureType.unpacked), u2 = o2.length;
            if (n2 < 1 || r2 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== o2.length) throw new Error("Dimensionality of the output should be 1");
            if (o2[0] !== n2) throw new Error("Shape of the output should be equal to logical row count");
            const p2 = (0, i.getGlsl)(e3.session.backend.glContext.version), d2 = `
      float process(int[${u2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float max = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset, ${a2},
        ${c2} )));
        for(int i=1; i<${r2}; ++i)
        {
          float current = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${a2}, ${c2})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
            return Object.assign(Object.assign({}, l), { output: { dims: o2, type: t2.type, textureType: s.TextureType.unpacked }, shaderSource: d2 });
          }, _ = (e3, t2, n2, r2, o2, a2) => {
            const [l2, u2] = e3.calculateTextureWidthAndHeight(t2.dims, s.TextureType.unpacked), p2 = a2.length;
            if (n2 < 1 || r2 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== a2.length) throw new Error("Dimensionality of the output should be 1");
            if (a2[0] !== n2) throw new Error("Shape of the output should be equal to logical row count");
            if (1 !== o2.length) throw new Error("Dimensionality of the intermediate results should be 1");
            if (o2[0] !== n2) throw new Error("Shape of the intermediate results should be equal to logical row count");
            const d2 = `
      float process(int[${p2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r2}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, i.getGlsl)(e3.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${l2}, ${u2}))) - max);
        }

        return norm_factor;
      }`;
            return Object.assign(Object.assign({}, c), { output: { dims: a2, type: t2.type, textureType: s.TextureType.unpacked }, shaderSource: d2 });
          }, h = (e3, t2, n2, r2, o2, i2) => {
            const [a2, l2] = e3.calculateTextureWidthAndHeight(t2.dims, s.TextureType.unpacked), c2 = t2.dims.length;
            if (n2 < 1 || r2 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== o2.length || 1 !== i2.length) throw new Error("Dimensionality of the intermediate results should be 1");
            if (o2[0] !== n2 || i2[0] !== n2) throw new Error("Shape of the intermediate results should be equal to logical row count");
            const p2 = `
      float process(int[${c2}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${a2}, ${l2});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r2};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
            return Object.assign(Object.assign({}, u), { output: { dims: t2.dims, type: t2.type, textureType: s.TextureType.unpacked }, shaderSource: p2 });
          }, f = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Softmax requires 1 input.");
            if ("float32" !== e3[0].type && "float64" !== e3[0].type) throw new Error("Invalid input type");
          };
        }, 5975: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseSplitAttributes = t.split = void 0;
          const r = n(246), o = n(2517), i = n(2039), s = { name: "Split", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
          t.split = (e3, t2, n2) => {
            c(t2);
            const r2 = o.ShapeUtil.normalizeAxis(n2.axis, t2[0].dims.length), i2 = a(e3, t2, r2, n2), u = [];
            for (let o2 = 0; o2 < i2; ++o2) u.push(e3.run(Object.assign(Object.assign({}, s), { cacheHint: `${n2.cacheKey};${o2}`, get: () => l(e3, t2[0], n2, r2, o2) }), t2));
            return u;
          }, t.parseSplitAttributes = (e3) => {
            const t2 = e3.attributes.getInt("axis", 0), n2 = e3.attributes.getInts("split", []), o2 = e3.outputs.length;
            return (0, r.createAttributeWithCacheKey)({ axis: t2, split: n2, numOutputs: o2 });
          };
          const a = (e3, t2, n2, r2) => {
            const [, i2] = o.SplitUtil.splitShape(t2[0].dims, n2, r2.split, r2.numOutputs);
            return i2.length;
          }, l = (e3, t2, n2, r2, a2) => {
            const [l2, c2] = o.SplitUtil.splitShape(t2.dims, r2, n2.split, n2.numOutputs), u = c2[a2], p = l2[a2], d = `
      float process(int indices[${p.length}]) {
        indices[${r2}] += ${u};
        return _A(indices);
      }
    `;
            return Object.assign(Object.assign({}, s), { cacheHint: `${n2.cacheKey}:${a2}`, output: { dims: p, type: t2.type, textureType: i.TextureType.unpacked }, shaderSource: d });
          }, c = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Split requires one input.");
            if ("int8" !== e3[0].type && "uint8" !== e3[0].type && "int16" !== e3[0].type && "uint16" !== e3[0].type && "int32" !== e3[0].type && "uint32" !== e3[0].type && "float32" !== e3[0].type && "float64" !== e3[0].type && "bool" !== e3[0].type) throw new Error("Invalid input type.");
          };
        }, 3933: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseSqueezeAttributes = t.squeezeV13 = t.squeeze = void 0;
          const r = n(2517);
          t.squeeze = (e3, t2, n2) => {
            o(t2);
            const i2 = r.ShapeUtil.squeezeShape(t2[0].dims, n2);
            return [e3.reshapeUnpacked(t2[0], i2)];
          }, t.squeezeV13 = (e3, n2) => (i(n2), (0, t.squeeze)(e3, [n2[0]], Array.from(n2[1].integerData))), t.parseSqueezeAttributes = (e3) => e3.attributes.getInts("axes");
          const o = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Squeeze requires 1 input.");
            if ("string" === e3[0].type) throw new Error("invalid input tensor types.");
          }, i = (e3) => {
            if (!e3 || 2 !== e3.length) throw new Error("Squeeze requires 2 inputs.");
            if ("int32" !== e3[1].type) throw new Error("Invalid input type.");
          };
        }, 6558: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.sum = void 0;
          const r = n(5060), o = n(2039);
          t.sum = (e3, t2) => {
            s(t2);
            const n2 = { name: "Sum", inputNames: t2.map(((e4, t3) => `X${t3}`)), inputTypes: new Array(t2.length).fill(o.TextureType.unpacked) };
            return [e3.run(Object.assign(Object.assign({}, n2), { get: () => i(e3, t2, n2) }), t2)];
          };
          const i = (e3, t2, n2) => {
            const i2 = (0, r.getGlsl)(e3.session.backend.glContext.version), s2 = t2[0].dims.slice(), a = `
      void main() {
        vec4 result = ${t2.map(((e4, t3) => `${i2.texture2D}(X${t3},TexCoords)`)).join(" + ")};
        ${i2.output} = result;
      }
    `;
            return Object.assign(Object.assign({}, n2), { output: { dims: s2, type: t2[0].type, textureType: o.TextureType.unpacked }, hasMain: true, shaderSource: a });
          }, s = (e3) => {
            if (!e3 || 0 === e3.length) throw new Error("Sum requires inputs.");
            const t2 = e3[0].dims.length;
            for (let n2 = 1; n2 < e3.length; n2++) {
              if (t2 !== e3[n2].dims.length) throw new Error("Input shapes are mismatched.");
              for (let r2 = 0; r2 < t2; r2++) if (e3[0].dims[r2] !== e3[n2].dims[r2]) throw new Error("Input shapes are not matched.");
            }
            if ("float32" !== e3[0].type && "float64" !== e3[0].type) throw new Error("Invalid input type.");
            for (let t3 = 1; t3 < e3.length; t3++) if (e3[0].type !== e3[t3].type) throw new Error("Input types are not matched.");
          };
        }, 5723: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.tile = void 0;
          const r = n(782), o = n(2039);
          t.tile = (e3, t2) => {
            s(t2);
            const n2 = { name: "Tile", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
            return [e3.run(Object.assign(Object.assign({}, n2), { get: () => i(e3, t2, n2) }), t2)];
          };
          const i = (e3, t2, n2) => {
            const r2 = t2[0].dims.slice(), i2 = new Array(r2.length), s2 = [];
            for (let e4 = 0; e4 < r2.length; e4++) i2[e4] = r2[e4] * t2[1].numberData[e4], s2.push(`inputIdx[${e4}] = int(mod(float(outputIdx[${e4}]), ${r2[e4]}.));`);
            const a = i2.length, l = `
      float process(int outputIdx[${a}]) {
        int inputIdx[${a}];
        ${s2.join("\n")}
        return _A(inputIdx);
      }
    `;
            return Object.assign(Object.assign({}, n2), { output: { dims: i2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: l });
          }, s = (e3) => {
            if (!e3 || 2 !== e3.length) throw new Error("Tile requires 2 input.");
            if (1 !== e3[1].dims.length) throw new Error("The second input shape must 1 dimension.");
            if (e3[1].dims[0] !== e3[0].dims.length) throw new Error("Invalid input shape.");
            if (-1 === r.NUMBER_TYPES.indexOf(e3[0].type)) throw new Error("Invalid input type.");
            if ("int32" !== e3[1].type && "int16" !== e3[1].type) throw new Error("Invalid repeat type.");
          };
        }, 3738: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseTransposeAttributes = t.transpose = void 0;
          const r = n(246), o = n(2517), i = n(2039), s = { name: "Transpose", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
          t.transpose = (e3, t2, n2) => (p(t2), [e3.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => a(e3, t2[0], n2.perm) }), t2)]), t.parseTransposeAttributes = (e3) => (0, r.createAttributeWithCacheKey)({ perm: e3.attributes.getInts("perm", []) });
          const a = (e3, t2, n2) => {
            const r2 = t2.dims;
            n2 = l(r2, n2);
            const o2 = c(r2, n2), a2 = r2.length, p2 = `
      ${u("perm", n2, a2)}
      float process(int indices[${a2}]) {
        int a[${a2}];
        perm(a, indices);
        return _A(a);
      }`;
            return Object.assign(Object.assign({}, s), { output: { dims: o2, type: t2.type, textureType: i.TextureType.unpacked }, shaderSource: p2 });
          }, l = (e3, t2) => (t2 && t2.length !== e3.length && (t2 = [...e3.keys()].reverse()), t2), c = (e3, t2) => (t2 = l(e3, t2), o.ShapeUtil.sortBasedOnPerm(e3, t2)), u = (e3, t2, n2) => {
            const r2 = [];
            r2.push(`void ${e3}(out int a[${n2}], int src[${n2}]) {`);
            for (let e4 = 0; e4 < n2; ++e4) r2.push(`	a[${t2[e4]}]=src[${e4}];`);
            return r2.push("	}"), r2.join("\n");
          }, p = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Transpose requires 1 input.");
            if ("float32" !== e3[0].type && "float64" !== e3[0].type) throw new Error("input should be float tensor");
          };
        }, 8710: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.encodeAsUint8 = void 0;
          const r = n(5060), o = n(2039);
          t.encodeAsUint8 = (e3, t2) => {
            const n2 = t2.shape, i = (0, r.getGlsl)(e3.session.backend.glContext.version), s = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${i.texture2D}(X,TexCoords).r;
      ${i.output} = encodeAsUint8(value);
    }`, a = { name: "Uint8Encode", inputTypes: [o.TextureType.unpacked], inputNames: ["X"], output: { dims: n2, type: t2.tensor.type, textureType: o.TextureType.downloadUint8AsFloat }, shaderSource: s, hasMain: true };
            return e3.executeProgram(a, [t2.tensor]);
          };
        }, 4909: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.tanh = t.tan = t.sqrt = t.sin = t.sigmoid = t.relu = t.not = t.neg = t.log = t.parseLeakyReluAttributes = t.leakyRelu = t.identity = t.floor = t.exp = t.parseEluAttributes = t.elu = t.cos = t.ceil = t.clipV11 = t.parseClipAttributes = t.clip = t.atan = t.asin = t.acos = t.abs = t.glslTanh = t.glslTan = t.glslSqrt = t.glslSigmoid = t.glslRelu = t.glslSin = t.glslNot = t.glslNeg = t.glslLog = t.glslLeakyRelu = t.glslIdentity = t.glslClip = t.glslFloor = t.glslExp = t.glslElu = t.glslCos = t.glslCeil = t.glslAtan = t.glslAsin = t.glslAcos = t.glslAbs = void 0;
          const r = n(246), o = n(2517), i = n(8520), s = n(5060), a = n(2039);
          function l() {
            return F("abs");
          }
          function c() {
            return F("acos");
          }
          function u() {
            return F("asin");
          }
          function p() {
            return F("atan");
          }
          function d() {
            return F("ceil");
          }
          function _() {
            return F("cos");
          }
          function h(e3) {
            const t2 = "elu";
            return { body: `
  const float alpha = float(${e3});

  float ${t2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function f() {
            return F("exp");
          }
          function m() {
            return F("floor");
          }
          function g(e3, t2) {
            const n2 = "clip";
            return { body: `
  const float min = float(${e3});
  const float max = float(${t2});

  float ${n2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n2, type: i.FunctionType.ValueBased };
          }
          function b() {
            const e3 = "indentity";
            return { body: `
  float ${e3}_(float a) {
    return a;
  }
  vec4 ${e3}_(vec4 v) {
    return v;
  }
  `, name: e3, type: i.FunctionType.ValueBased };
          }
          function w(e3) {
            const t2 = "leakyRelu";
            return { body: `
  const float alpha = float(${e3});

  float ${t2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function x() {
            return F("log");
          }
          function y() {
            const e3 = "neg";
            return { body: `
  float ${e3}_(float a) {
    return -a;
  }
  vec4 ${e3}_(vec4 v) {
    return -v;
  }
  `, name: e3, type: i.FunctionType.ValueBased };
          }
          function T() {
            const e3 = "not";
            return { body: `
  float ${e3}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e3}_(bool a) {
    return !a;
  }
  vec4 ${e3}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e3}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: e3, type: i.FunctionType.ValueBased };
          }
          function v() {
            return F("sin");
          }
          function k() {
            const e3 = "relu";
            return { body: `
  float ${e3}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e3}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: e3, type: i.FunctionType.ValueBased };
          }
          function M() {
            const e3 = "sigmoid";
            return { body: `
  float ${e3}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e3}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: e3, type: i.FunctionType.ValueBased };
          }
          function S() {
            return F("sqrt");
          }
          function P() {
            return F("tan");
          }
          function A() {
            const e3 = "tanh";
            return { body: `
  float ${e3}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e3}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: e3, type: i.FunctionType.ValueBased };
          }
          function F(e3) {
            return { body: `
  float ${e3}_(float a) {
    return ${e3}(a);
  }
  vec4 ${e3}_(vec4 v) {
    return ${e3}(v);
  }
  `, name: e3, type: i.FunctionType.ValueBased };
          }
          t.glslAbs = l, t.glslAcos = c, t.glslAsin = u, t.glslAtan = p, t.glslCeil = d, t.glslCos = _, t.glslElu = h, t.glslExp = f, t.glslFloor = m, t.glslClip = g, t.glslIdentity = b, t.glslLeakyRelu = w, t.glslLog = x, t.glslNeg = y, t.glslNot = T, t.glslSin = v, t.glslRelu = k, t.glslSigmoid = M, t.glslSqrt = S, t.glslTan = P, t.glslTanh = A;
          const C = (e3, t2, n2, r2) => {
            const o2 = e3.session.pack ? a.TextureType.packed : a.TextureType.unpacked, i2 = { name: n2.name, inputTypes: [o2], inputNames: ["A"], cacheHint: r2 };
            return Object.assign(Object.assign({}, i2), { get: () => ((e4, t3, n3, r3) => {
              const o3 = e4.session.pack ? a.TextureType.packed : a.TextureType.unpacked, i3 = (0, s.getGlsl)(e4.session.backend.glContext.version);
              return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: o3 }, shaderSource: `
     ${r3.body}
     void main() {
       vec4 v = ${i3.texture2D}(A, TexCoords);
       v = ${r3.name}_(v);
       ${i3.output} = v;
     }
     `, hasMain: true });
            })(e3, i2, t2, n2) });
          };
          t.abs = (e3, t2) => [e3.run(C(e3, t2[0], l()), t2)], t.acos = (e3, t2) => [e3.run(C(e3, t2[0], c()), t2)], t.asin = (e3, t2) => [e3.run(C(e3, t2[0], u()), t2)], t.atan = (e3, t2) => [e3.run(C(e3, t2[0], p()), t2)], t.clip = (e3, t2, n2) => [e3.run(C(e3, t2[0], g(n2.min, n2.max), n2.cacheKey), t2)], t.parseClipAttributes = (e3) => (0, r.createAttributeWithCacheKey)({ min: e3.attributes.getFloat("min", o.MIN_CLIP), max: e3.attributes.getFloat("max", o.MAX_CLIP) }), t.clipV11 = (e3, n2) => {
            const r2 = E(e3, n2);
            return (0, t.clip)(e3, [n2[0]], r2);
          };
          const E = (e3, t2) => {
            if (t2.length >= 3 && (!e3.session.isInitializer(t2[1].dataId) || !e3.session.isInitializer(t2[2].dataId))) throw new Error("dynamic clip attributes are not allowed");
            const n2 = t2.length >= 3 ? t2[1].numberData[0] : o.MIN_CLIP, i2 = t2.length >= 3 ? t2[2].numberData[0] : o.MAX_CLIP;
            return (0, r.createAttributeWithCacheKey)({ min: n2, max: i2 });
          };
          t.ceil = (e3, t2) => [e3.run(C(e3, t2[0], d()), t2)], t.cos = (e3, t2) => [e3.run(C(e3, t2[0], _()), t2)], t.elu = (e3, t2, n2) => [e3.run(C(e3, t2[0], h(n2.alpha), n2.cacheKey), t2)], t.parseEluAttributes = (e3) => (0, r.createAttributeWithCacheKey)({ alpha: e3.attributes.getFloat("alpha", 1) }), t.exp = (e3, t2) => [e3.run(C(e3, t2[0], f()), t2)], t.floor = (e3, t2) => [e3.run(C(e3, t2[0], m()), t2)], t.identity = (e3, t2) => [e3.run(C(e3, t2[0], b()), t2)], t.leakyRelu = (e3, t2, n2) => [e3.run(C(e3, t2[0], w(n2.alpha), n2.cacheKey), t2)], t.parseLeakyReluAttributes = (e3) => (0, r.createAttributeWithCacheKey)({ alpha: e3.attributes.getFloat("alpha", 0.01) }), t.log = (e3, t2) => [e3.run(C(e3, t2[0], x()), t2)], t.neg = (e3, t2) => [e3.run(C(e3, t2[0], y()), t2)], t.not = (e3, t2) => [e3.run(C(e3, t2[0], T()), t2)], t.relu = (e3, t2) => [e3.run(C(e3, t2[0], k()), t2)], t.sigmoid = (e3, t2) => [e3.run(C(e3, t2[0], M()), t2)], t.sin = (e3, t2) => [e3.run(C(e3, t2[0], v()), t2)], t.sqrt = (e3, t2) => [e3.run(C(e3, t2[0], S()), t2)], t.tan = (e3, t2) => [e3.run(C(e3, t2[0], P()), t2)], t.tanh = (e3, t2) => [e3.run(C(e3, t2[0], A()), t2)];
        }, 5611: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackProgramInfoLoader = t.createUnpackProgramInfo = void 0;
          const r = n(5060), o = n(2039), i = n(9390), s = n(2827), a = { name: "unpack", inputNames: ["A"], inputTypes: [o.TextureType.packed] };
          t.createUnpackProgramInfo = (e3, t2) => {
            const n2 = t2.dims.length, l = (0, s.getChannels)("rc", n2), c = l.slice(-2), u = (0, i.getCoordsDataType)(n2), p = (0, s.unpackFromChannel)(), d = 0 === t2.dims.length ? "" : (function(e4, t3) {
              if (1 === e4) return "rc";
              let n3 = "";
              for (let r2 = 0; r2 < e4; r2++) n3 += t3[r2], r2 < e4 - 1 && (n3 += ",");
              return n3;
            })(n2, l), _ = n2 <= 1 ? "rc" : `vec2(${c.join(",")})`, h = `
    ${p}
    void main() {
      ${u} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${d});

       ${(0, r.getGlsl)(e3.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${_}), 0, 0, 0);
     }
   `;
            return Object.assign(Object.assign({}, a), { hasMain: true, output: { dims: t2.dims, type: t2.type, textureType: o.TextureType.unpacked }, shaderSource: h });
          }, t.createUnpackProgramInfoLoader = (e3, n2) => Object.assign(Object.assign({}, a), { get: () => (0, t.createUnpackProgramInfo)(e3, n2) });
        }, 8428: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.parseUnsqueezeAttributes = t.unsqueezeV13 = t.unsqueeze = void 0;
          const r = n(2517);
          t.unsqueeze = (e3, t2, n2) => {
            o(t2);
            const i2 = r.ShapeUtil.unsqueezeShape(t2[0].dims, n2);
            return [e3.reshapeUnpacked(t2[0], i2)];
          }, t.unsqueezeV13 = (e3, n2) => (i(n2), (0, t.unsqueeze)(e3, [n2[0]], Array.from(n2[1].integerData))), t.parseUnsqueezeAttributes = (e3) => e3.attributes.getInts("axes");
          const o = (e3) => {
            if (!e3 || 1 !== e3.length) throw new Error("Unsqueeze requires 1 input.");
            if ("string" === e3[0].type) throw new Error("invalid input tensor types.");
          }, i = (e3) => {
            if (!e3 || 2 !== e3.length) throw new Error("Unsqueeze requires 2 inputs.");
            if ("int32" !== e3[1].type) throw new Error("Invalid input type.");
          };
        }, 9793: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.scalesValidation = t.validateInputs = t.parseUpsampleAttributes = t.parseUpsampleAttributesV9 = t.parseUpsampleAttributesV7 = t.upsample = void 0;
          const r = n(246), o = n(5060), i = n(2039), s = { name: "Upsample", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] };
          t.upsample = (e3, n2, r2) => ((0, t.validateInputs)(n2, r2), [e3.run(Object.assign(Object.assign({}, s), { cacheHint: r2.cacheKey, get: () => a(e3, n2, r2) }), n2)]), t.parseUpsampleAttributesV7 = (e3) => (0, t.parseUpsampleAttributes)(e3, 7), t.parseUpsampleAttributesV9 = (e3) => (0, t.parseUpsampleAttributes)(e3, 9), t.parseUpsampleAttributes = (e3, n2) => {
            const o2 = n2 >= 10, i2 = e3.attributes.getString("mode", "nearest");
            if ("nearest" !== i2 && "linear" !== i2 && (n2 < 11 || "cubic" !== i2)) throw new Error(`unrecognized mode: ${i2}`);
            let s2 = [];
            n2 < 9 && (s2 = e3.attributes.getFloats("scales"), (0, t.scalesValidation)(s2, i2, o2));
            const a2 = e3.attributes.getFloat("extrapolation_value", 0), l = n2 > 10 ? e3.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
            if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(l)) throw new Error(`coordinate_transform_mode '${l}' is not supported`);
            const c = "tf_crop_and_resize" === l, u = c, p = "nearest" === i2 && n2 >= 11 ? e3.attributes.getString("nearest_mode", "round_prefer_floor") : "";
            if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p)) throw new Error(`nearest_mode '${p}' is not supported`);
            const d = e3.attributes.getFloat("cubic_coeff_a", -0.75), _ = 0 !== e3.attributes.getInt("exclude_outside", 0);
            if (_ && "cubic" !== i2) throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
            const h = n2 < 11 || "nearest" === i2 && "asymmetric" === l && "floor" === p;
            let f = 0, m = 0, g = 0;
            return n2 > 10 ? e3.inputs.length > 2 ? (f = 1, m = 2, g = 3) : (m = 1, g = 2) : 9 === n2 && (m = 1), (0, r.createAttributeWithCacheKey)({ opset: n2, isResize: o2, mode: i2, scales: s2, extrapolationValue: a2, coordinateTransformMode: l, useExtrapolation: u, needRoiInput: c, nearestMode: p, cubicCoefficientA: d, excludeOutside: _, useNearest2xOptimization: h, roiInputIdx: f, scalesInputIdx: m, sizesInputIdx: g });
          };
          const a = (e3, t2, n2) => {
            const r2 = (0, o.getGlsl)(e3.session.backend.glContext.version), [a2, l] = e3.calculateTextureWidthAndHeight(t2[0].dims, i.TextureType.unpacked), c = t2[0].dims.map(((e4, t3) => Math.floor(e4 * n2.scales[t3]))), [u, p] = e3.calculateTextureWidthAndHeight(c, i.TextureType.unpacked), d = c.length, _ = new Array(d), h = new Array(d);
            let f = `
      int output_pitches[${d}];
      int input_pitches[${d}];
      `;
            for (let e4 = d - 1; e4 >= 0; e4--) _[e4] = e4 === d - 1 ? 1 : _[e4 + 1] * c[e4 + 1], h[e4] = e4 === d - 1 ? 1 : h[e4 + 1] * t2[0].dims[e4 + 1], f += `
        output_pitches[${e4}] = ${_[e4]};
        input_pitches[${e4}] = ${h[e4]};
        `;
            const m = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${a2}, ${l});
        float value = getColorAsFloat(${r2.texture2D}(X, coords));
        return value;
      }
      `, g = "nearest" === n2.mode ? `
    ${m}
    float process(int indices[${d}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${u}, ${p});

      ${f}

      int d, m;
      for (int dim = 0; dim < ${d}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === d ? `
    ${m}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${u}, ${p});

      ${f}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${t2[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${m}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${u}, ${p});

      ${f}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${t2[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
            return Object.assign(Object.assign({}, s), { output: { dims: c, type: t2[0].type, textureType: i.TextureType.unpacked }, shaderSource: g, variables: [{ name: "scales", type: "int", arrayLength: n2.scales.length, data: n2.scales.map(((e4) => Math.ceil(e4))) }] });
          };
          t.validateInputs = (e3, t2) => {
            if (!e3 || t2.opset < 9 && 1 !== e3.length || t2.opset >= 9 && t2.opset < 11 && 2 !== e3.length || t2.opset >= 11 && e3.length < 2) throw new Error("invalid inputs.");
            if (t2.scales.length > 0 && e3[0].dims.length !== t2.scales.length) throw new Error("Invalid input shape.");
            if ("string" === e3[0].type) throw new Error("Invalid input tensor types.");
          }, t.scalesValidation = (e3, t2, n2) => {
            if (n2) {
              for (const t3 of e3) if (t3 <= 0) throw new Error("Scale value should be greater than 0.");
            } else for (const t3 of e3) if (t3 < 1) throw new Error("Scale value should be greater than or equal to 1.");
            if (!("linear" !== t2 && "cubic" !== t2 || 2 === e3.length || 4 === e3.length && 1 === e3[0] && 1 === e3[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n2 ? "Resize" : "Upsample"} opeartor.`);
          };
        }, 1958: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.ProgramManager = void 0;
          const r = n(1670), o = n(6231), i = n(8879), s = n(5060);
          t.ProgramManager = class {
            constructor(e3, t2, n2) {
              this.profiler = e3, this.glContext = t2, this.textureLayoutStrategy = n2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
            }
            getArtifact(e3) {
              return this.repo.get(e3);
            }
            setArtifact(e3, t2) {
              this.repo.set(e3, t2);
            }
            run(e3, t2, n2) {
              var r2;
              this.profiler.event("op", `ProgramManager.run ${null !== (r2 = e3.programInfo.name) && void 0 !== r2 ? r2 : "unknown kernel"}`, (() => {
                var r3;
                const i2 = this.glContext.gl, s2 = e3.program;
                i2.useProgram(s2);
                try {
                  this.bindOutput(n2), this.attributesBound || this.bindAttributes(e3.attribLocations), this.bindUniforms(e3.uniformLocations, null !== (r3 = e3.programInfo.variables) && void 0 !== r3 ? r3 : [], t2);
                } catch (t3) {
                  throw o.Logger.error("ProgramManager", e3.programInfo.shaderSource), t3;
                }
                this.profiler.event("backend", "GlContext.draw()", (() => {
                  this.glContext.draw();
                }));
              }), this.glContext);
            }
            dispose() {
              this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach(((e3) => this.glContext.deleteProgram(e3.program)));
            }
            build(e3, t2, n2) {
              return this.profiler.event("backend", "ProgramManager.build", (() => {
                const r2 = new i.GlslPreprocessor(this.glContext, e3, t2, n2), o2 = r2.preprocess(), s2 = this.compile(o2);
                return { programInfo: e3, program: s2, uniformLocations: this.getUniformLocations(s2, r2.context.programInfo.inputNames, r2.context.programInfo.variables), attribLocations: this.getAttribLocations(s2) };
              }));
            }
            compile(e3) {
              if (!this.vertexShader) {
                o.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
                const e4 = (0, s.getVertexShaderSource)(this.glContext.version);
                this.vertexShader = this.glContext.compileShader(e4, this.glContext.gl.VERTEX_SHADER);
              }
              r.env.debug && o.Logger.verbose("ProrgramManager", `FragShader:
${e3}
`);
              const t2 = this.glContext.compileShader(e3, this.glContext.gl.FRAGMENT_SHADER), n2 = this.glContext.createProgram(this.vertexShader, t2);
              return this.glContext.deleteShader(t2), n2;
            }
            bindOutput(e3) {
              const t2 = e3.width, n2 = e3.height;
              o.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${t2}/${n2}, shape=${e3.shape}, type=${e3.tensor.type}`), this.glContext.attachFramebuffer(e3.texture, t2, n2);
            }
            bindAttributes(e3) {
              const t2 = e3.position, n2 = e3.textureCoord;
              this.glContext.setVertexAttributes(t2, n2), this.attributesBound = true;
            }
            bindUniforms(e3, t2, n2) {
              var r2;
              const o2 = this.glContext.gl;
              let i2 = 0;
              for (const { name: s2, type: a, location: l, arrayLength: c } of e3) {
                const e4 = null === (r2 = t2.find(((e5) => e5.name === s2))) || void 0 === r2 ? void 0 : r2.data;
                if ("sampler2D" !== a && !e4) throw new Error(`variable '${s2}' does not have data defined in program info`);
                switch (a) {
                  case "sampler2D":
                    this.bindTexture(n2[i2], l, i2), i2++;
                    break;
                  case "float":
                    c ? o2.uniform1fv(l, e4) : o2.uniform1f(l, e4);
                    break;
                  case "int":
                    c ? o2.uniform1iv(l, e4) : o2.uniform1i(l, e4);
                    break;
                  default:
                    throw new Error(`Uniform not implemented: ${a}`);
                }
              }
            }
            bindTexture(e3, t2, n2) {
              this.glContext.bindTextureToUniform(e3.texture, n2, t2);
            }
            getAttribLocations(e3) {
              return { position: this.getAttribLocation(e3, "position"), textureCoord: this.getAttribLocation(e3, "textureCoord") };
            }
            getUniformLocations(e3, t2, n2) {
              const r2 = [];
              if (t2) for (const n3 of t2) r2.push({ name: n3, type: "sampler2D", location: this.getUniformLocation(e3, n3) });
              if (n2) for (const t3 of n2) r2.push(Object.assign(Object.assign({}, t3), { location: this.getUniformLocation(e3, t3.name) }));
              return r2;
            }
            getUniformLocation(e3, t2) {
              const n2 = this.glContext.gl.getUniformLocation(e3, t2);
              if (null === n2) throw new Error(`Uniform ${t2} not found.`);
              return n2;
            }
            getAttribLocation(e3, t2) {
              return this.glContext.gl.getAttribLocation(e3, t2);
            }
          };
        }, 6416: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.WebGLSessionHandler = void 0;
          const r = n(6231), o = n(1047), i = n(8316), s = n(1640), a = n(1958), l = n(7859), c = n(5702);
          t.WebGLSessionHandler = class {
            constructor(e3, t2) {
              this.backend = e3, this.context = t2, this.layoutStrategy = new l.PreferLogicalStrategy(e3.glContext.maxTextureSize), this.programManager = new a.ProgramManager(this.context.profiler, e3.glContext, this.layoutStrategy), this.textureManager = new c.TextureManager(e3.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === e3.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = e3.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
            }
            createInferenceHandler() {
              return new i.WebGLInferenceHandler(this);
            }
            onGraphInitialized(e3) {
              const t2 = e3.getValues().filter(((e4) => -1 === e4.from && e4.tensor)).map(((e4) => e4.tensor.dataId));
              this.initializers = new Set(t2);
            }
            isInitializer(e3) {
              return !!this.initializers && this.initializers.has(e3);
            }
            addInitializer(e3) {
              this.initializers.add(e3);
            }
            getTextureData(e3, t2) {
              return t2 ? this.packedTextureDataCache.get(e3) : this.unpackedTextureDataCache.get(e3);
            }
            setTextureData(e3, t2, n2 = false) {
              r.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n2 ? this.packedTextureDataCache.set(e3, t2) : this.unpackedTextureDataCache.set(e3, t2);
            }
            dispose() {
              this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(((e3) => this.textureManager.releaseTexture(e3, true))), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach(((e3) => this.textureManager.releaseTexture(e3, true))), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            resolve(e3, t2, n2) {
              const r2 = (0, o.resolveOperator)(e3, t2, s.WEBGL_OP_RESOLVE_RULES);
              return { impl: r2.opImpl, context: r2.opInit ? r2.opInit(e3, n2) : e3 };
            }
          };
        }, 7769: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.Uint8DataEncoder = t.RGBAFloatDataEncoder = t.RedFloat32DataEncoder = void 0;
          const r = n(6231);
          t.RedFloat32DataEncoder = class {
            constructor(e3, t2 = 1) {
              if (1 === t2) this.internalFormat = e3.R32F, this.format = e3.RED, this.textureType = e3.FLOAT, this.channelSize = t2;
              else {
                if (4 !== t2) throw new Error(`Invalid number of channels: ${t2}`);
                this.internalFormat = e3.RGBA32F, this.format = e3.RGBA, this.textureType = e3.FLOAT, this.channelSize = t2;
              }
            }
            encode(e3, t2) {
              let n2, o;
              return e3.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), o = new Float32Array(e3)), t2 * this.channelSize > e3.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), o = e3, n2 = this.allocate(t2 * this.channelSize), o.forEach(((e4, t3) => n2[t3] = e4))) : (o = e3, n2 = o), n2;
            }
            allocate(e3) {
              return new Float32Array(4 * e3);
            }
            decode(e3, t2) {
              return 1 === this.channelSize ? e3.filter(((e4, t3) => t3 % 4 == 0)).subarray(0, t2) : e3.subarray(0, t2);
            }
          }, t.RGBAFloatDataEncoder = class {
            constructor(e3, t2 = 1, n2) {
              if (1 !== t2 && 4 !== t2) throw new Error(`Invalid number of channels: ${t2}`);
              this.internalFormat = e3.RGBA, this.format = e3.RGBA, this.channelSize = t2, this.textureType = n2 || e3.FLOAT;
            }
            encode(e3, t2) {
              let n2 = e3;
              return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n2 = this.allocate(t2), e3.forEach(((e4, t3) => n2[4 * t3] = e4))), n2;
            }
            allocate(e3) {
              return new Float32Array(4 * e3);
            }
            decode(e3, t2) {
              return 1 === this.channelSize ? e3.filter(((e4, t3) => t3 % 4 == 0)).subarray(0, t2) : e3.subarray(0, t2);
            }
          }, t.Uint8DataEncoder = class {
            constructor(e3, t2 = 1) {
              if (this.channelSize = 4, 1 === t2) this.internalFormat = e3.ALPHA, this.format = e3.ALPHA, this.textureType = e3.UNSIGNED_BYTE, this.channelSize = t2;
              else {
                if (4 !== t2) throw new Error(`Invalid number of channels: ${t2}`);
                this.internalFormat = e3.RGBA, this.format = e3.RGBA, this.textureType = e3.UNSIGNED_BYTE, this.channelSize = t2;
              }
            }
            encode(e3, t2) {
              return new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength);
            }
            allocate(e3) {
              return new Uint8Array(e3 * this.channelSize);
            }
            decode(e3, t2) {
              if (e3 instanceof Uint8Array) return e3.subarray(0, t2);
              throw new Error(`Invalid array type: ${e3.constructor}`);
            }
          };
        }, 7859: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.getBatchDim = t.sizeToSquarishShape = t.getRowsCols = t.sizeFromShape = t.isInt = t.parseAxisParam = t.squeezeShape = t.PreferLogicalStrategy = t.AlwaysKeepOriginalSizeStrategy = void 0;
          const r = n(6231), o = n(2517);
          function i(e3, t2) {
            const n2 = [], r2 = [], o2 = null != t2 && Array.isArray(t2) && 0 === t2.length, i2 = null == t2 || o2 ? null : s(t2, e3).sort();
            let a2 = 0;
            for (let t3 = 0; t3 < e3.length; ++t3) {
              if (null != i2) {
                if (i2[a2] === t3 && 1 !== e3[t3]) throw new Error(`Can't squeeze axis ${t3} since its dim '${e3[t3]}' is not 1`);
                (null == i2[a2] || i2[a2] > t3) && 1 === e3[t3] && (n2.push(e3[t3]), r2.push(t3)), i2[a2] <= t3 && a2++;
              }
              1 !== e3[t3] && (n2.push(e3[t3]), r2.push(t3));
            }
            return { newShape: n2, keptDims: r2 };
          }
          function s(e3, t2) {
            const n2 = t2.length;
            return e3 = null == e3 ? t2.map(((e4, t3) => t3)) : [].concat(e3), (0, o.assert)(e3.every(((e4) => e4 >= -n2 && e4 < n2)), (() => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${e3}`)), (0, o.assert)(e3.every(a), (() => `All values in axis param must be integers but got axis ${e3}`)), e3.map(((e4) => e4 < 0 ? n2 + e4 : e4));
          }
          function a(e3) {
            return e3 % 1 == 0;
          }
          function l(e3) {
            if (0 === e3.length) return 1;
            let t2 = e3[0];
            for (let n2 = 1; n2 < e3.length; n2++) t2 *= e3[n2];
            return t2;
          }
          function c(e3) {
            const t2 = Math.ceil(Math.sqrt(e3));
            return [t2, Math.ceil(e3 / t2)];
          }
          t.AlwaysKeepOriginalSizeStrategy = class {
            constructor(e3) {
              this.maxTextureSize = e3;
            }
            computeTextureWH(e3, t2) {
              if (0 === e3.length) return [1, 1];
              const n2 = this.maxTextureSize;
              if (t2 && void 0 !== t2.breakAxis) {
                const o3 = t2.breakAxis >= e3.length ? 1 : e3.slice(t2.breakAxis).reduce(((e4, t3) => e4 * t3)), i3 = t2.breakAxis <= 0 ? 1 : e3.slice(0, t2.breakAxis).reduce(((e4, t3) => e4 * t3));
                if (!(o3 > n2 || i3 > n2)) return [o3, i3];
                r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e3}, breakAxis:${t2.breakAxis}`);
              }
              const o2 = e3.reduce(((e4, t3) => e4 * t3));
              let i2 = Math.floor(Math.sqrt(o2));
              for (; i2 < n2 && i2 < o2 && o2 % i2 != 0; i2++) ;
              if (i2 >= n2 || o2 % i2 != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${e3}`);
              return [i2, o2 / i2];
            }
          }, t.PreferLogicalStrategy = class {
            constructor(e3) {
              this.maxTextureSize = e3;
            }
            computeTextureWH(e3, t2) {
              const n2 = this.computeTexture(e3, t2);
              return t2 && t2.isPacked && (n2[0] /= 2, n2[1] /= 2), t2 && t2.reverseWH ? [n2[1], n2[0]] : n2;
            }
            computeTexture(e3, t2) {
              const n2 = t2 && t2.isPacked;
              if (0 === e3.length) return n2 ? [2, 2] : [1, 1];
              let o2 = this.maxTextureSize;
              if (t2 && void 0 !== t2.breakAxis) {
                const n3 = t2.breakAxis >= e3.length ? 1 : e3.slice(t2.breakAxis).reduce(((e4, t3) => e4 * t3)), i2 = t2.breakAxis <= 0 ? 1 : e3.slice(0, t2.breakAxis).reduce(((e4, t3) => e4 * t3));
                if (!(n3 > o2 || i2 > o2)) return [n3, i2];
                r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e3}, breakAxis:${t2.breakAxis}`);
              }
              let s2 = e3.slice(0);
              if (n2 && (o2 *= 2, s2 = s2.map(((e4, t3) => t3 >= s2.length - 2 ? s2[t3] % 2 == 0 ? s2[t3] : s2[t3] + 1 : s2[t3])), 1 === s2.length && (s2 = [2, s2[0]])), 2 !== s2.length) {
                const e4 = i(s2);
                s2 = e4.newShape;
              }
              const a2 = l(s2);
              return s2.length <= 1 && a2 <= o2 ? [1, a2] : 2 === s2.length && s2[0] <= o2 && s2[1] <= o2 ? s2 : 3 === s2.length && s2[0] * s2[1] <= o2 && s2[2] <= o2 ? [s2[0] * s2[1], s2[2]] : 3 === s2.length && s2[0] <= o2 && s2[1] * s2[2] <= o2 ? [s2[0], s2[1] * s2[2]] : 4 === s2.length && s2[0] * s2[1] * s2[2] <= o2 && s2[3] <= o2 ? [s2[0] * s2[1] * s2[2], s2[3]] : 4 === s2.length && s2[0] <= o2 && s2[1] * s2[2] * s2[3] <= o2 ? [s2[0], s2[1] * s2[2] * s2[3]] : n2 ? c(a2 / 4).map(((e4) => 2 * e4)) : c(a2);
            }
          }, t.squeezeShape = i, t.parseAxisParam = s, t.isInt = a, t.sizeFromShape = l, t.getRowsCols = function(e3) {
            if (0 === e3.length) throw Error("Cannot get rows and columns of an empty shape array.");
            return [e3.length > 1 ? e3[e3.length - 2] : 1, e3[e3.length - 1]];
          }, t.sizeToSquarishShape = c, t.getBatchDim = function(e3, t2 = 2) {
            return l(e3.slice(0, e3.length - t2));
          };
        }, 4057: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createTextureLayoutFromShape = t.calculateTextureWidthAndHeight = t.createTextureLayoutFromTextureType = void 0;
          const r = n(2517), o = n(2039);
          t.createTextureLayoutFromTextureType = (e3, n2, r2) => {
            const i = r2 === o.TextureType.unpacked || r2 === o.TextureType.unpackedReversed ? 1 : 4, s = r2 === o.TextureType.packed, a = r2 === o.TextureType.unpackedReversed || r2 === o.TextureType.packed, l = r2 === o.TextureType.packedLastDimension ? n2.length - 1 : void 0, c = r2 === o.TextureType.packedLastDimension ? n2.map(((e4, t2) => t2 === n2.length - 1 ? 4 * e4 : e4)) : void 0;
            return (0, t.createTextureLayoutFromShape)(e3, n2, i, c, { isPacked: s, reverseWH: a, breakAxis: l });
          }, t.calculateTextureWidthAndHeight = (e3, n2, r2) => {
            const o2 = (0, t.createTextureLayoutFromTextureType)(e3, n2, r2);
            return [o2.width, o2.height];
          }, t.createTextureLayoutFromShape = (e3, t2, n2 = 1, o2, i) => {
            const s = !(!i || !i.isPacked), [a, l] = e3.computeTextureWH(s && o2 || t2, i), c = t2.length;
            let u = t2.slice(0);
            if (0 === c && (u = [1]), 1 === n2) o2 = t2;
            else if (s) {
              if (4 !== n2) throw new Error("a packed texture must be 4-channel");
              o2 = t2, c > 0 && (u[c - 1] = Math.ceil(u[c - 1] / 2)), c > 1 && (u[c - 2] = Math.ceil(u[c - 2] / 2));
            } else if (!o2) throw new Error("Unpacked shape is needed when using channels > 1");
            return { width: a, height: l, channels: n2, isPacked: s, shape: u, strides: r.ShapeUtil.computeStrides(u), unpackedShape: o2, reversedWH: i && i.reverseWH };
          };
        }, 5702: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.TextureManager = void 0;
          const r = n(6231);
          t.TextureManager = class {
            constructor(e3, t2, n2, r2) {
              this.glContext = e3, this.layoutStrategy = t2, this.profiler = n2, this.config = r2, this.pendingRead = /* @__PURE__ */ new Map(), r2.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
            }
            createTextureFromLayout(e3, t2, n2, o) {
              const i = this.toEncoderType(e3), s = this.glContext.getEncoder(i, t2.channels || 1, o);
              if (t2.isPacked && 1 === o) throw new Error("not implemented");
              const a = t2.width, l = t2.height;
              let c, u;
              if (this.config.reuseTextures) {
                c = `${a}x${l}_${s.format}_${s.internalFormat}_${s.textureType}`, u = this.inUseTextures.get(c), u || (u = [], this.inUseTextures.set(c, u));
                const t3 = this.idleTextures.get(c);
                if (t3 && t3.length > 0) {
                  const r2 = t3.pop();
                  return u.push(r2), 1 === o && this.glContext.updateTexture(r2, a, l, s, this.toTextureData(e3, n2)), r2;
                }
              }
              r.Logger.verbose("TextureManager", `Creating new texture of size ${t2.width}x${t2.height}`);
              const p = this.glContext.allocateTexture(a, l, s, this.toTextureData(e3, n2));
              return this.config.reuseTextures && (u.push(p), this.textureLookup.set(p, c)), p;
            }
            readTexture(e3, t2, n2) {
              return n2 || (n2 = 1), this.profiler.event("backend", "TextureManager.readTexture", (() => {
                const r2 = e3.shape.reduce(((e4, t3) => e4 * t3)) * n2, o = this.glContext.readTexture(e3.texture, e3.width, e3.height, r2, this.toEncoderType(t2), n2);
                return this.toTensorData(t2, o);
              }));
            }
            async readTextureAsync(e3, t2, n2) {
              const r2 = e3.tensor.dataId;
              if (n2 || (n2 = 1), this.pendingRead.has(r2)) {
                const e4 = this.pendingRead.get(r2);
                return new Promise(((t3) => null == e4 ? void 0 : e4.push(t3)));
              }
              return this.profiler.event("backend", "TextureManager.readTextureAsync", (async () => {
                this.pendingRead.set(r2, []);
                const o = e3.shape.reduce(((e4, t3) => e4 * t3)) * n2;
                await this.glContext.createAndWaitForFence();
                const i = this.glContext.readTexture(e3.texture, e3.width, e3.height, o, this.toEncoderType(t2), n2), s = this.toTensorData(t2, i), a = this.pendingRead.get(r2);
                return this.pendingRead.delete(r2), null == a || a.forEach(((e4) => e4(s))), s;
              }));
            }
            readUint8TextureAsFloat(e3) {
              return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", (() => {
                const t2 = e3.shape.reduce(((e4, t3) => e4 * t3)), n2 = this.glContext.readTexture(e3.texture, e3.width, e3.height, 4 * t2, "byte", 4);
                return new Float32Array(n2.buffer, n2.byteOffset, t2);
              }));
            }
            releaseTexture(e3, t2) {
              let n2;
              if (this.config.reuseTextures && (n2 = this.textureLookup.get(e3.texture), n2)) {
                t2 && this.textureLookup.delete(n2);
                const r2 = this.inUseTextures.get(n2);
                if (r2) {
                  const t3 = r2.indexOf(e3.texture);
                  if (-1 !== t3) {
                    r2.splice(t3, 1);
                    let o = this.idleTextures.get(n2);
                    o || (o = [], this.idleTextures.set(n2, o)), o.push(e3.texture);
                  }
                }
              }
              n2 && !t2 || (r.Logger.verbose("TextureManager", `Deleting texture of size ${e3.width}x${e3.height}`), this.glContext.deleteTexture(e3.texture));
            }
            toTensorData(e3, t2) {
              switch (e3) {
                case "int16":
                  return t2 instanceof Int16Array ? t2 : Int16Array.from(t2);
                case "int32":
                  return t2 instanceof Int32Array ? t2 : Int32Array.from(t2);
                case "int8":
                  return t2 instanceof Int8Array ? t2 : Int8Array.from(t2);
                case "uint16":
                  return t2 instanceof Uint16Array ? t2 : Uint16Array.from(t2);
                case "uint32":
                  return t2 instanceof Uint32Array ? t2 : Uint32Array.from(t2);
                case "uint8":
                case "bool":
                  return t2 instanceof Uint8Array ? t2 : Uint8Array.from(t2);
                case "float32":
                  return t2 instanceof Float32Array ? t2 : Float32Array.from(t2);
                case "float64":
                  return t2 instanceof Float64Array ? t2 : Float64Array.from(t2);
                default:
                  throw new Error(`TensorData type ${e3} is not supported`);
              }
            }
            toTextureData(e3, t2) {
              if (t2) return t2 instanceof Float32Array ? t2 : new Float32Array(t2);
            }
            toEncoderType(e3) {
              return "float";
            }
            clearActiveTextures() {
              this.glContext.clearActiveTextures();
            }
          };
        }, 2039: (e2, t) => {
          var n;
          Object.defineProperty(t, "__esModule", { value: true }), t.TextureType = void 0, (n = t.TextureType || (t.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
        }, 9390: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.getGlChannels = t.getCoordsDataType = t.getSqueezedParams = t.squeezeInputShape = t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = t.generateShaderFuncNameFromInputSamplerName = t.repeatedTry = t.getPackedShape = void 0;
          const r = n(2517);
          t.getPackedShape = function(e3) {
            const t2 = e3.length;
            return e3.slice(0, t2 - 1).concat(e3[t2 - 1] / 4);
          }, t.repeatedTry = async function(e3, t2 = ((e4) => 0), n2) {
            return new Promise(((r2, o) => {
              let i = 0;
              const s = () => {
                if (e3()) return void r2();
                i++;
                const a = t2(i);
                null != n2 && i >= n2 ? o() : setTimeout(s, a);
              };
              s();
            }));
          }, t.generateShaderFuncNameFromInputSamplerName = function(e3) {
            return (0, r.assert)(void 0 !== e3 && 0 !== e3.length, (() => "empty string found for sampler name")), "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
          }, t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(e3) {
            return (0, r.assert)(void 0 !== e3 && 0 !== e3.length, (() => "empty string found for sampler name")), "get" + e3.charAt(0).toUpperCase() + e3.slice(1) + "AtOutCoords";
          }, t.squeezeInputShape = function(e3, t2) {
            let n2 = JSON.parse(JSON.stringify(e3));
            return n2 = t2, n2;
          }, t.getSqueezedParams = function(e3, t2) {
            return t2.map(((t3) => e3[t3])).join(", ");
          }, t.getCoordsDataType = function(e3) {
            if (e3 <= 1) return "int";
            if (2 === e3) return "ivec2";
            if (3 === e3) return "ivec3";
            if (4 === e3) return "ivec4";
            if (5 === e3) return "ivec5";
            if (6 === e3) return "ivec6";
            throw Error(`GPU for rank ${e3} is not yet supported`);
          }, t.getGlChannels = function(e3 = 6) {
            return ["x", "y", "z", "w", "u", "v"].slice(0, e3);
          };
        }, 7305: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.createNewWebGLContext = t.createWebGLContext = void 0;
          const r = n(6231), o = n(1713), i = {};
          function s(e3) {
            const t2 = (function() {
              if ("undefined" == typeof document) {
                if ("undefined" == typeof OffscreenCanvas) throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");
                return new OffscreenCanvas(1, 1);
              }
              const e4 = document.createElement("canvas");
              return e4.width = 1, e4.height = 1, e4;
            })();
            let n2;
            const i2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
            if ((!e3 || "webgl2" === e3) && (n2 = t2.getContext("webgl2", i2), n2)) try {
              return new o.WebGLContext(n2, 2);
            } catch (e4) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${e4}`);
            }
            if ((!e3 || "webgl" === e3) && (n2 = t2.getContext("webgl", i2) || t2.getContext("experimental-webgl", i2), n2)) try {
              return new o.WebGLContext(n2, 1);
            } catch (e4) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e4}`);
            }
            throw new Error("WebGL is not supported");
          }
          t.createWebGLContext = function e3(t2) {
            let n2;
            t2 && "webgl2" !== t2 || !("webgl2" in i) ? t2 && "webgl" !== t2 || !("webgl" in i) || (n2 = i.webgl) : n2 = i.webgl2, n2 = n2 || s(t2), t2 = t2 || 1 === n2.version ? "webgl" : "webgl2";
            const r2 = n2.gl;
            return i[t2] = n2, r2.isContextLost() ? (delete i[t2], e3(t2)) : (r2.disable(r2.DEPTH_TEST), r2.disable(r2.STENCIL_TEST), r2.disable(r2.BLEND), r2.disable(r2.DITHER), r2.disable(r2.POLYGON_OFFSET_FILL), r2.disable(r2.SAMPLE_COVERAGE), r2.enable(r2.SCISSOR_TEST), r2.enable(r2.CULL_FACE), r2.cullFace(r2.BACK), n2);
          }, t.createNewWebGLContext = s;
        }, 1713: function(e2, t, n) {
          var r = this && this.__createBinding || (Object.create ? function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var o2 = Object.getOwnPropertyDescriptor(t2, n2);
            o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
              return t2[n2];
            } }), Object.defineProperty(e3, r2, o2);
          } : function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2), e3[r2] = t2[n2];
          }), o = this && this.__setModuleDefault || (Object.create ? function(e3, t2) {
            Object.defineProperty(e3, "default", { enumerable: true, value: t2 });
          } : function(e3, t2) {
            e3.default = t2;
          }), i = this && this.__importStar || function(e3) {
            if (e3 && e3.__esModule) return e3;
            var t2 = {};
            if (null != e3) for (var n2 in e3) "default" !== n2 && Object.prototype.hasOwnProperty.call(e3, n2) && r(t2, e3, n2);
            return o(t2, e3), t2;
          };
          Object.defineProperty(t, "__esModule", { value: true }), t.WebGLContext = t.linearSearchLastTrue = void 0;
          const s = n(1670), a = i(n(7769)), l = n(9390);
          function c(e3) {
            let t2 = 0;
            for (; t2 < e3.length && e3[t2](); ++t2) ;
            return t2 - 1;
          }
          t.linearSearchLastTrue = c, t.WebGLContext = class {
            constructor(e3, t2) {
              this.frameBufferBound = false, this.itemsToPoll = [], this.gl = e3, this.version = t2, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
            }
            allocateTexture(e3, t2, n2, r2) {
              const o2 = this.gl, i2 = o2.createTexture();
              o2.bindTexture(o2.TEXTURE_2D, i2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.NEAREST), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.NEAREST), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE);
              const s2 = r2 ? n2.encode(r2, e3 * t2) : null;
              return o2.texImage2D(o2.TEXTURE_2D, 0, n2.internalFormat, e3, t2, 0, n2.format, n2.textureType, s2), this.checkError(), i2;
            }
            updateTexture(e3, t2, n2, r2, o2) {
              const i2 = this.gl;
              i2.bindTexture(i2.TEXTURE_2D, e3);
              const s2 = r2.encode(o2, t2 * n2);
              i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, t2, n2, r2.format, r2.textureType, s2), this.checkError();
            }
            attachFramebuffer(e3, t2, n2) {
              const r2 = this.gl;
              r2.bindTexture(r2.TEXTURE_2D, e3), r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer), r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.COLOR_ATTACHMENT0, r2.TEXTURE_2D, e3, 0), this.checkError(), r2.viewport(0, 0, t2, n2), r2.scissor(0, 0, t2, n2);
            }
            readTexture(e3, t2, n2, r2, o2, i2) {
              const s2 = this.gl;
              i2 || (i2 = 1), this.frameBufferBound || this.attachFramebuffer(e3, t2, n2);
              const a2 = this.getEncoder(o2, i2), l2 = a2.allocate(t2 * n2);
              return s2.bindTexture(s2.TEXTURE_2D, e3), s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.TEXTURE_2D, e3, 0), s2.readPixels(0, 0, t2, n2, s2.RGBA, a2.textureType, l2), this.checkError(), a2.decode(l2, r2);
            }
            isFramebufferReady() {
              return true;
            }
            getActiveTexture() {
              const e3 = this.gl;
              return "TEXTURE" + (e3.getParameter(this.gl.ACTIVE_TEXTURE) - e3.TEXTURE0);
            }
            getTextureBinding() {
              return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
            }
            getFramebufferBinding() {
              return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
            }
            setVertexAttributes(e3, t2) {
              const n2 = this.gl;
              n2.vertexAttribPointer(e3, 3, n2.FLOAT, false, 20, 0), n2.enableVertexAttribArray(e3), -1 !== t2 && (n2.vertexAttribPointer(t2, 2, n2.FLOAT, false, 20, 12), n2.enableVertexAttribArray(t2)), this.checkError();
            }
            createProgram(e3, t2) {
              const n2 = this.gl, r2 = n2.createProgram();
              return n2.attachShader(r2, e3), n2.attachShader(r2, t2), n2.linkProgram(r2), r2;
            }
            compileShader(e3, t2) {
              const n2 = this.gl, r2 = n2.createShader(t2);
              if (!r2) throw new Error(`createShader() returned null with type ${t2}`);
              if (n2.shaderSource(r2, e3), n2.compileShader(r2), false === n2.getShaderParameter(r2, n2.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n2.getShaderInfoLog(r2)}
Shader source:
${e3}`);
              return r2;
            }
            deleteShader(e3) {
              this.gl.deleteShader(e3);
            }
            bindTextureToUniform(e3, t2, n2) {
              const r2 = this.gl;
              r2.activeTexture(r2.TEXTURE0 + t2), this.checkError(), r2.bindTexture(r2.TEXTURE_2D, e3), this.checkError(), r2.uniform1i(n2, t2), this.checkError();
            }
            draw() {
              this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
            }
            checkError() {
              if (s.env.debug) {
                const e3 = this.gl, t2 = e3.getError();
                let n2 = "";
                switch (t2) {
                  case e3.NO_ERROR:
                    return;
                  case e3.INVALID_ENUM:
                    n2 = "INVALID_ENUM";
                    break;
                  case e3.INVALID_VALUE:
                    n2 = "INVALID_VALUE";
                    break;
                  case e3.INVALID_OPERATION:
                    n2 = "INVALID_OPERATION";
                    break;
                  case e3.INVALID_FRAMEBUFFER_OPERATION:
                    n2 = "INVALID_FRAMEBUFFER_OPERATION";
                    break;
                  case e3.OUT_OF_MEMORY:
                    n2 = "OUT_OF_MEMORY";
                    break;
                  case e3.CONTEXT_LOST_WEBGL:
                    n2 = "CONTEXT_LOST_WEBGL";
                    break;
                  default:
                    n2 = `Unknown WebGL Error: ${t2.toString(16)}`;
                }
                throw new Error(n2);
              }
            }
            deleteTexture(e3) {
              this.gl.deleteTexture(e3);
            }
            deleteProgram(e3) {
              this.gl.deleteProgram(e3);
            }
            getEncoder(e3, t2, n2 = 0) {
              if (2 === this.version) return new a.RedFloat32DataEncoder(this.gl, t2);
              switch (e3) {
                case "float":
                  return 1 === n2 || this.isRenderFloat32Supported ? new a.RGBAFloatDataEncoder(this.gl, t2) : new a.RGBAFloatDataEncoder(this.gl, t2, this.textureHalfFloatExtension.HALF_FLOAT_OES);
                case "int":
                  throw new Error("not implemented");
                case "byte":
                  return new a.Uint8DataEncoder(this.gl, t2);
                default:
                  throw new Error(`Invalid dataType: ${e3}`);
              }
            }
            clearActiveTextures() {
              const e3 = this.gl;
              for (let t2 = 0; t2 < this.maxTextureImageUnits; ++t2) e3.activeTexture(e3.TEXTURE0 + t2), e3.bindTexture(e3.TEXTURE_2D, null);
            }
            dispose() {
              if (this.disposed) return;
              const e3 = this.gl;
              e3.bindFramebuffer(e3.FRAMEBUFFER, null), e3.deleteFramebuffer(this.framebuffer), e3.bindBuffer(e3.ARRAY_BUFFER, null), e3.deleteBuffer(this.vertexbuffer), e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, null), e3.finish(), this.disposed = true;
            }
            createDefaultGeometry() {
              return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
            }
            createVertexbuffer() {
              const e3 = this.gl, t2 = e3.createBuffer();
              if (!t2) throw new Error("createBuffer() returned null");
              const n2 = this.createDefaultGeometry();
              return e3.bindBuffer(e3.ARRAY_BUFFER, t2), e3.bufferData(e3.ARRAY_BUFFER, n2, e3.STATIC_DRAW), this.checkError(), t2;
            }
            createFramebuffer() {
              const e3 = this.gl.createFramebuffer();
              if (!e3) throw new Error("createFramebuffer returned null");
              return e3;
            }
            queryVitalParameters() {
              const e3 = this.gl;
              if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error("both float32 and float16 TextureType are not supported");
              this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e3.getParameter(e3.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e3.getParameter(e3.MAX_TEXTURE_IMAGE_UNITS), this.version;
            }
            getExtensions() {
              2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
            }
            checkFloatTextureAttachableToFrameBuffer() {
              const e3 = this.gl, t2 = e3.createTexture();
              e3.bindTexture(e3.TEXTURE_2D, t2);
              const n2 = 2 === this.version ? e3.RGBA32F : e3.RGBA;
              e3.texImage2D(e3.TEXTURE_2D, 0, n2, 1, 1, 0, e3.RGBA, e3.FLOAT, null);
              const r2 = e3.createFramebuffer();
              e3.bindFramebuffer(e3.FRAMEBUFFER, r2), e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t2, 0);
              const o2 = e3.checkFramebufferStatus(e3.FRAMEBUFFER) === e3.FRAMEBUFFER_COMPLETE;
              return e3.bindTexture(e3.TEXTURE_2D, null), e3.bindFramebuffer(e3.FRAMEBUFFER, null), e3.deleteTexture(t2), e3.deleteFramebuffer(r2), o2;
            }
            checkRenderFloat32() {
              if (2 === this.version) {
                if (!this.colorBufferFloatExtension) return false;
              } else if (!this.textureFloatExtension) return false;
              return this.isFloatTextureAttachableToFrameBuffer;
            }
            checkFloat32Download() {
              if (2 === this.version) {
                if (!this.colorBufferFloatExtension) return false;
              } else {
                if (!this.textureFloatExtension) return false;
                if (!this.gl.getExtension("WEBGL_color_buffer_float")) return false;
              }
              return this.isFloatTextureAttachableToFrameBuffer;
            }
            checkFloat32Blend() {
              const e3 = this.gl;
              let t2, n2, r2, o2, i2;
              try {
                t2 = e3.createTexture(), n2 = e3.createFramebuffer(), e3.bindTexture(e3.TEXTURE_2D, t2);
                const s2 = 2 === this.version ? e3.RGBA32F : e3.RGBA;
                return e3.texImage2D(e3.TEXTURE_2D, 0, s2, 1, 1, 0, e3.RGBA, e3.FLOAT, null), e3.bindFramebuffer(e3.FRAMEBUFFER, n2), e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t2, 0), e3.enable(e3.BLEND), r2 = e3.createShader(e3.VERTEX_SHADER), !!r2 && (e3.shaderSource(r2, "void main(){}"), e3.compileShader(r2), o2 = e3.createShader(e3.FRAGMENT_SHADER), !!o2 && (e3.shaderSource(o2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), e3.compileShader(o2), i2 = e3.createProgram(), !!i2 && (e3.attachShader(i2, r2), e3.attachShader(i2, o2), e3.linkProgram(i2), e3.useProgram(i2), e3.drawArrays(e3.POINTS, 0, 1), e3.getError() === e3.NO_ERROR)));
              } finally {
                e3.disable(e3.BLEND), i2 && e3.deleteProgram(i2), r2 && e3.deleteShader(r2), o2 && e3.deleteShader(o2), n2 && (e3.bindFramebuffer(e3.FRAMEBUFFER, null), e3.deleteFramebuffer(n2)), t2 && (e3.bindTexture(e3.TEXTURE_2D, null), e3.deleteTexture(t2));
              }
            }
            beginTimer() {
              if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
                const e3 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension, n2 = e3.createQuery();
                return e3.beginQuery(t2.TIME_ELAPSED_EXT, n2), n2;
              }
              throw new Error("WebGL1 profiling currently not supported.");
            }
            endTimer() {
              if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
              {
                const e3 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension;
                e3.endQuery(t2.TIME_ELAPSED_EXT);
              }
            }
            isTimerResultAvailable(e3) {
              let t2 = false, n2 = false;
              if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
              {
                const r2 = this.gl, o2 = this.disjointTimerQueryWebgl2Extension;
                t2 = r2.getQueryParameter(e3, r2.QUERY_RESULT_AVAILABLE), n2 = r2.getParameter(o2.GPU_DISJOINT_EXT);
              }
              return t2 && !n2;
            }
            getTimerResult(e3) {
              let t2 = 0;
              if (2 !== this.version) throw new Error("WebGL1 profiling currently not supported");
              {
                const n2 = this.gl;
                t2 = n2.getQueryParameter(e3, n2.QUERY_RESULT), n2.deleteQuery(e3);
              }
              return t2 / 1e6;
            }
            async waitForQueryAndGetTime(e3) {
              return await (0, l.repeatedTry)((() => this.isTimerResultAvailable(e3))), this.getTimerResult(e3);
            }
            async createAndWaitForFence() {
              const e3 = this.createFence(this.gl);
              return this.pollFence(e3);
            }
            createFence(e3) {
              let t2;
              const n2 = e3, r2 = n2.fenceSync(n2.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return e3.flush(), t2 = null === r2 ? () => true : () => {
                const e4 = n2.clientWaitSync(r2, 0, 0);
                return e4 === n2.ALREADY_SIGNALED || e4 === n2.CONDITION_SATISFIED;
              }, { query: r2, isFencePassed: t2 };
            }
            async pollFence(e3) {
              return new Promise(((t2) => {
                this.addItemToPoll((() => e3.isFencePassed()), (() => t2()));
              }));
            }
            pollItems() {
              const e3 = c(this.itemsToPoll.map(((e4) => e4.isDoneFn)));
              for (let t2 = 0; t2 <= e3; ++t2) {
                const { resolveFn: e4 } = this.itemsToPoll[t2];
                e4();
              }
              this.itemsToPoll = this.itemsToPoll.slice(e3 + 1);
            }
            async addItemToPoll(e3, t2) {
              this.itemsToPoll.push({ isDoneFn: e3, resolveFn: t2 }), this.itemsToPoll.length > 1 || await (0, l.repeatedTry)((() => (this.pollItems(), 0 === this.itemsToPoll.length)));
            }
          };
        }, 1036: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.ExecutionPlan = void 0;
          const r = n(6231);
          class o {
            constructor(e3, t2) {
              this.op = e3, this.node = t2;
            }
          }
          t.ExecutionPlan = class {
            constructor(e3, t2, n2) {
              this.graph = e3, this.profiler = n2, this.initialize(t2);
            }
            initialize(e3) {
              this.profiler.event("session", "ExecutionPlan.initialize", (() => {
                const t2 = this.graph.getNodes();
                if (t2.length !== e3.length) throw new Error("The size of nodes and OPs do not match.");
                this._ops = e3.map(((e4, n2) => new o(e4, t2[n2]))), this.reset(), this._starter = [], this._ops.forEach(((e4, t3) => {
                  let n2 = true;
                  for (const t4 of e4.node.inputs) if (!this._values[t4] && -1 === this.graph.getInputIndices().indexOf(t4)) {
                    n2 = false;
                    break;
                  }
                  n2 && this._starter.push(t3);
                }));
              }));
            }
            reset() {
              this._values = this.graph.getValues().map(((e3) => e3.tensor));
            }
            async execute(e3, t2) {
              return this.profiler.event("session", "ExecutionPlan.execute", (async () => {
                this.reset();
                const n2 = e3.createInferenceHandler(), o2 = this.graph.getInputIndices();
                if (t2.length !== o2.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t2.length} expected: ${o2.length}`);
                t2.forEach(((e4, t3) => {
                  const n3 = o2[t3];
                  this._values[n3] = e4;
                }));
                const i = this._starter.slice(0), s = this.graph.getValues(), a = this.graph.getNodes();
                let l = 0;
                for (; l < i.length; ) {
                  const e4 = i[l++], t3 = this._ops[e4], o3 = t3.node.inputs.map(((e5) => this._values[e5]));
                  if (-1 !== o3.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${t3.node}`);
                  const c2 = o3;
                  r.Logger.verbose("ExecPlan", `Runing op:${t3.node.name} (${c2.map(((e5, n3) => `'${t3.node.inputs[n3]}': ${e5.type}[${e5.dims.join(",")}]`)).join(", ")})`);
                  const u = await this.profiler.event("node", t3.node.name, (async () => t3.op.impl(n2, c2, t3.op.context)));
                  if (u.length !== t3.node.outputs.length) throw new Error("the size of output does not match model definition.");
                  u.forEach(((e5, n3) => {
                    const r2 = t3.node.outputs[n3];
                    if (this._values[r2]) throw new Error(`output [${r2}] already has value: op:${t3.node.name}`);
                    this._values[r2] = e5;
                  }));
                  const p = /* @__PURE__ */ new Set();
                  u.forEach(((e5, n3) => {
                    const r2 = t3.node.outputs[n3];
                    for (const e6 of s[r2].to) {
                      const t4 = a[e6];
                      let n4 = true;
                      for (const e7 of t4.inputs) if (!this._values[e7]) {
                        n4 = false;
                        break;
                      }
                      n4 && p.add(e6);
                    }
                  })), i.push(...p);
                }
                const c = [];
                for (let e4 = 0; e4 < this.graph.getOutputIndices().length; e4++) {
                  const t3 = this.graph.getOutputIndices()[e4], n3 = this._values[t3];
                  if (void 0 === n3) throw new Error(`required output [${t3}] does not have value`);
                  0 === t3 ? await n3.getData() : n3.data, c.push(n3);
                }
                return r.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n2.dispose(), c;
              }));
            }
          };
        }, 7070: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.Graph = void 0;
          const r = n(1446), o = n(7778), i = n(9395), s = n(9162), a = n(2517);
          var l = i.onnxruntime.experimental.fbs;
          t.Graph = { from: (e3, t2) => new p(e3, t2) };
          class c {
            constructor(e3) {
              this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e3 && (this.type = a.ProtoUtil.tensorValueTypeFromProto(e3.type.tensorType));
            }
            get from() {
              return this._from;
            }
            get to() {
              return this._to;
            }
          }
          class u {
            constructor(e3, t2) {
              e3 instanceof r.onnx.NodeProto ? (this.name = e3.name, this.opType = e3.opType, this.attributes = new o.Attribute(e3.attribute)) : e3 instanceof l.Node && (this.name = null != t2 ? t2 : e3.name(), this.opType = e3.opType(), this.attributes = new o.Attribute(a.ProtoUtil.tensorAttributesFromORTFormat(e3))), this.inputs = [], this.outputs = [], this.executeNode = true;
            }
          }
          class p {
            constructor(e3, t2) {
              if (!e3) throw new TypeError("graph is empty");
              this.buildGraph(e3), this.transformGraph(t2), this.checkIsAcyclic();
            }
            getInputIndices() {
              return this._allInputIndices;
            }
            getInputNames() {
              return this._allInputNames;
            }
            getOutputIndices() {
              return this._allOutputIndices;
            }
            getOutputNames() {
              return this._allOutputNames;
            }
            getValues() {
              return this._allData;
            }
            getNodes() {
              return this._nodes;
            }
            buildGraph(e3) {
              if (e3 instanceof r.onnx.GraphProto) this.buildGraphFromOnnxFormat(e3);
              else {
                if (!(e3 instanceof l.Graph)) throw new TypeError("Graph type is not supported.");
                this.buildGraphFromOrtFormat(e3);
              }
            }
            buildGraphFromOnnxFormat(e3) {
              const t2 = /* @__PURE__ */ new Map();
              this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
              const n2 = /* @__PURE__ */ new Map();
              if (!e3.input) throw new Error("missing information in graph: input");
              const r2 = [];
              for (const n3 of e3.input) {
                if (t2.has(n3.name)) throw new Error(`duplicated input name: ${n3.name}`);
                const e4 = this._allData.push(new c(n3)) - 1;
                t2.set(n3.name, e4), r2.push(n3.name);
              }
              if (!e3.initializer) throw new Error("missing information in graph: initializer");
              for (const n3 of e3.initializer) {
                let e4 = t2.get(n3.name);
                if (void 0 === e4) {
                  const r3 = new c();
                  r3.type = { shape: { dims: a.ProtoUtil.tensorDimsFromProto(n3.dims) }, tensorType: a.ProtoUtil.tensorDataTypeFromProto(n3.dataType) }, e4 = this._allData.push(r3) - 1, t2.set(n3.name, e4);
                }
                this._allData[e4]._from = -1, this._allData[e4].tensor = s.Tensor.fromProto(n3);
              }
              for (let e4 = 0; e4 < this._allData.length; e4++) this._allData[e4].tensor || (this._allInputIndices.push(e4), this._allInputNames.push(r2[e4]));
              if (!e3.output) throw new Error("missing information in graph: output");
              for (const n3 of e3.output) {
                if (t2.has(n3.name)) throw new Error(`duplicated output name: ${n3.name}`);
                const e4 = this._allData.push(new c(n3)) - 1;
                t2.set(n3.name, e4), this._allOutputIndices.push(e4), this._allOutputNames.push(n3.name);
              }
              if (!e3.node) throw new Error("missing information in graph: node");
              for (const t3 of e3.node) {
                if (!t3.name) for (let e5 = 0; ; e5++) {
                  const r3 = `unnamed_${t3.opType}_${e5}`;
                  if (!n2.has(r3)) {
                    t3.name = r3;
                    break;
                  }
                }
                if (n2.has(t3.name)) throw new Error(`duplicated node name: ${t3.name}`);
                const e4 = this._nodes.push(new u(t3)) - 1;
                n2.set(t3.name, e4);
              }
              for (let n3 = 0; n3 < this._nodes.length; n3++) {
                const r3 = this._nodes[n3], o2 = e3.node[n3];
                if (!o2.output) throw new Error(`missing output for node: ${o2.name}`);
                for (const e4 of o2.output) {
                  let i2 = t2.get(e4);
                  if (void 0 === i2 && (i2 = this._allData.push(new c()) - 1, t2.set(e4, i2)), r3.outputs.push(i2), void 0 !== this._allData[i2]._from) throw new Error(`multiple nodes output to one data value: ${i2}`);
                  if (this._allData[i2]._from = n3, "Constant" === o2.opType) {
                    if (!o2.attribute || 1 !== o2.attribute.length || !o2.attribute[0].t) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                    if (!o2.output || 1 !== o2.output.length) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                    r3.outputs.pop(), r3.executeNode = false, this._allData[i2]._from = -1, this._allData[i2].tensor = s.Tensor.fromProto(o2.attribute[0].t);
                  }
                }
              }
              for (let n3 = 0; n3 < this._nodes.length; n3++) {
                const r3 = this._nodes[n3], o2 = e3.node[n3];
                if (!o2.input) throw new Error(`missing input for node: ${o2.name}`);
                for (const e4 of o2.input) {
                  const i2 = t2.get(e4);
                  if (void 0 === i2) {
                    if ("" === e4 && 3 === o2.input.length && "Resize" === o2.opType) continue;
                    throw new Error(`unrecognized input '${e4}' for node: ${o2.name}`);
                  }
                  r3.inputs.push(i2), this._allData[i2]._to.push(n3);
                }
              }
              return true;
            }
            buildGraphFromOrtFormat(e3) {
              var t2, n2, r2;
              const o2 = /* @__PURE__ */ new Map();
              this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
              const i2 = /* @__PURE__ */ new Map(), p2 = [];
              for (let i3 = 0; i3 < e3.inputsLength(); i3++) {
                const s2 = e3.inputs(i3);
                if (o2.has(s2)) throw new Error(`duplicated input name: ${s2}`);
                for (let i4 = 0; i4 < e3.nodeArgsLength(); i4++) if ((null === (t2 = e3.nodeArgs(i4)) || void 0 === t2 ? void 0 : t2.name()) === s2) {
                  const t3 = new c();
                  if ((null === (r2 = null === (n2 = e3.nodeArgs(i4)) || void 0 === n2 ? void 0 : n2.type()) || void 0 === r2 ? void 0 : r2.valueType()) !== l.TypeInfoValue.tensor_type) throw new Error("Unexpected value type for the nodeArg.");
                  const u2 = e3.nodeArgs(i4).type().value(new l.TensorTypeAndShape()), d = a.ProtoUtil.tensorDataTypeFromProto(u2.elemType()), _ = u2.shape(), h = [];
                  for (let e4 = 0; e4 < _.dimLength(); e4++) h.push(a.LongUtil.longToNumber(_.dim(e4).value().dimValue()));
                  t3.type = { shape: { dims: h }, tensorType: d };
                  const f = this._allData.push(t3) - 1;
                  o2.set(s2, f), p2.push(s2);
                }
              }
              for (let t3 = 0; t3 < e3.initializersLength(); t3++) {
                const n3 = e3.initializers(t3);
                let r3 = o2.get(n3.name());
                if (void 0 === r3) {
                  const e4 = new c(), t4 = a.ProtoUtil.tensorDimsFromORTFormat(n3), i3 = a.ProtoUtil.tensorDataTypeFromProto(n3.dataType());
                  e4.type = { shape: { dims: t4 }, tensorType: i3 }, r3 = this._allData.push(e4) - 1, o2.set(n3.name(), r3);
                }
                this._allData[r3]._from = -1, this._allData[r3].tensor = s.Tensor.fromOrtTensor(n3);
              }
              for (let e4 = 0; e4 < this._allData.length; e4++) this._allData[e4].tensor || (this._allInputIndices.push(e4), this._allInputNames.push(p2[e4]));
              for (let t3 = 0; t3 < e3.outputsLength(); t3++) {
                const n3 = e3.outputs(t3);
                if (o2.has(n3)) throw new Error(`duplicated output name: ${n3}`);
                const r3 = this._allData.push(new c()) - 1;
                o2.set(n3, r3), this._allOutputIndices.push(r3), this._allOutputNames.push(n3);
              }
              if (!e3.nodes) throw new Error("missing information in graph: node");
              for (let t3 = 0; t3 < e3.nodesLength(); t3++) {
                const n3 = e3.nodes(t3);
                let r3 = n3.name();
                if (!r3) for (let e4 = 0; r3 = `unnamed_${n3.opType()}_${e4}`, i2.has(r3); e4++) ;
                if (i2.has(r3)) throw new Error(`duplicated node name: ${r3}`);
                const o3 = this._nodes.push(new u(n3, r3)) - 1;
                i2.set(r3, o3);
              }
              for (let t3 = 0; t3 < this._nodes.length; t3++) {
                const n3 = this._nodes[t3], r3 = e3.nodes(t3);
                if (null == r3) throw new Error(`No node exists at index ${t3}`);
                if (0 === (null == r3 ? void 0 : r3.outputsLength())) throw new Error(`missing output for node: ${r3.name}`);
                for (let e4 = 0; e4 < (null == r3 ? void 0 : r3.outputsLength()); e4++) {
                  const i3 = null == r3 ? void 0 : r3.outputs(e4);
                  let a2 = o2.get(i3);
                  if (void 0 === a2 && (a2 = this._allData.push(new c()) - 1, o2.set(i3, a2)), n3.outputs.push(a2), void 0 !== this._allData[a2]._from) throw new Error(`multiple nodes output to one data value: ${a2}`);
                  if (this._allData[a2]._from = t3, "Constant" === r3.opType()) {
                    if (1 !== r3.attributesLength() || !r3.attributes(0).t()) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                    if (1 !== r3.outputsLength()) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                    n3.outputs.pop(), n3.executeNode = false, this._allData[a2]._from = -1, this._allData[a2].tensor = s.Tensor.fromOrtTensor(r3.attributes(0).t());
                  }
                }
              }
              for (let t3 = 0; t3 < this._nodes.length; t3++) {
                const n3 = this._nodes[t3], r3 = e3.nodes(t3);
                if (0 === r3.inputsLength()) throw new Error(`missing input for node: ${r3.name}`);
                for (let e4 = 0; e4 < r3.inputsLength(); e4++) {
                  const i3 = r3.inputs(e4), s2 = o2.get(i3);
                  if (void 0 === s2) throw new Error(`unrecognized input '${i3}' for node: ${r3.name()}`);
                  n3.inputs.push(s2), this._allData[s2]._to.push(t3);
                }
              }
            }
            checkIsAcyclic() {
              const e3 = /* @__PURE__ */ new Set();
              this._allInputIndices.forEach(((t3) => {
                this._allData[t3]._to.forEach(((t4) => {
                  e3.add(t4);
                }));
              }));
              const t2 = Array.from(e3), n2 = new Array(this._nodes.length).fill("white");
              for (; t2.length > 0; ) {
                const e4 = t2.pop();
                "gray" === n2[e4] ? n2[e4] = "black" : (t2.push(e4), n2[e4] = "gray", this._nodes[e4].outputs.forEach(((r2) => {
                  const o2 = this._allData[r2];
                  if (void 0 !== o2.tensor) throw new Error("node outputs should not be initialized");
                  if (o2._from !== e4) throw new Error("from property of the Value object doesn't match index of Node being processed");
                  o2._to.forEach(((e5) => {
                    if ("gray" === n2[e5]) throw new Error("model graph is cyclic");
                    "white" === n2[e5] && t2.push(e5);
                  }));
                })));
              }
            }
            transformGraph(e3) {
              this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e3 && e3.transformGraph(this), this.finalizeGraph();
            }
            finalizeGraph() {
              let e3 = 0;
              for (let t2 = 0; t2 < this._nodes.length; t2++) this._nodes[t2].executeNode ? e3 > 0 && (this._nodes[t2].inputs.forEach(((n2) => {
                const r2 = this._allData[n2]._to.indexOf(t2 + e3);
                -1 !== r2 && (this._allData[n2]._to[r2] = t2);
              })), this._nodes[t2].outputs.forEach(((n2) => {
                this._allData[n2]._from && this._allData[n2]._from === t2 + e3 && (this._allData[n2]._from = t2);
              }))) : (e3++, this._nodes[t2].outputs.forEach(((e4) => {
                this._allData[e4]._from = -2;
              })), this._nodes.splice(t2, 1), t2--);
              e3 = 0;
              for (let t2 = 0; t2 < this._allData.length; t2++) if (-2 !== this._allData[t2].from || -1 !== this._allOutputIndices.indexOf(t2 + e3)) {
                if (e3 > 0) {
                  let n2 = -1;
                  void 0 !== this._allData[t2].from && -1 !== this._allData[t2].from ? (n2 = this._nodes[this._allData[t2].from].outputs.indexOf(t2 + e3), -1 !== n2 && (this._nodes[this._allData[t2].from].outputs[n2] = t2)) : (n2 = this._allInputIndices.indexOf(t2 + e3), -1 !== n2 && (this._allInputIndices[n2] = t2)), this._allData[t2].to.forEach(((r2) => {
                    n2 = this._nodes[r2].inputs.indexOf(t2 + e3), -1 !== n2 && (this._nodes[r2].inputs[n2] = t2);
                  })), 0 === this._allData[t2].to.length && (n2 = this._allOutputIndices.indexOf(t2 + e3), -1 !== n2 && (this._allOutputIndices[n2] = t2));
                }
              } else e3++, this._allData.splice(t2, 1), t2--;
            }
            deleteNode(e3) {
              const t2 = this._nodes[e3];
              if (t2.outputs.length > 1) {
                for (let e4 = 1; e4 < t2.outputs.length; e4++) if (this._allData[t2.outputs[e4]].to.length > 0) throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
              }
              t2.executeNode = false;
              const n2 = t2.inputs[0], r2 = t2.outputs[0], o2 = this._allData[r2].to, i2 = this._allData[n2].to.indexOf(e3);
              if (-1 === i2) throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
              this._allData[n2].to.splice(i2, 1), this._allData[r2]._to = [];
              const s2 = this._allOutputIndices.indexOf(r2);
              if (-1 !== s2 && (this._allOutputIndices[s2] = n2), o2 && o2.length > 0) for (const e4 of o2) {
                const t3 = this._nodes[e4].inputs.indexOf(r2);
                if (-1 === t3) throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                this._nodes[e4].inputs[t3] = n2, this._allData[n2].to.push(e4);
              }
            }
            removeAllDropoutNodes() {
              let e3 = 0;
              for (const t2 of this._nodes) {
                if ("Dropout" === t2.opType) {
                  if (1 !== t2.inputs.length) throw new Error("Dropout nodes should only contain one input. ");
                  if (1 !== t2.outputs.length && 2 !== t2.outputs.length) throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                  if (2 === t2.outputs.length && 0 !== this._allData[t2.outputs[1]]._to.length) throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                  this.deleteNode(e3);
                }
                e3++;
              }
            }
            removeAllIdentityNodes() {
              let e3 = 0;
              for (const t2 of this._nodes) "Identity" === t2.opType && this.deleteNode(e3), e3++;
            }
            isActivation(e3) {
              switch (e3.opType) {
                case "Relu":
                case "Sigmoid":
                case "Clip":
                  return true;
                default:
                  return false;
              }
            }
            fuseConvActivationNodes() {
              for (const e3 of this._nodes) if ("Conv" === e3.opType) {
                const t2 = this._allData[e3.outputs[0]]._to;
                if (1 === t2.length && this.isActivation(this._nodes[t2[0]])) {
                  const n2 = this._nodes[t2[0]];
                  if ("Clip" === n2.opType) if (1 === n2.inputs.length) try {
                    e3.attributes.set("activation_params", "floats", [n2.attributes.getFloat("min"), n2.attributes.getFloat("max")]);
                  } catch (t3) {
                    e3.attributes.set("activation_params", "floats", [a.MIN_CLIP, a.MAX_CLIP]);
                  }
                  else {
                    if (!(n2.inputs.length >= 3 && void 0 !== this._allData[n2.inputs[1]].tensor && void 0 !== this._allData[n2.inputs[2]].tensor)) continue;
                    e3.attributes.set("activation_params", "floats", [this._allData[n2.inputs[1]].tensor.floatData[0], this._allData[n2.inputs[2]].tensor.floatData[0]]);
                  }
                  e3.attributes.set("activation", "string", n2.opType), this.deleteNode(t2[0]);
                }
              }
            }
          }
        }, 6231: (e2, t) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.now = t.Profiler = t.Logger = void 0;
          const n = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r = { none: new class {
            log(e3, t2, n2) {
            }
          }(), console: new class {
            log(e3, t2, n2) {
              console.log(`${this.color(e3)} ${n2 ? "\x1B[35m" + n2 + "\x1B[0m " : ""}${t2}`);
            }
            color(e3) {
              switch (e3) {
                case "verbose":
                  return "\x1B[34;40mv\x1B[0m";
                case "info":
                  return "\x1B[32mi\x1B[0m";
                case "warning":
                  return "\x1B[30;43mw\x1B[0m";
                case "error":
                  return "\x1B[31;40me\x1B[0m";
                case "fatal":
                  return "\x1B[101mf\x1B[0m";
                default:
                  throw new Error(`unsupported severity: ${e3}`);
              }
            }
          }() }, o = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
          let i = { "": o };
          function s(e3, t2, n2, r2) {
            if (void 0 === t2) return o2 = e3, { verbose: s.verbose.bind(null, o2), info: s.info.bind(null, o2), warning: s.warning.bind(null, o2), error: s.error.bind(null, o2), fatal: s.fatal.bind(null, o2) };
            if (void 0 === n2) a(e3, t2);
            else if ("number" == typeof n2 && void 0 === r2) a(e3, t2);
            else if ("string" == typeof n2 && void 0 === r2) a(e3, n2, 0, t2);
            else {
              if ("string" != typeof n2 || "number" != typeof r2) throw new TypeError("input is valid");
              a(e3, n2, 0, t2);
            }
            var o2;
          }
          function a(e3, t2, o2, s2) {
            const a2 = i[s2 || ""] || i[""];
            n[e3] < n[a2.minimalSeverity] || (a2.logDateTime && (t2 = `${(/* @__PURE__ */ new Date()).toISOString()}|${t2}`), a2.logSourceLocation, r[a2.provider].log(e3, t2, s2));
          }
          !(function(e3) {
            function t2(e4) {
              i = {}, n2("", e4 || {});
            }
            function n2(e4, n3) {
              if ("*" === e4) t2(n3);
              else {
                const t3 = i[e4] || o;
                i[e4] = { provider: n3.provider || t3.provider, minimalSeverity: n3.minimalSeverity || t3.minimalSeverity, logDateTime: void 0 === n3.logDateTime ? t3.logDateTime : n3.logDateTime, logSourceLocation: void 0 === n3.logSourceLocation ? t3.logSourceLocation : n3.logSourceLocation };
              }
            }
            e3.verbose = function(t3, n3) {
              e3("verbose", t3, n3);
            }, e3.info = function(t3, n3) {
              e3("info", t3, n3);
            }, e3.warning = function(t3, n3) {
              e3("warning", t3, n3);
            }, e3.error = function(t3, n3) {
              e3("error", t3, n3);
            }, e3.fatal = function(t3, n3) {
              e3("fatal", t3, n3);
            }, e3.reset = t2, e3.set = n2, e3.setWithEnv = function(e4) {
              const t3 = {};
              e4.logLevel && (t3.minimalSeverity = e4.logLevel), n2("", t3);
            };
          })(s || (s = {})), t.Logger = s;
          class l {
            constructor(e3, t2, n2, r2, o2, i2) {
              this.category = e3, this.name = t2, this.startTime = n2, this.endCallback = r2, this.timer = o2, this.ctx = i2;
            }
            end() {
              return this.endCallback(this);
            }
            async checkTimer() {
              if (void 0 === this.ctx || void 0 === this.timer) throw new Error("No webgl timer found");
              return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
            }
          }
          class c {
            constructor(e3, t2, n2, r2) {
              this.category = e3, this.name = t2, this.startTime = n2, this.endTime = r2;
            }
          }
          t.Profiler = class {
            static create(e3) {
              return void 0 === e3 ? new this() : new this(e3.maxNumberEvents, e3.flushBatchSize, e3.flushIntervalInMilliseconds);
            }
            constructor(e3, t2, n2) {
              this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === e3 ? 1e4 : e3, this._flushBatchSize = void 0 === t2 ? 10 : t2, this._flushIntervalInMilliseconds = void 0 === n2 ? 5e3 : n2;
            }
            start() {
              this._started = true, this._timingEvents = [], this._flushTime = (0, t.now)(), this._flushPointer = 0;
            }
            stop() {
              for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            event(e3, t2, n2, r2) {
              const o2 = this._started ? this.begin(e3, t2, r2) : void 0;
              let i2 = false;
              const s2 = n2();
              if (s2 && "function" == typeof s2.then) return i2 = true, new Promise(((e4, t3) => {
                s2.then((async (t4) => {
                  o2 && await o2.end(), e4(t4);
                }), (async (e5) => {
                  o2 && await o2.end(), t3(e5);
                }));
              }));
              if (!i2 && o2) {
                const e4 = o2.end();
                if (e4 && "function" == typeof e4.then) return new Promise(((t3, n3) => {
                  e4.then((() => {
                    t3(s2);
                  }), ((e5) => {
                    n3(e5);
                  }));
                }));
              }
              return s2;
            }
            begin(e3, n2, r2) {
              if (!this._started) throw new Error("profiler is not started yet");
              if (void 0 === r2) {
                const r3 = (0, t.now)();
                return this.flush(r3), new l(e3, n2, r3, ((e4) => this.endSync(e4)));
              }
              {
                const t2 = r2.beginTimer();
                return new l(e3, n2, 0, (async (e4) => this.end(e4)), t2, r2);
              }
            }
            async end(e3) {
              const t2 = await e3.checkTimer();
              this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(e3.category, e3.name, e3.startTime, t2)), this.flush(t2));
            }
            endSync(e3) {
              const n2 = (0, t.now)();
              this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(e3.category, e3.name, e3.startTime, n2)), this.flush(n2));
            }
            logOneEvent(e3) {
              t.Logger.verbose(`Profiler.${e3.category}`, `${(e3.endTime - e3.startTime).toFixed(2)}ms on event '${e3.name}' at ${e3.endTime.toFixed(2)}`);
            }
            flush(e3) {
              if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e3 - this._flushTime >= this._flushIntervalInMilliseconds) {
                for (const e4 = this._flushPointer; this._flushPointer < e4 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
                this._flushTime = (0, t.now)();
              }
            }
            get started() {
              return this._started;
            }
          }, t.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
        }, 2644: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.Model = void 0;
          const r = n(5686), o = n(1446), i = n(7070), s = n(9395), a = n(2517);
          var l = s.onnxruntime.experimental.fbs;
          t.Model = class {
            constructor() {
            }
            load(e3, t2, n2) {
              if (!n2) try {
                return void this.loadFromOnnxFormat(e3, t2);
              } catch (e4) {
                if (void 0 !== n2) throw e4;
              }
              this.loadFromOrtFormat(e3, t2);
            }
            loadFromOnnxFormat(e3, t2) {
              const n2 = o.onnx.ModelProto.decode(e3);
              if (a.LongUtil.longToNumber(n2.irVersion) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
              this._opsets = n2.opsetImport.map(((e4) => ({ domain: e4.domain, version: a.LongUtil.longToNumber(e4.version) }))), this._graph = i.Graph.from(n2.graph, t2);
            }
            loadFromOrtFormat(e3, t2) {
              const n2 = new r.flatbuffers.ByteBuffer(e3), o2 = l.InferenceSession.getRootAsInferenceSession(n2).model();
              if (a.LongUtil.longToNumber(o2.irVersion()) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
              this._opsets = [];
              for (let e4 = 0; e4 < o2.opsetImportLength(); e4++) {
                const t3 = o2.opsetImport(e4);
                this._opsets.push({ domain: null == t3 ? void 0 : t3.domain(), version: a.LongUtil.longToNumber(t3.version()) });
              }
              this._graph = i.Graph.from(o2.graph(), t2);
            }
            get graph() {
              return this._graph;
            }
            get opsets() {
              return this._opsets;
            }
          };
        }, 782: (e2, t) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.FLOAT_TYPES = t.INT_TYPES = t.NUMBER_TYPES = void 0, t.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], t.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], t.FLOAT_TYPES = ["float32", "float64"];
        }, 1047: (e2, t) => {
          function n(e3, t2) {
            if (t2.endsWith("+")) {
              const n2 = Number.parseInt(t2.substring(0, t2.length - 1), 10);
              return !isNaN(n2) && n2 <= e3;
            }
            if (2 === t2.split("-").length) {
              const n2 = t2.split("-"), r = Number.parseInt(n2[0], 10), o = Number.parseInt(n2[1], 10);
              return !isNaN(r) && !isNaN(o) && r <= e3 && e3 <= o;
            }
            return Number.parseInt(t2, 10) === e3;
          }
          Object.defineProperty(t, "__esModule", { value: true }), t.resolveOperator = void 0, t.resolveOperator = function(e3, t2, r) {
            for (const o of r) {
              const r2 = o[0], i = o[1], s = o[2], a = o[3], l = o[4];
              if (e3.opType === r2) {
                for (const e4 of t2) if ((e4.domain === i || "ai.onnx" === e4.domain && "" === i) && n(e4.version, s)) return { opImpl: a, opInit: l };
              }
            }
            throw new TypeError(`cannot resolve operator '${e3.opType}' with opsets: ${t2.map(((e4) => `${e4.domain || "ai.onnx"} v${e4.version}`)).join(", ")}`);
          };
        }, 9395: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.onnxruntime = void 0;
          const r = n(5686);
          var o, i;
          (function(e3) {
            let t2;
            !(function(e4) {
              e4[e4.UNDEFINED = 0] = "UNDEFINED", e4[e4.FLOAT = 1] = "FLOAT", e4[e4.INT = 2] = "INT", e4[e4.STRING = 3] = "STRING", e4[e4.TENSOR = 4] = "TENSOR", e4[e4.GRAPH = 5] = "GRAPH", e4[e4.FLOATS = 6] = "FLOATS", e4[e4.INTS = 7] = "INTS", e4[e4.STRINGS = 8] = "STRINGS", e4[e4.TENSORS = 9] = "TENSORS", e4[e4.GRAPHS = 10] = "GRAPHS", e4[e4.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", e4[e4.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
            })(t2 = e3.AttributeType || (e3.AttributeType = {}));
          })((i = (o = t.onnxruntime || (t.onnxruntime = {})).experimental || (o.experimental = {})).fbs || (i.fbs = {})), (function(e3) {
            !(function(e4) {
              !(function(e5) {
                let t2;
                !(function(e6) {
                  e6[e6.UNKNOWN = 0] = "UNKNOWN", e6[e6.VALUE = 1] = "VALUE", e6[e6.PARAM = 2] = "PARAM";
                })(t2 = e5.DimensionValueType || (e5.DimensionValueType = {}));
              })(e4.fbs || (e4.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(e4) {
              !(function(e5) {
                let t2;
                !(function(e6) {
                  e6[e6.UNDEFINED = 0] = "UNDEFINED", e6[e6.FLOAT = 1] = "FLOAT", e6[e6.UINT8 = 2] = "UINT8", e6[e6.INT8 = 3] = "INT8", e6[e6.UINT16 = 4] = "UINT16", e6[e6.INT16 = 5] = "INT16", e6[e6.INT32 = 6] = "INT32", e6[e6.INT64 = 7] = "INT64", e6[e6.STRING = 8] = "STRING", e6[e6.BOOL = 9] = "BOOL", e6[e6.FLOAT16 = 10] = "FLOAT16", e6[e6.DOUBLE = 11] = "DOUBLE", e6[e6.UINT32 = 12] = "UINT32", e6[e6.UINT64 = 13] = "UINT64", e6[e6.COMPLEX64 = 14] = "COMPLEX64", e6[e6.COMPLEX128 = 15] = "COMPLEX128", e6[e6.BFLOAT16 = 16] = "BFLOAT16";
                })(t2 = e5.TensorDataType || (e5.TensorDataType = {}));
              })(e4.fbs || (e4.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(e4) {
              !(function(e5) {
                let t2;
                !(function(e6) {
                  e6[e6.Primitive = 0] = "Primitive", e6[e6.Fused = 1] = "Fused";
                })(t2 = e5.NodeType || (e5.NodeType = {}));
              })(e4.fbs || (e4.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(e4) {
              !(function(e5) {
                let t2;
                !(function(e6) {
                  e6[e6.NONE = 0] = "NONE", e6[e6.tensor_type = 1] = "tensor_type", e6[e6.sequence_type = 2] = "sequence_type", e6[e6.map_type = 3] = "map_type";
                })(t2 = e5.TypeInfoValue || (e5.TypeInfoValue = {}));
              })(e4.fbs || (e4.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsShape(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsShape(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  dim(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 4);
                    return r2 ? (n3 || new e3.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  dimLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startShape(e4) {
                    e4.startObject(1);
                  }
                  static addDim(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static createDimVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startDimVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static endShape(e4) {
                    return e4.endObject();
                  }
                  static createShape(e4, t4) {
                    return n2.startShape(e4), n2.addDim(e4, t4), n2.endShape(e4);
                  }
                }
                t3.Shape = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsDimension(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsDimension(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  value(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (t4 || new e3.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  denotation(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 6);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  static startDimension(e4) {
                    e4.startObject(2);
                  }
                  static addValue(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addDenotation(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static endDimension(e4) {
                    return e4.endObject();
                  }
                  static createDimension(e4, t4, r2) {
                    return n2.startDimension(e4), n2.addValue(e4, t4), n2.addDenotation(e4, r2), n2.endDimension(e4);
                  }
                }
                t3.Dimension = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsDimensionValue(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsDimensionValue(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  dimType() {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.readInt8(this.bb_pos + t4) : e3.experimental.fbs.DimensionValueType.UNKNOWN;
                  }
                  dimValue() {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.readInt64(this.bb_pos + e4) : this.bb.createLong(0, 0);
                  }
                  dimParam(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 8);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  static startDimensionValue(e4) {
                    e4.startObject(3);
                  }
                  static addDimType(t4, n3) {
                    t4.addFieldInt8(0, n3, e3.experimental.fbs.DimensionValueType.UNKNOWN);
                  }
                  static addDimValue(e4, t4) {
                    e4.addFieldInt64(1, t4, e4.createLong(0, 0));
                  }
                  static addDimParam(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static endDimensionValue(e4) {
                    return e4.endObject();
                  }
                  static createDimensionValue(e4, t4, r2, o2) {
                    return n2.startDimensionValue(e4), n2.addDimType(e4, t4), n2.addDimValue(e4, r2), n2.addDimParam(e4, o2), n2.endDimensionValue(e4);
                  }
                }
                t3.DimensionValue = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsTensorTypeAndShape(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsTensorTypeAndShape(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  elemType() {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.readInt32(this.bb_pos + t4) : e3.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  shape(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (t4 || new e3.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startTensorTypeAndShape(e4) {
                    e4.startObject(2);
                  }
                  static addElemType(t4, n3) {
                    t4.addFieldInt32(0, n3, e3.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addShape(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static endTensorTypeAndShape(e4) {
                    return e4.endObject();
                  }
                  static createTensorTypeAndShape(e4, t4, r2) {
                    return n2.startTensorTypeAndShape(e4), n2.addElemType(e4, t4), n2.addShape(e4, r2), n2.endTensorTypeAndShape(e4);
                  }
                }
                t3.TensorTypeAndShape = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsMapType(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsMapType(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  keyType() {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.readInt32(this.bb_pos + t4) : e3.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  valueType(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (t4 || new e3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startMapType(e4) {
                    e4.startObject(2);
                  }
                  static addKeyType(t4, n3) {
                    t4.addFieldInt32(0, n3, e3.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addValueType(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static endMapType(e4) {
                    return e4.endObject();
                  }
                  static createMapType(e4, t4, r2) {
                    return n2.startMapType(e4), n2.addKeyType(e4, t4), n2.addValueType(e4, r2), n2.endMapType(e4);
                  }
                }
                t3.MapType = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsSequenceType(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsSequenceType(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  elemType(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (t4 || new e3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startSequenceType(e4) {
                    e4.startObject(1);
                  }
                  static addElemType(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static endSequenceType(e4) {
                    return e4.endObject();
                  }
                  static createSequenceType(e4, t4) {
                    return n2.startSequenceType(e4), n2.addElemType(e4, t4), n2.endSequenceType(e4);
                  }
                }
                t3.SequenceType = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(e4) {
              (e4.fbs || (e4.fbs = {})).EdgeEnd = class {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e5, t2) {
                  return this.bb_pos = e5, this.bb = t2, this;
                }
                nodeIndex() {
                  return this.bb.readUint32(this.bb_pos);
                }
                srcArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 4);
                }
                dstArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 8);
                }
                static createEdgeEnd(e5, t2, n2, r2) {
                  return e5.prep(4, 12), e5.writeInt32(r2), e5.writeInt32(n2), e5.writeInt32(t2), e5.offset();
                }
              };
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsNodeEdge(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsNodeEdge(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  nodeIndex() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readUint32(this.bb_pos + e4) : 0;
                  }
                  inputEdges(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new e3.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                  }
                  inputEdgesLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  outputEdges(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 8);
                    return r2 ? (n3 || new e3.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                  }
                  outputEdgesLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startNodeEdge(e4) {
                    e4.startObject(3);
                  }
                  static addNodeIndex(e4, t4) {
                    e4.addFieldInt32(0, t4, 0);
                  }
                  static addInputEdges(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static startInputEdgesVector(e4, t4) {
                    e4.startVector(12, t4, 4);
                  }
                  static addOutputEdges(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static startOutputEdgesVector(e4, t4) {
                    e4.startVector(12, t4, 4);
                  }
                  static endNodeEdge(e4) {
                    return e4.endObject();
                  }
                  static createNodeEdge(e4, t4, r2, o2) {
                    return n2.startNodeEdge(e4), n2.addNodeIndex(e4, t4), n2.addInputEdges(e4, r2), n2.addOutputEdges(e4, o2), n2.endNodeEdge(e4);
                  }
                }
                t3.NodeEdge = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsNode(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsNode(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  name(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  docString(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 6);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  domain(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 8);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  sinceVersion() {
                    let e4 = this.bb.__offset(this.bb_pos, 10);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : 0;
                  }
                  index() {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.readUint32(this.bb_pos + e4) : 0;
                  }
                  opType(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 14);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  type() {
                    let t4 = this.bb.__offset(this.bb_pos, 16);
                    return t4 ? this.bb.readInt32(this.bb_pos + t4) : e3.experimental.fbs.NodeType.Primitive;
                  }
                  executionProviderType(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 18);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  inputs(e4, t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 20);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e4, t4) : null;
                  }
                  inputsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 20);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  outputs(e4, t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 22);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e4, t4) : null;
                  }
                  outputsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 22);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  attributes(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 24);
                    return r2 ? (n3 || new e3.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  attributesLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 24);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  inputArgCounts(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 26);
                    return t4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + t4) + 4 * e4) : 0;
                  }
                  inputArgCountsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 26);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  inputArgCountsArray() {
                    let e4 = this.bb.__offset(this.bb_pos, 26);
                    return e4 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e4), this.bb.__vector_len(this.bb_pos + e4)) : null;
                  }
                  implicitInputs(e4, t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 28);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e4, t4) : null;
                  }
                  implicitInputsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 28);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startNode(e4) {
                    e4.startObject(13);
                  }
                  static addName(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addDocString(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static addDomain(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static addSinceVersion(e4, t4) {
                    e4.addFieldInt32(3, t4, 0);
                  }
                  static addIndex(e4, t4) {
                    e4.addFieldInt32(4, t4, 0);
                  }
                  static addOpType(e4, t4) {
                    e4.addFieldOffset(5, t4, 0);
                  }
                  static addType(t4, n3) {
                    t4.addFieldInt32(6, n3, e3.experimental.fbs.NodeType.Primitive);
                  }
                  static addExecutionProviderType(e4, t4) {
                    e4.addFieldOffset(7, t4, 0);
                  }
                  static addInputs(e4, t4) {
                    e4.addFieldOffset(8, t4, 0);
                  }
                  static createInputsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startInputsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addOutputs(e4, t4) {
                    e4.addFieldOffset(9, t4, 0);
                  }
                  static createOutputsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startOutputsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addAttributes(e4, t4) {
                    e4.addFieldOffset(10, t4, 0);
                  }
                  static createAttributesVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startAttributesVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addInputArgCounts(e4, t4) {
                    e4.addFieldOffset(11, t4, 0);
                  }
                  static createInputArgCountsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addInt32(t4[n3]);
                    return e4.endVector();
                  }
                  static startInputArgCountsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addImplicitInputs(e4, t4) {
                    e4.addFieldOffset(12, t4, 0);
                  }
                  static createImplicitInputsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startImplicitInputsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static endNode(e4) {
                    return e4.endObject();
                  }
                  static createNode(e4, t4, r2, o2, i2, s, a, l, c, u, p, d, _, h) {
                    return n2.startNode(e4), n2.addName(e4, t4), n2.addDocString(e4, r2), n2.addDomain(e4, o2), n2.addSinceVersion(e4, i2), n2.addIndex(e4, s), n2.addOpType(e4, a), n2.addType(e4, l), n2.addExecutionProviderType(e4, c), n2.addInputs(e4, u), n2.addOutputs(e4, p), n2.addAttributes(e4, d), n2.addInputArgCounts(e4, _), n2.addImplicitInputs(e4, h), n2.endNode(e4);
                  }
                }
                t3.Node = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsValueInfo(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsValueInfo(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  name(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  docString(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 6);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  type(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 8);
                    return n3 ? (t4 || new e3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startValueInfo(e4) {
                    e4.startObject(3);
                  }
                  static addName(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addDocString(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static addType(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static endValueInfo(e4) {
                    return e4.endObject();
                  }
                  static createValueInfo(e4, t4, r2, o2) {
                    return n2.startValueInfo(e4), n2.addName(e4, t4), n2.addDocString(e4, r2), n2.addType(e4, o2), n2.endValueInfo(e4);
                  }
                }
                t3.ValueInfo = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsTypeInfo(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsTypeInfo(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  denotation(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  valueType() {
                    let t4 = this.bb.__offset(this.bb_pos, 6);
                    return t4 ? this.bb.readUint8(this.bb_pos + t4) : e3.experimental.fbs.TypeInfoValue.NONE;
                  }
                  value(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 8);
                    return t4 ? this.bb.__union(e4, this.bb_pos + t4) : null;
                  }
                  static startTypeInfo(e4) {
                    e4.startObject(3);
                  }
                  static addDenotation(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addValueType(t4, n3) {
                    t4.addFieldInt8(1, n3, e3.experimental.fbs.TypeInfoValue.NONE);
                  }
                  static addValue(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static endTypeInfo(e4) {
                    return e4.endObject();
                  }
                  static createTypeInfo(e4, t4, r2, o2) {
                    return n2.startTypeInfo(e4), n2.addDenotation(e4, t4), n2.addValueType(e4, r2), n2.addValue(e4, o2), n2.endTypeInfo(e4);
                  }
                }
                t3.TypeInfo = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(e4) {
              !(function(e5) {
                class t2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e6, t3) {
                    return this.bb_pos = e6, this.bb = t3, this;
                  }
                  static getRootAsOperatorSetId(e6, n2) {
                    return (n2 || new t2()).__init(e6.readInt32(e6.position()) + e6.position(), e6);
                  }
                  static getSizePrefixedRootAsOperatorSetId(e6, n2) {
                    return e6.setPosition(e6.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e6.readInt32(e6.position()) + e6.position(), e6);
                  }
                  domain(e6) {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.__string(this.bb_pos + t3, e6) : null;
                  }
                  version() {
                    let e6 = this.bb.__offset(this.bb_pos, 6);
                    return e6 ? this.bb.readInt64(this.bb_pos + e6) : this.bb.createLong(0, 0);
                  }
                  static startOperatorSetId(e6) {
                    e6.startObject(2);
                  }
                  static addDomain(e6, t3) {
                    e6.addFieldOffset(0, t3, 0);
                  }
                  static addVersion(e6, t3) {
                    e6.addFieldInt64(1, t3, e6.createLong(0, 0));
                  }
                  static endOperatorSetId(e6) {
                    return e6.endObject();
                  }
                  static createOperatorSetId(e6, n2, r2) {
                    return t2.startOperatorSetId(e6), t2.addDomain(e6, n2), t2.addVersion(e6, r2), t2.endOperatorSetId(e6);
                  }
                }
                e5.OperatorSetId = t2;
              })(e4.fbs || (e4.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsTensor(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsTensor(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  name(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  docString(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 6);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  dims(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 8);
                    return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e4) : this.bb.createLong(0, 0);
                  }
                  dimsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  dataType() {
                    let t4 = this.bb.__offset(this.bb_pos, 10);
                    return t4 ? this.bb.readInt32(this.bb_pos + t4) : e3.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  rawData(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 12);
                    return t4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t4) + e4) : 0;
                  }
                  rawDataLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  rawDataArray() {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e4), this.bb.__vector_len(this.bb_pos + e4)) : null;
                  }
                  stringData(e4, t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 14);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e4, t4) : null;
                  }
                  stringDataLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 14);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startTensor(e4) {
                    e4.startObject(6);
                  }
                  static addName(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addDocString(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static addDims(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static createDimsVector(e4, t4) {
                    e4.startVector(8, t4.length, 8);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addInt64(t4[n3]);
                    return e4.endVector();
                  }
                  static startDimsVector(e4, t4) {
                    e4.startVector(8, t4, 8);
                  }
                  static addDataType(t4, n3) {
                    t4.addFieldInt32(3, n3, e3.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addRawData(e4, t4) {
                    e4.addFieldOffset(4, t4, 0);
                  }
                  static createRawDataVector(e4, t4) {
                    e4.startVector(1, t4.length, 1);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addInt8(t4[n3]);
                    return e4.endVector();
                  }
                  static startRawDataVector(e4, t4) {
                    e4.startVector(1, t4, 1);
                  }
                  static addStringData(e4, t4) {
                    e4.addFieldOffset(5, t4, 0);
                  }
                  static createStringDataVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startStringDataVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static endTensor(e4) {
                    return e4.endObject();
                  }
                  static createTensor(e4, t4, r2, o2, i2, s, a) {
                    return n2.startTensor(e4), n2.addName(e4, t4), n2.addDocString(e4, r2), n2.addDims(e4, o2), n2.addDataType(e4, i2), n2.addRawData(e4, s), n2.addStringData(e4, a), n2.endTensor(e4);
                  }
                }
                t3.Tensor = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsSparseTensor(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsSparseTensor(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  values(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (t4 || new e3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  indices(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (t4 || new e3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  dims(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 8);
                    return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e4) : this.bb.createLong(0, 0);
                  }
                  dimsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startSparseTensor(e4) {
                    e4.startObject(3);
                  }
                  static addValues(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addIndices(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static addDims(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static createDimsVector(e4, t4) {
                    e4.startVector(8, t4.length, 8);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addInt64(t4[n3]);
                    return e4.endVector();
                  }
                  static startDimsVector(e4, t4) {
                    e4.startVector(8, t4, 8);
                  }
                  static endSparseTensor(e4) {
                    return e4.endObject();
                  }
                  static createSparseTensor(e4, t4, r2, o2) {
                    return n2.startSparseTensor(e4), n2.addValues(e4, t4), n2.addIndices(e4, r2), n2.addDims(e4, o2), n2.endSparseTensor(e4);
                  }
                }
                t3.SparseTensor = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsAttribute(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsAttribute(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  name(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  docString(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 6);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  type() {
                    let t4 = this.bb.__offset(this.bb_pos, 8);
                    return t4 ? this.bb.readInt32(this.bb_pos + t4) : e3.experimental.fbs.AttributeType.UNDEFINED;
                  }
                  f() {
                    let e4 = this.bb.__offset(this.bb_pos, 10);
                    return e4 ? this.bb.readFloat32(this.bb_pos + e4) : 0;
                  }
                  i() {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.readInt64(this.bb_pos + e4) : this.bb.createLong(0, 0);
                  }
                  s(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 14);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  t(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 16);
                    return n3 ? (t4 || new e3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  g(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 18);
                    return n3 ? (t4 || new e3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  floats(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 20);
                    return t4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + t4) + 4 * e4) : 0;
                  }
                  floatsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 20);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  floatsArray() {
                    let e4 = this.bb.__offset(this.bb_pos, 20);
                    return e4 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e4), this.bb.__vector_len(this.bb_pos + e4)) : null;
                  }
                  ints(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 22);
                    return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e4) : this.bb.createLong(0, 0);
                  }
                  intsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 22);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  strings(e4, t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 24);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e4, t4) : null;
                  }
                  stringsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 24);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  tensors(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 26);
                    return r2 ? (n3 || new e3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  tensorsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 26);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  graphs(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 28);
                    return r2 ? (n3 || new e3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  graphsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 28);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startAttribute(e4) {
                    e4.startObject(13);
                  }
                  static addName(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addDocString(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static addType(t4, n3) {
                    t4.addFieldInt32(2, n3, e3.experimental.fbs.AttributeType.UNDEFINED);
                  }
                  static addF(e4, t4) {
                    e4.addFieldFloat32(3, t4, 0);
                  }
                  static addI(e4, t4) {
                    e4.addFieldInt64(4, t4, e4.createLong(0, 0));
                  }
                  static addS(e4, t4) {
                    e4.addFieldOffset(5, t4, 0);
                  }
                  static addT(e4, t4) {
                    e4.addFieldOffset(6, t4, 0);
                  }
                  static addG(e4, t4) {
                    e4.addFieldOffset(7, t4, 0);
                  }
                  static addFloats(e4, t4) {
                    e4.addFieldOffset(8, t4, 0);
                  }
                  static createFloatsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addFloat32(t4[n3]);
                    return e4.endVector();
                  }
                  static startFloatsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addInts(e4, t4) {
                    e4.addFieldOffset(9, t4, 0);
                  }
                  static createIntsVector(e4, t4) {
                    e4.startVector(8, t4.length, 8);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addInt64(t4[n3]);
                    return e4.endVector();
                  }
                  static startIntsVector(e4, t4) {
                    e4.startVector(8, t4, 8);
                  }
                  static addStrings(e4, t4) {
                    e4.addFieldOffset(10, t4, 0);
                  }
                  static createStringsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startStringsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addTensors(e4, t4) {
                    e4.addFieldOffset(11, t4, 0);
                  }
                  static createTensorsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startTensorsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addGraphs(e4, t4) {
                    e4.addFieldOffset(12, t4, 0);
                  }
                  static createGraphsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startGraphsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static endAttribute(e4) {
                    return e4.endObject();
                  }
                  static createAttribute(e4, t4, r2, o2, i2, s, a, l, c, u, p, d, _, h) {
                    return n2.startAttribute(e4), n2.addName(e4, t4), n2.addDocString(e4, r2), n2.addType(e4, o2), n2.addF(e4, i2), n2.addI(e4, s), n2.addS(e4, a), n2.addT(e4, l), n2.addG(e4, c), n2.addFloats(e4, u), n2.addInts(e4, p), n2.addStrings(e4, d), n2.addTensors(e4, _), n2.addGraphs(e4, h), n2.endAttribute(e4);
                  }
                }
                t3.Attribute = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsGraph(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsGraph(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  initializers(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 4);
                    return r2 ? (n3 || new e3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  initializersLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  nodeArgs(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new e3.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  nodeArgsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  nodes(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 8);
                    return r2 ? (n3 || new e3.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  nodesLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  maxNodeIndex() {
                    let e4 = this.bb.__offset(this.bb_pos, 10);
                    return e4 ? this.bb.readUint32(this.bb_pos + e4) : 0;
                  }
                  nodeEdges(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 12);
                    return r2 ? (n3 || new e3.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  nodeEdgesLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  inputs(e4, t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 14);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e4, t4) : null;
                  }
                  inputsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 14);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  outputs(e4, t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 16);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e4, t4) : null;
                  }
                  outputsLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 16);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  sparseInitializers(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 18);
                    return r2 ? (n3 || new e3.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  sparseInitializersLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 18);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startGraph(e4) {
                    e4.startObject(8);
                  }
                  static addInitializers(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static createInitializersVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startInitializersVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addNodeArgs(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static createNodeArgsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startNodeArgsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addNodes(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static createNodesVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startNodesVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addMaxNodeIndex(e4, t4) {
                    e4.addFieldInt32(3, t4, 0);
                  }
                  static addNodeEdges(e4, t4) {
                    e4.addFieldOffset(4, t4, 0);
                  }
                  static createNodeEdgesVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startNodeEdgesVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addInputs(e4, t4) {
                    e4.addFieldOffset(5, t4, 0);
                  }
                  static createInputsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startInputsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addOutputs(e4, t4) {
                    e4.addFieldOffset(6, t4, 0);
                  }
                  static createOutputsVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startOutputsVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addSparseInitializers(e4, t4) {
                    e4.addFieldOffset(7, t4, 0);
                  }
                  static createSparseInitializersVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startSparseInitializersVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static endGraph(e4) {
                    return e4.endObject();
                  }
                  static createGraph(e4, t4, r2, o2, i2, s, a, l, c) {
                    return n2.startGraph(e4), n2.addInitializers(e4, t4), n2.addNodeArgs(e4, r2), n2.addNodes(e4, o2), n2.addMaxNodeIndex(e4, i2), n2.addNodeEdges(e4, s), n2.addInputs(e4, a), n2.addOutputs(e4, l), n2.addSparseInitializers(e4, c), n2.endGraph(e4);
                  }
                }
                t3.Graph = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsModel(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsModel(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  irVersion() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readInt64(this.bb_pos + e4) : this.bb.createLong(0, 0);
                  }
                  opsetImport(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new e3.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  opsetImportLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  producerName(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 8);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  producerVersion(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 10);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  domain(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 12);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  modelVersion() {
                    let e4 = this.bb.__offset(this.bb_pos, 14);
                    return e4 ? this.bb.readInt64(this.bb_pos + e4) : this.bb.createLong(0, 0);
                  }
                  docString(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 16);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  graph(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 18);
                    return n3 ? (t4 || new e3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  graphDocString(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 20);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  static startModel(e4) {
                    e4.startObject(9);
                  }
                  static addIrVersion(e4, t4) {
                    e4.addFieldInt64(0, t4, e4.createLong(0, 0));
                  }
                  static addOpsetImport(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static createOpsetImportVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startOpsetImportVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static addProducerName(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static addProducerVersion(e4, t4) {
                    e4.addFieldOffset(3, t4, 0);
                  }
                  static addDomain(e4, t4) {
                    e4.addFieldOffset(4, t4, 0);
                  }
                  static addModelVersion(e4, t4) {
                    e4.addFieldInt64(5, t4, e4.createLong(0, 0));
                  }
                  static addDocString(e4, t4) {
                    e4.addFieldOffset(6, t4, 0);
                  }
                  static addGraph(e4, t4) {
                    e4.addFieldOffset(7, t4, 0);
                  }
                  static addGraphDocString(e4, t4) {
                    e4.addFieldOffset(8, t4, 0);
                  }
                  static endModel(e4) {
                    return e4.endObject();
                  }
                  static createModel(e4, t4, r2, o2, i2, s, a, l, c, u) {
                    return n2.startModel(e4), n2.addIrVersion(e4, t4), n2.addOpsetImport(e4, r2), n2.addProducerName(e4, o2), n2.addProducerVersion(e4, i2), n2.addDomain(e4, s), n2.addModelVersion(e4, a), n2.addDocString(e4, l), n2.addGraph(e4, c), n2.addGraphDocString(e4, u), n2.endModel(e4);
                  }
                }
                t3.Model = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(e4) {
              !(function(e5) {
                class t2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e6, t3) {
                    return this.bb_pos = e6, this.bb = t3, this;
                  }
                  static getRootAsKernelCreateInfos(e6, n2) {
                    return (n2 || new t2()).__init(e6.readInt32(e6.position()) + e6.position(), e6);
                  }
                  static getSizePrefixedRootAsKernelCreateInfos(e6, n2) {
                    return e6.setPosition(e6.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e6.readInt32(e6.position()) + e6.position(), e6);
                  }
                  nodeIndices(e6) {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t3) + 4 * e6) : 0;
                  }
                  nodeIndicesLength() {
                    let e6 = this.bb.__offset(this.bb_pos, 4);
                    return e6 ? this.bb.__vector_len(this.bb_pos + e6) : 0;
                  }
                  nodeIndicesArray() {
                    let e6 = this.bb.__offset(this.bb_pos, 4);
                    return e6 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e6), this.bb.__vector_len(this.bb_pos + e6)) : null;
                  }
                  kernelDefHashes(e6) {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t3) + 8 * e6) : this.bb.createLong(0, 0);
                  }
                  kernelDefHashesLength() {
                    let e6 = this.bb.__offset(this.bb_pos, 6);
                    return e6 ? this.bb.__vector_len(this.bb_pos + e6) : 0;
                  }
                  static startKernelCreateInfos(e6) {
                    e6.startObject(2);
                  }
                  static addNodeIndices(e6, t3) {
                    e6.addFieldOffset(0, t3, 0);
                  }
                  static createNodeIndicesVector(e6, t3) {
                    e6.startVector(4, t3.length, 4);
                    for (let n2 = t3.length - 1; n2 >= 0; n2--) e6.addInt32(t3[n2]);
                    return e6.endVector();
                  }
                  static startNodeIndicesVector(e6, t3) {
                    e6.startVector(4, t3, 4);
                  }
                  static addKernelDefHashes(e6, t3) {
                    e6.addFieldOffset(1, t3, 0);
                  }
                  static createKernelDefHashesVector(e6, t3) {
                    e6.startVector(8, t3.length, 8);
                    for (let n2 = t3.length - 1; n2 >= 0; n2--) e6.addInt64(t3[n2]);
                    return e6.endVector();
                  }
                  static startKernelDefHashesVector(e6, t3) {
                    e6.startVector(8, t3, 8);
                  }
                  static endKernelCreateInfos(e6) {
                    return e6.endObject();
                  }
                  static createKernelCreateInfos(e6, n2, r2) {
                    return t2.startKernelCreateInfos(e6), t2.addNodeIndices(e6, n2), t2.addKernelDefHashes(e6, r2), t2.endKernelCreateInfos(e6);
                  }
                }
                e5.KernelCreateInfos = t2;
              })(e4.fbs || (e4.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsSubGraphSessionState(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsSubGraphSessionState(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  graphId(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  sessionState(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (t4 || new e3.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startSubGraphSessionState(e4) {
                    e4.startObject(2);
                  }
                  static addGraphId(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addSessionState(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static endSubGraphSessionState(e4) {
                    let t4 = e4.endObject();
                    return e4.requiredField(t4, 4), t4;
                  }
                  static createSubGraphSessionState(e4, t4, r2) {
                    return n2.startSubGraphSessionState(e4), n2.addGraphId(e4, t4), n2.addSessionState(e4, r2), n2.endSubGraphSessionState(e4);
                  }
                }
                t3.SubGraphSessionState = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsSessionState(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsSessionState(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  kernels(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (t4 || new e3.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  subGraphSessionStates(t4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new e3.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                  }
                  subGraphSessionStatesLength() {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__vector_len(this.bb_pos + e4) : 0;
                  }
                  static startSessionState(e4) {
                    e4.startObject(2);
                  }
                  static addKernels(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addSubGraphSessionStates(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static createSubGraphSessionStatesVector(e4, t4) {
                    e4.startVector(4, t4.length, 4);
                    for (let n3 = t4.length - 1; n3 >= 0; n3--) e4.addOffset(t4[n3]);
                    return e4.endVector();
                  }
                  static startSubGraphSessionStatesVector(e4, t4) {
                    e4.startVector(4, t4, 4);
                  }
                  static endSessionState(e4) {
                    return e4.endObject();
                  }
                  static createSessionState(e4, t4, r2) {
                    return n2.startSessionState(e4), n2.addKernels(e4, t4), n2.addSubGraphSessionStates(e4, r2), n2.endSessionState(e4);
                  }
                }
                t3.SessionState = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {})), (function(e3) {
            !(function(t2) {
              !(function(t3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(e4, t4) {
                    return this.bb_pos = e4, this.bb = t4, this;
                  }
                  static getRootAsInferenceSession(e4, t4) {
                    return (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static getSizePrefixedRootAsInferenceSession(e4, t4) {
                    return e4.setPosition(e4.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
                  }
                  static bufferHasIdentifier(e4) {
                    return e4.__has_identifier("ORTM");
                  }
                  ortVersion(e4) {
                    let t4 = this.bb.__offset(this.bb_pos, 4);
                    return t4 ? this.bb.__string(this.bb_pos + t4, e4) : null;
                  }
                  model(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (t4 || new e3.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  sessionState(t4) {
                    let n3 = this.bb.__offset(this.bb_pos, 8);
                    return n3 ? (t4 || new e3.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startInferenceSession(e4) {
                    e4.startObject(3);
                  }
                  static addOrtVersion(e4, t4) {
                    e4.addFieldOffset(0, t4, 0);
                  }
                  static addModel(e4, t4) {
                    e4.addFieldOffset(1, t4, 0);
                  }
                  static addSessionState(e4, t4) {
                    e4.addFieldOffset(2, t4, 0);
                  }
                  static endInferenceSession(e4) {
                    return e4.endObject();
                  }
                  static finishInferenceSessionBuffer(e4, t4) {
                    e4.finish(t4, "ORTM");
                  }
                  static finishSizePrefixedInferenceSessionBuffer(e4, t4) {
                    e4.finish(t4, "ORTM", true);
                  }
                  static createInferenceSession(e4, t4, r2, o2) {
                    return n2.startInferenceSession(e4), n2.addOrtVersion(e4, t4), n2.addModel(e4, r2), n2.addSessionState(e4, o2), n2.endInferenceSession(e4);
                  }
                }
                t3.InferenceSession = n2;
              })(t2.fbs || (t2.fbs = {}));
            })(e3.experimental || (e3.experimental = {}));
          })(t.onnxruntime || (t.onnxruntime = {}));
        }, 7448: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.OnnxjsSessionHandler = void 0;
          const r = n(1670), o = n(9162);
          t.OnnxjsSessionHandler = class {
            constructor(e3) {
              this.session = e3, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
            }
            async dispose() {
            }
            async run(e3, t2, n2) {
              const i = /* @__PURE__ */ new Map();
              for (const t3 in e3) if (Object.hasOwnProperty.call(e3, t3)) {
                const n3 = e3[t3];
                i.set(t3, new o.Tensor(n3.dims, n3.type, void 0, void 0, n3.data));
              }
              const s = await this.session.run(i), a = {};
              return s.forEach(((e4, t3) => {
                a[t3] = new r.Tensor(e4.type, e4.data, e4.dims);
              })), a;
            }
            startProfiling() {
              this.session.startProfiling();
            }
            endProfiling() {
              this.session.endProfiling();
            }
          };
        }, 6919: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.Session = void 0;
          const r = n(7067), o = n(1296), i = n(7091), s = n(1036), a = n(6231), l = n(2644);
          t.Session = class {
            constructor(e3 = {}) {
              this._initialized = false, this.backendHint = e3.backendHint, this.profiler = a.Profiler.create(e3.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
            }
            get inputNames() {
              return this._model.graph.getInputNames();
            }
            get outputNames() {
              return this._model.graph.getOutputNames();
            }
            startProfiling() {
              this.profiler.start();
            }
            endProfiling() {
              this.profiler.stop();
            }
            async loadModel(e3, t2, n2) {
              await this.profiler.event("session", "Session.loadModel", (async () => {
                const s2 = await (0, i.resolveBackend)(this.backendHint);
                if (this.sessionHandler = s2.createSessionHandler(this.context), this._model = new l.Model(), "string" == typeof e3) {
                  const t3 = e3.endsWith(".ort");
                  if ("undefined" == typeof fetch) {
                    const n3 = await (0, o.promisify)(r.readFile)(e3);
                    this.initialize(n3, t3);
                  } else {
                    const n3 = await fetch(e3), r2 = await n3.arrayBuffer();
                    this.initialize(new Uint8Array(r2), t3);
                  }
                } else if (ArrayBuffer.isView(e3)) this.initialize(e3);
                else {
                  const r2 = new Uint8Array(e3, t2 || 0, n2 || e3.byteLength);
                  this.initialize(r2);
                }
              }));
            }
            initialize(e3, t2) {
              if (this._initialized) throw new Error("already initialized");
              this.profiler.event("session", "Session.initialize", (() => {
                const n2 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
                this._model.load(e3, n2, t2), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new s.ExecutionPlan(this._model.graph, this._ops, this.profiler);
              })), this._initialized = true;
            }
            async run(e3) {
              if (!this._initialized) throw new Error("session not initialized yet");
              return this.profiler.event("session", "Session.run", (async () => {
                const t2 = this.normalizeAndValidateInputs(e3), n2 = await this._executionPlan.execute(this.sessionHandler, t2);
                return this.createOutput(n2);
              }));
            }
            normalizeAndValidateInputs(e3) {
              const t2 = this._model.graph.getInputNames();
              if (Array.isArray(e3)) {
                if (e3.length !== t2.length) throw new Error(`incorrect input array length: expected ${t2.length} but got ${e3.length}`);
              } else {
                if (e3.size !== t2.length) throw new Error(`incorrect input map size: expected ${t2.length} but got ${e3.size}`);
                const n2 = new Array(e3.size);
                let r2 = 0;
                for (let o2 = 0; o2 < t2.length; ++o2) {
                  const i2 = e3.get(t2[o2]);
                  if (!i2) throw new Error(`missing input tensor for: '${name}'`);
                  n2[r2++] = i2;
                }
                e3 = n2;
              }
              if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, e3, false);
              else {
                const t3 = this._model.graph.getInputIndices(), n2 = this._model.graph.getValues(), r2 = new Array(t3.length);
                for (let o2 = 0; o2 < t3.length; ++o2) {
                  const i2 = n2[t3[o2]];
                  r2[o2] = i2.type.shape.dims, this.context.graphInputTypes.push(i2.type.tensorType), this.context.graphInputDims.push(e3[o2].dims);
                }
                this.validateInputTensorDims(r2, e3, true);
              }
              return this.validateInputTensorTypes(this.context.graphInputTypes, e3), e3;
            }
            validateInputTensorTypes(e3, t2) {
              for (let n2 = 0; n2 < t2.length; n2++) {
                const r2 = e3[n2], o2 = t2[n2].type;
                if (r2 !== o2) throw new Error(`input tensor[${n2}] check failed: expected type '${r2}' but got ${o2}`);
              }
            }
            validateInputTensorDims(e3, t2, n2) {
              for (let r2 = 0; r2 < t2.length; r2++) {
                const o2 = e3[r2], i2 = t2[r2].dims;
                if (!this.compareTensorDims(o2, i2, n2)) throw new Error(`input tensor[${r2}] check failed: expected shape '[${o2.join(",")}]' but got [${i2.join(",")}]`);
              }
            }
            compareTensorDims(e3, t2, n2) {
              if (e3.length !== t2.length) return false;
              for (let r2 = 0; r2 < e3.length; ++r2) if (e3[r2] !== t2[r2] && (!n2 || 0 !== e3[r2])) return false;
              return true;
            }
            createOutput(e3) {
              const t2 = this._model.graph.getOutputNames();
              if (e3.length !== t2.length) throw new Error("expected number of outputs do not match number of generated outputs");
              const n2 = /* @__PURE__ */ new Map();
              for (let r2 = 0; r2 < t2.length; ++r2) n2.set(t2[r2], e3[r2]);
              return n2;
            }
            initializeOps(e3) {
              const t2 = e3.getNodes();
              this._ops = new Array(t2.length);
              for (let n2 = 0; n2 < t2.length; n2++) this._ops[n2] = this.sessionHandler.resolve(t2[n2], this._model.opsets, e3);
            }
          };
        }, 9162: function(e2, t, n) {
          var r = this && this.__importDefault || function(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          };
          Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
          const o = n(3442), i = r(n(3720)), s = n(1446), a = n(9395), l = n(2517);
          var c = a.onnxruntime.experimental.fbs;
          class u {
            get data() {
              if (void 0 === this.cache) {
                const e3 = this.dataProvider(this.dataId);
                if (e3.length !== this.size) throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
                this.cache = e3;
              }
              return this.cache;
            }
            get stringData() {
              if ("string" !== this.type) throw new TypeError("data type is not string");
              return this.data;
            }
            get integerData() {
              switch (this.type) {
                case "uint8":
                case "int8":
                case "uint16":
                case "int16":
                case "int32":
                case "uint32":
                case "bool":
                  return this.data;
                default:
                  throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
              }
            }
            get floatData() {
              switch (this.type) {
                case "float32":
                case "float64":
                  return this.data;
                default:
                  throw new TypeError("data type is not float (float32, float64)");
              }
            }
            get numberData() {
              if ("string" !== this.type) return this.data;
              throw new TypeError("type cannot be non-number (string)");
            }
            get(e3) {
              return this.data[l.ShapeUtil.indicesToOffset(e3, this.strides)];
            }
            set(e3, t2) {
              this.data[l.ShapeUtil.indicesToOffset(e3, this.strides)] = t2;
            }
            async getData() {
              return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
            }
            get strides() {
              return this._strides || (this._strides = l.ShapeUtil.computeStrides(this.dims)), this._strides;
            }
            constructor(e3, t2, n2, r2, i2, s2 = o.Guid.create()) {
              this.dims = e3, this.type = t2, this.dataProvider = n2, this.asyncDataProvider = r2, this.cache = i2, this.dataId = s2, this.size = l.ShapeUtil.validateDimsAndCalcSize(e3);
              const a2 = this.size, c2 = void 0 === n2 && void 0 === r2 && void 0 === i2;
              if (void 0 !== i2 && i2.length !== a2) throw new RangeError("Input dims doesn't match data length.");
              if ("string" === t2) {
                if (!(void 0 === i2 || Array.isArray(i2) && i2.every(((e4) => "string" == typeof e4)))) throw new TypeError("cache should be a string array");
                c2 && (this.cache = new Array(a2));
              } else {
                if (void 0 !== i2) {
                  const e4 = d(t2);
                  if (!(i2 instanceof e4)) throw new TypeError(`cache should be type ${e4.name}`);
                }
                if (c2) {
                  const e4 = new ArrayBuffer(a2 * (function(e5) {
                    switch (e5) {
                      case "bool":
                      case "int8":
                      case "uint8":
                        return 1;
                      case "int16":
                      case "uint16":
                        return 2;
                      case "int32":
                      case "uint32":
                      case "float32":
                        return 4;
                      case "float64":
                        return 8;
                      default:
                        throw new Error(`cannot calculate sizeof() on type ${e5}`);
                    }
                  })(t2));
                  this.cache = (function(e5, t3) {
                    return new (d(t3))(e5);
                  })(e4, t2);
                }
              }
            }
            static fromProto(e3) {
              if (!e3) throw new Error("cannot construct Value from an empty tensor");
              const t2 = l.ProtoUtil.tensorDataTypeFromProto(e3.dataType), n2 = l.ProtoUtil.tensorDimsFromProto(e3.dims), r2 = new u(n2, t2);
              if ("string" === t2) e3.stringData.forEach(((e4, t3) => {
                r2.data[t3] = (0, l.decodeUtf8String)(e4);
              }));
              else if (e3.rawData && "number" == typeof e3.rawData.byteLength && e3.rawData.byteLength > 0) {
                const t3 = r2.data, n3 = new DataView(e3.rawData.buffer, e3.rawData.byteOffset, e3.rawData.byteLength), o2 = p(e3.dataType), i2 = e3.rawData.byteLength / o2;
                if (e3.rawData.byteLength % o2 != 0) throw new Error("invalid buffer length");
                if (t3.length !== i2) throw new Error("buffer length mismatch");
                for (let r3 = 0; r3 < i2; r3++) {
                  const i3 = h(n3, e3.dataType, r3 * o2);
                  t3[r3] = i3;
                }
              } else {
                let t3;
                switch (e3.dataType) {
                  case s.onnx.TensorProto.DataType.FLOAT:
                    t3 = e3.floatData;
                    break;
                  case s.onnx.TensorProto.DataType.INT32:
                  case s.onnx.TensorProto.DataType.INT16:
                  case s.onnx.TensorProto.DataType.UINT16:
                  case s.onnx.TensorProto.DataType.INT8:
                  case s.onnx.TensorProto.DataType.UINT8:
                  case s.onnx.TensorProto.DataType.BOOL:
                    t3 = e3.int32Data;
                    break;
                  case s.onnx.TensorProto.DataType.INT64:
                    t3 = e3.int64Data;
                    break;
                  case s.onnx.TensorProto.DataType.DOUBLE:
                    t3 = e3.doubleData;
                    break;
                  case s.onnx.TensorProto.DataType.UINT32:
                  case s.onnx.TensorProto.DataType.UINT64:
                    t3 = e3.uint64Data;
                    break;
                  default:
                    throw new Error("unspecific error");
                }
                if (null == t3) throw new Error("failed to populate data from a tensorproto value");
                const n3 = r2.data;
                if (n3.length !== t3.length) throw new Error("array length mismatch");
                for (let r3 = 0; r3 < t3.length; r3++) {
                  const o2 = t3[r3];
                  i.default.isLong(o2) ? n3[r3] = _(o2, e3.dataType) : n3[r3] = o2;
                }
              }
              return r2;
            }
            static fromData(e3, t2, n2) {
              return new u(t2, n2, void 0, void 0, e3);
            }
            static fromOrtTensor(e3) {
              if (!e3) throw new Error("cannot construct Value from an empty tensor");
              const t2 = l.ProtoUtil.tensorDimsFromORTFormat(e3), n2 = l.ProtoUtil.tensorDataTypeFromProto(e3.dataType()), r2 = new u(t2, n2);
              if ("string" === n2) for (let t3 = 0; t3 < e3.stringDataLength(); t3++) r2.data[t3] = e3.stringData(t3);
              else if (e3.rawDataArray() && "number" == typeof e3.rawDataLength() && e3.rawDataLength() > 0) {
                const t3 = r2.data, n3 = new DataView(e3.rawDataArray().buffer, e3.rawDataArray().byteOffset, e3.rawDataLength()), o2 = p(e3.dataType()), i2 = e3.rawDataLength() / o2;
                if (e3.rawDataLength() % o2 != 0) throw new Error("invalid buffer length");
                if (t3.length !== i2) throw new Error("buffer length mismatch");
                for (let r3 = 0; r3 < i2; r3++) {
                  const i3 = h(n3, e3.dataType(), r3 * o2);
                  t3[r3] = i3;
                }
              }
              return r2;
            }
          }
          function p(e3) {
            switch (e3) {
              case s.onnx.TensorProto.DataType.UINT8:
              case s.onnx.TensorProto.DataType.INT8:
              case s.onnx.TensorProto.DataType.BOOL:
                return 1;
              case s.onnx.TensorProto.DataType.UINT16:
              case s.onnx.TensorProto.DataType.INT16:
                return 2;
              case s.onnx.TensorProto.DataType.FLOAT:
              case s.onnx.TensorProto.DataType.INT32:
              case s.onnx.TensorProto.DataType.UINT32:
                return 4;
              case s.onnx.TensorProto.DataType.INT64:
              case s.onnx.TensorProto.DataType.DOUBLE:
              case s.onnx.TensorProto.DataType.UINT64:
                return 8;
              default:
                throw new Error(`cannot calculate sizeof() on type ${s.onnx.TensorProto.DataType[e3]}`);
            }
          }
          function d(e3) {
            switch (e3) {
              case "bool":
              case "uint8":
                return Uint8Array;
              case "int8":
                return Int8Array;
              case "int16":
                return Int16Array;
              case "uint16":
                return Uint16Array;
              case "int32":
                return Int32Array;
              case "uint32":
                return Uint32Array;
              case "float32":
                return Float32Array;
              case "float64":
                return Float64Array;
              default:
                throw new Error("unspecified error");
            }
          }
          function _(e3, t2) {
            if (t2 === s.onnx.TensorProto.DataType.INT64 || t2 === c.TensorDataType.INT64) {
              if (e3.greaterThanOrEqual(2147483648) || e3.lessThan(-2147483648)) throw new TypeError("int64 is not supported");
            } else {
              if (t2 !== s.onnx.TensorProto.DataType.UINT32 && t2 !== c.TensorDataType.UINT32 && t2 !== s.onnx.TensorProto.DataType.UINT64 && t2 !== c.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${s.onnx.TensorProto.DataType[t2]}`);
              if (e3.greaterThanOrEqual(4294967296) || e3.lessThan(0)) throw new TypeError("uint64 is not supported");
            }
            return e3.toNumber();
          }
          function h(e3, t2, n2) {
            switch (t2) {
              case s.onnx.TensorProto.DataType.BOOL:
              case s.onnx.TensorProto.DataType.UINT8:
                return e3.getUint8(n2);
              case s.onnx.TensorProto.DataType.INT8:
                return e3.getInt8(n2);
              case s.onnx.TensorProto.DataType.UINT16:
                return e3.getUint16(n2, true);
              case s.onnx.TensorProto.DataType.INT16:
                return e3.getInt16(n2, true);
              case s.onnx.TensorProto.DataType.FLOAT:
                return e3.getFloat32(n2, true);
              case s.onnx.TensorProto.DataType.INT32:
                return e3.getInt32(n2, true);
              case s.onnx.TensorProto.DataType.UINT32:
                return e3.getUint32(n2, true);
              case s.onnx.TensorProto.DataType.INT64:
                return _(i.default.fromBits(e3.getUint32(n2, true), e3.getUint32(n2 + 4, true), false), t2);
              case s.onnx.TensorProto.DataType.DOUBLE:
                return e3.getFloat64(n2, true);
              case s.onnx.TensorProto.DataType.UINT64:
                return _(i.default.fromBits(e3.getUint32(n2, true), e3.getUint32(n2 + 4, true), true), t2);
              default:
                throw new Error(`cannot read from DataView for type ${s.onnx.TensorProto.DataType[t2]}`);
            }
          }
          t.Tensor = u;
        }, 2517: function(e2, t, n) {
          var r = this && this.__importDefault || function(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          };
          Object.defineProperty(t, "__esModule", { value: true }), t.decodeUtf8String = t.MAX_CLIP = t.MIN_CLIP = t.PoolConvUtil = t.ReduceUtil = t.SplitUtil = t.MathUtil = t.ShapeUtil = t.LongUtil = t.ProtoUtil = t.GemmUtil = t.arrayCopyHelper = t.BroadcastUtil = t.MatMulUtil = t.ArrayUtil = t.assert = t.checkInputsShape = void 0;
          const o = n(5686), i = r(n(3720)), s = n(1446), a = n(9162);
          t.checkInputsShape = function(e3, ...t2) {
            if (!e3 || e3.length !== t2.length) return false;
            for (let n2 = 0; n2 < e3.length; n2++) if (!e3[n2].dims || e3[n2].dims.length !== t2[n2]) return false;
            return true;
          }, t.assert = function(e3, t2) {
            if (!e3) throw new Error("string" == typeof t2 ? t2 : t2());
          }, t.ArrayUtil = class {
            static arraysEqual(e3, t2) {
              if (e3.length !== t2.length) return false;
              for (let n2 = 0; n2 < e3.length; n2++) if (e3[n2] !== t2[n2]) return false;
              return true;
            }
          };
          class l {
            static preprocessInputShapes(e3, t2) {
              return [1 === e3.length ? [1, e3[0]] : e3, 1 === t2.length ? [t2[0], 1] : t2];
            }
            static postprocessOutputShape(e3, t2, n2) {
              1 === t2 && e3.splice(e3.length - 2, 1), 1 === n2 && e3.pop();
            }
            static calcMatMulShape(e3, t2) {
              return e3[1] !== t2[0] ? void 0 : [e3[0], t2[1]];
            }
          }
          t.MatMulUtil = l;
          class c {
            static calcShape(e3, t2, n2 = false) {
              const r2 = e3.length, o2 = t2.length;
              if (0 === r2) return t2;
              if (0 === o2) return e3;
              const i2 = Math.max(e3.length, t2.length), s2 = new Array(i2);
              if (n2) {
                if (r2 < 2 || o2 < 2) return;
                const n3 = l.calcMatMulShape([e3[r2 - 2], e3[r2 - 1]], [t2[o2 - 2], t2[o2 - 1]]);
                if (void 0 === n3) return;
                [s2[i2 - 2], s2[i2 - 1]] = n3;
              }
              for (let a2 = n2 ? 3 : 1; a2 <= i2; a2++) {
                const n3 = r2 - a2 < 0 ? 1 : e3[r2 - a2], l2 = o2 - a2 < 0 ? 1 : t2[o2 - a2];
                if (n3 !== l2 && n3 > 1 && l2 > 1) return;
                s2[i2 - a2] = Math.max(n3, l2);
              }
              return s2;
            }
            static index(e3, t2) {
              const n2 = new Array(t2.length);
              return c.fillIndex(e3, t2, n2), n2;
            }
            static fillIndex(e3, t2, n2) {
              const r2 = e3.length - t2.length;
              for (let o2 = 0; o2 < t2.length; o2++) n2[o2] = e3[r2 + o2] % t2[o2];
            }
            static calc(e3, t2, n2, r2, o2) {
              const i2 = c.calcShape(e3.dims, t2.dims);
              if (i2) {
                if (r2 && !d.areEqual(i2, e3.dims)) return;
                const s2 = d.size(i2), l2 = r2 ? e3 : new a.Tensor(i2, o2 || e3.type);
                if (0 === i2.length) l2.set([], n2(e3.get([]), t2.get([])));
                else {
                  const r3 = new Array(i2.length), o3 = new Array(e3.dims.length), a2 = new Array(t2.dims.length);
                  let u2, p2 = 0, d2 = 0, _2 = false, h2 = false;
                  0 === e3.dims.length && (p2 = e3.get([]), _2 = true), 0 === t2.dims.length && (d2 = t2.get([]), h2 = true);
                  for (let f2 = 0; f2 < s2; f2++) {
                    u2 = f2;
                    for (let e4 = i2.length - 1; e4 >= 0; e4--) r3[e4] = u2 % i2[e4], u2 = Math.floor(u2 / i2[e4]);
                    _2 || (c.fillIndex(r3, e3.dims, o3), p2 = e3.get(o3)), h2 || (c.fillIndex(r3, t2.dims, a2), d2 = t2.get(a2)), l2.set(r3, n2(p2, d2));
                  }
                }
                return l2;
              }
            }
            static isValidBroadcast(e3, t2) {
              const n2 = e3.length, r2 = t2.length;
              if (n2 > r2) return false;
              for (let o2 = 1; o2 <= n2; o2++) if (1 !== e3[n2 - o2] && e3[n2 - o2] !== t2[r2 - o2]) return false;
              return true;
            }
            static getBroadcastDims(e3, t2) {
              const n2 = e3.length, r2 = [];
              for (let o2 = 0; o2 < n2; o2++) {
                const i2 = n2 - 1 - o2, s2 = e3[i2] || 1;
                (t2[t2.length - 1 - o2] || 1) > 1 && 1 === s2 && r2.unshift(i2);
              }
              return r2;
            }
          }
          t.BroadcastUtil = c, t.arrayCopyHelper = function(e3, t2, n2, r2, o2) {
            if (r2 < 0 || r2 >= t2.length) throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e3.length) throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length) throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e3.length) throw new Error("target array is too small to hold result");
            for (let i2 = 0; i2 < o2; i2++) e3[n2 + i2] = t2[r2 + i2];
          }, t.GemmUtil = class {
            static getShapeOfGemmResult(e3, t2, n2, r2, o2) {
              if (2 !== e3.length || 2 !== n2.length) throw new Error("shape need to be of size 2");
              let i2, s2, a2;
              t2 ? (i2 = e3[1], s2 = e3[0]) : (i2 = e3[0], s2 = e3[1]);
              let l2 = -1;
              if (r2 ? (a2 = n2[0], l2 = 1) : (a2 = n2[1], l2 = 0), n2[l2] !== s2) throw new Error("dimension mismatch");
              if (i2 <= 0 || a2 <= 0 || s2 <= 0) throw new Error("invalid shape specified");
              if (o2 && !c.isValidBroadcast(o2, [i2, a2])) throw new Error("gemm: invalid bias shape for broadcast");
              return [i2, a2, s2];
            }
          };
          class u {
            static tensorDataTypeFromProto(e3) {
              switch (e3) {
                case s.onnx.TensorProto.DataType.INT8:
                  return "int8";
                case s.onnx.TensorProto.DataType.UINT8:
                  return "uint8";
                case s.onnx.TensorProto.DataType.BOOL:
                  return "bool";
                case s.onnx.TensorProto.DataType.INT16:
                  return "int16";
                case s.onnx.TensorProto.DataType.UINT16:
                  return "uint16";
                case s.onnx.TensorProto.DataType.INT32:
                  return "int32";
                case s.onnx.TensorProto.DataType.UINT32:
                  return "uint32";
                case s.onnx.TensorProto.DataType.FLOAT:
                  return "float32";
                case s.onnx.TensorProto.DataType.DOUBLE:
                  return "float64";
                case s.onnx.TensorProto.DataType.STRING:
                  return "string";
                case s.onnx.TensorProto.DataType.INT64:
                  return "int32";
                case s.onnx.TensorProto.DataType.UINT64:
                  return "uint32";
                default:
                  throw new Error(`unsupported data type: ${s.onnx.TensorProto.DataType[e3]}`);
              }
            }
            static tensorDataTypeStringToEnum(e3) {
              switch (e3) {
                case "int8":
                  return s.onnx.TensorProto.DataType.INT8;
                case "uint8":
                  return s.onnx.TensorProto.DataType.UINT8;
                case "bool":
                  return s.onnx.TensorProto.DataType.BOOL;
                case "int16":
                  return s.onnx.TensorProto.DataType.INT16;
                case "uint16":
                  return s.onnx.TensorProto.DataType.UINT16;
                case "int32":
                  return s.onnx.TensorProto.DataType.INT32;
                case "uint32":
                  return s.onnx.TensorProto.DataType.UINT32;
                case "float32":
                  return s.onnx.TensorProto.DataType.FLOAT;
                case "float64":
                  return s.onnx.TensorProto.DataType.DOUBLE;
                case "string":
                  return s.onnx.TensorProto.DataType.STRING;
                case "int64":
                  return s.onnx.TensorProto.DataType.INT64;
                case "uint64":
                  return s.onnx.TensorProto.DataType.UINT64;
                default:
                  throw new Error(`unsupported data type: ${e3}`);
              }
            }
            static tensorDimsFromProto(e3) {
              return e3.map(((e4) => i.default.isLong(e4) ? e4.toNumber() : e4));
            }
            static tensorValueTypeFromProto(e3) {
              return { tensorType: u.tensorDataTypeFromProto(e3.elemType), shape: { dims: u.tensorDimsFromProto(e3.shape.dim.map(((e4) => e4.dimValue))) } };
            }
            static tensorDimsFromORTFormat(e3) {
              const t2 = [];
              for (let n2 = 0; n2 < e3.dimsLength(); n2++) t2.push(p.longToNumber(e3.dims(n2)));
              return t2;
            }
            static tensorAttributesFromORTFormat(e3) {
              const t2 = [];
              for (let n2 = 0; n2 < e3.attributesLength(); n2++) t2.push(e3.attributes(n2));
              return t2;
            }
          }
          t.ProtoUtil = u;
          class p {
            static longToNumber(e3, t2) {
              return i.default.isLong(e3) ? e3.toNumber() : e3 instanceof o.flatbuffers.Long ? i.default.fromValue({ low: e3.low, high: e3.high, unsigned: null != t2 && t2 }).toNumber() : e3;
            }
            static isLong(e3) {
              return i.default.isLong(e3) || e3 instanceof o.flatbuffers.Long;
            }
          }
          t.LongUtil = p;
          class d {
            static size(e3) {
              return d.getSizeFromDimensionRange(e3, 0, e3.length);
            }
            static sizeFromDimension(e3, t2) {
              if (t2 < 0 || t2 > e3.length) throw new Error(`invalid dimension of ${t2} for sizeFromDimension as Tensor has ${e3.length} dimensions.`);
              return d.getSizeFromDimensionRange(e3, t2, e3.length);
            }
            static sizeToDimension(e3, t2) {
              if (t2 < 0 || t2 > e3.length) throw new Error(`invalid dimension of ${t2} for sizeToDimension as Tensor has ${e3.length} dimensions.`);
              return d.getSizeFromDimensionRange(e3, 0, t2);
            }
            static getSizeFromDimensionRange(e3, t2, n2) {
              let r2 = 1;
              for (let o2 = t2; o2 < n2; o2++) {
                if (e3[o2] <= 0) throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
                r2 *= e3[o2];
              }
              return r2;
            }
            static computeStrides(e3) {
              const t2 = e3.length;
              if (0 === t2) return [];
              if (1 === t2) return [1];
              const n2 = new Array(t2);
              n2[t2 - 1] = 1, n2[t2 - 2] = e3[t2 - 1];
              for (let r2 = t2 - 3; r2 >= 0; --r2) n2[r2] = n2[r2 + 1] * e3[r2 + 1];
              return n2;
            }
            static transpose(e3) {
              return e3.slice().reverse();
            }
            static indicesToOffset(e3, t2, n2) {
              void 0 === n2 && (n2 = e3.length);
              let r2 = 0;
              for (let o2 = 0; o2 < n2; ++o2) r2 += t2[o2] * e3[o2];
              return r2;
            }
            static offsetToIndices(e3, t2) {
              const n2 = t2.length;
              if (0 === n2) return [];
              if (1 === n2) return [e3 * t2[0]];
              const r2 = new Array(t2.length);
              for (let n3 = 0; n3 < r2.length - 1; ++n3) r2[n3] = Math.floor(e3 / t2[n3]), e3 -= r2[n3] * t2[n3];
              return r2[r2.length - 1] = e3, r2;
            }
            static normalizeAxis(e3, t2) {
              if (e3 < -t2 && e3 >= t2) throw new Error("unsupported axis for this operation.");
              return e3 < 0 ? e3 + t2 : e3;
            }
            static normalizeAxes(e3, t2) {
              return e3.map(((e4) => this.normalizeAxis(e4, t2)));
            }
            static incrementIndex(e3, t2, n2) {
              if (0 === t2.length || 0 === e3.length) throw new Error("Index incrementing unsupported for scalar Tensor");
              if (void 0 === n2) n2 = t2.length;
              else if (n2 <= 0 || n2 > t2.length) throw new Error("Incorrect axis to increment on");
              for (let r2 = n2 - 1; r2 >= 0 && (e3[r2]++, !(e3[r2] < t2[r2])); --r2) e3[r2] = 0;
            }
            static calculateReshapedDims(e3, t2) {
              if (0 === t2.length) {
                if (0 === e3.length || 1 === d.size(e3)) return [];
                throw new Error("cannot reshape to a scalar Tensor");
              }
              const n2 = t2.length, r2 = new Array(n2);
              let o2 = -1, i2 = 1;
              for (let s3 = 0; s3 < n2; s3++) {
                if (t2[s3] < -1) throw new Error("a dimension in shape hints cannot be less than -1");
                if (-1 === t2[s3]) {
                  if (-1 !== o2) throw new Error("at most one dimension in shape hints can be -1");
                  o2 = s3;
                } else {
                  if (0 === t2[s3]) {
                    if (s3 >= e3.length) throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                    r2[s3] = e3[s3];
                  } else r2[s3] = t2[s3];
                  i2 *= r2[s3];
                }
              }
              const s2 = d.size(e3);
              if (-1 !== o2) {
                if (s2 % i2 != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e3}] Output shape: [${t2}]`);
                r2[o2] = s2 / i2;
              } else if (i2 !== s2) throw new Error("reshapedDims and originalDims don't have matching sizes");
              return r2;
            }
            static sortBasedOnPerm(e3, t2) {
              return t2 ? t2.map(((t3) => e3[t3])) : e3.slice().reverse();
            }
            static padShape(e3, t2) {
              const n2 = e3.length;
              return e3.map(((e4, r2) => e4 + t2[r2] + t2[r2 + n2]));
            }
            static areEqual(e3, t2) {
              return e3.length === t2.length && e3.every(((e4, n2) => e4 === t2[n2]));
            }
            static validateDimsAndCalcSize(e3) {
              if (e3.length > 6) throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
              let t2 = 1;
              for (const n2 of e3) {
                if (!Number.isInteger(n2)) throw new TypeError(`Invalid shape: ${n2} is not an integer`);
                if (n2 < 0 || n2 > 2147483647) throw new TypeError(`Invalid shape: length ${n2} is not allowed`);
                t2 *= n2;
              }
              return t2;
            }
            static flattenShape(e3, t2) {
              t2 < 0 && (t2 += e3.length);
              const n2 = e3.reduce(((e4, t3) => e4 * t3), 1), r2 = e3.slice(t2).reduce(((e4, t3) => e4 * t3), 1);
              return [n2 / r2, r2];
            }
            static squeezeShape(e3, t2) {
              const n2 = new Array();
              t2 = d.normalizeAxes(t2, e3.length);
              for (let r2 = 0; r2 < e3.length; r2++) {
                const o2 = t2.indexOf(r2) >= 0;
                if (o2 && 1 !== e3[r2]) throw new Error("squeeze an axis of size different than 1");
                (0 === t2.length && e3[r2] > 1 || t2.length > 0 && !o2) && n2.push(e3[r2]);
              }
              return n2;
            }
            static unsqueezeShape(e3, t2) {
              const n2 = new Array(e3.length + t2.length);
              n2.fill(0);
              for (let e4 = 0; e4 < t2.length; e4++) {
                const r3 = d.normalizeAxis(t2[e4], n2.length);
                if (r3 >= n2.length) throw new Error("'axes' has an out of range axis");
                if (0 !== n2[r3]) throw new Error("'axes' has a duplicate axis");
                n2[r3] = 1;
              }
              let r2 = 0;
              for (let t3 = 0; t3 < n2.length; t3++) 0 === n2[t3] && (n2[t3] = e3[r2++]);
              if (r2 !== e3.length) throw new Error("the unsqueezed dimension could not be established");
              return n2;
            }
          }
          t.ShapeUtil = d, t.MathUtil = class {
            static sqr(e3, t2, n2, r2, o2) {
              if (r2 < 0 || r2 >= t2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= e3.length) throw new Error("targetIndex out of bounds");
              if (r2 + o2 > t2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + o2 > e3.length) throw new Error("target array is too small to hold result");
              for (let i2 = 0; i2 < o2; i2++) e3[n2 + i2] += Math.pow(t2[r2 + i2], 2);
            }
            static axpy(e3, t2, n2, r2, o2, i2) {
              if (r2 < 0 || r2 >= t2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= e3.length) throw new Error("targetIndex out of bounds");
              if (r2 + o2 > t2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + o2 > e3.length) throw new Error("target array is too small to hold result");
              for (let s2 = 0; s2 < o2; s2++) e3[n2 + s2] += i2 * t2[r2 + s2];
            }
            static powx(e3, t2, n2, r2, o2, i2) {
              if (r2 < 0 || r2 >= t2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= e3.length) throw new Error("targetIndex out of bounds");
              if (r2 + o2 > t2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + o2 > e3.length) throw new Error("target array is too small to hold result");
              for (let s2 = 0; s2 < o2; s2++) e3[n2 + s2] = Math.pow(t2[r2 + s2], i2);
            }
            static mul(e3, t2, n2, r2, o2) {
              if (r2 < 0 || r2 >= t2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= e3.length) throw new Error("targetIndex out of bounds");
              if (r2 + o2 > t2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + o2 > e3.length) throw new Error("target array is too small to hold result");
              for (let i2 = 0; i2 < o2; i2++) e3[n2 + i2] = t2[r2 + i2] * e3[n2 + i2];
            }
          };
          class _ {
            static splitShape(e3, t2, n2, r2) {
              if (0 === n2.length) {
                if (!r2) throw new Error("need to know number of outputs when the 'split' attribute is not specified");
                _.determineSplit(e3[t2], r2, n2);
              }
              const o2 = [], i2 = [0];
              for (let r3 = 0; r3 < n2.length; ++r3) {
                0 !== r3 && i2.push(i2[r3 - 1] + n2[r3 - 1]);
                const s2 = e3.slice();
                s2[t2] = n2[r3], o2.push(s2);
              }
              return [o2, i2];
            }
            static determineSplit(e3, t2, n2) {
              if (e3 % t2 != 0) throw new Error("cannot split tensor to equal sized parts");
              for (let r2 = 0; r2 < t2; ++r2) n2.push(e3 / t2);
            }
          }
          t.SplitUtil = _;
          class h {
            static calcReduce(e3, t2, n2, r2, o2) {
              const i2 = e3.dims.slice(0);
              0 === t2.length && i2.forEach(((e4, n3) => t2.push(n3)));
              const s2 = h.calcReduceShape(i2, t2, true), l2 = d.size(s2), u2 = new a.Tensor(s2, e3.type), p2 = d.computeStrides(s2), _2 = d.computeStrides(i2), f2 = new Array(i2.length);
              for (let n3 = 0; n3 < l2; n3++) {
                const s3 = d.offsetToIndices(n3, p2);
                c.fillIndex(s3, i2, f2), u2.set(s3, h.calcReduceByAxis(e3.numberData, t2, i2, 0, d.indicesToOffset(f2, _2), r2, o2));
              }
              return n2 ? u2 : new a.Tensor(h.calcReduceShape(i2, t2, n2), u2.type, void 0, void 0, u2.data, u2.dataId);
            }
            static calcReduceByAxis(e3, t2, n2, r2, o2, i2, s2) {
              let a2 = 0;
              if (r2 >= t2.length) return i2(e3[o2]);
              const l2 = t2[r2], c2 = l2 >= n2.length ? 1 : d.size(n2.slice(l2 + 1));
              for (let u2 = 0; u2 < n2[l2]; u2++) a2 = 0 === u2 ? h.calcReduceByAxis(e3, t2, n2, r2 + 1, o2, i2, s2) : s2(a2, h.calcReduceByAxis(e3, t2, n2, r2 + 1, o2, i2, s2)), o2 += c2;
              return a2;
            }
            static calcReduceShape(e3, t2, n2) {
              const r2 = e3.slice();
              for (let e4 = 0; e4 < t2.length; e4++) r2[t2[e4]] = n2 ? 1 : 0;
              return r2.filter(((e4) => 0 !== e4));
            }
          }
          t.ReduceUtil = h;
          class f {
            static adjustPoolAttributes(e3, t2, n2, r2, o2, i2) {
              if (!e3 && n2.length !== t2.length - 2) throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
              if (e3) for (let e4 = 0; e4 < t2.length - 2; e4++) e4 >= n2.length ? n2.push(t2[e4 + 2]) : n2[e4] = t2[e4 + 2];
              for (let e4 = 0; e4 < n2.length; e4++) if (e4 < r2.length) {
                if (r2[e4] < 0) throw new Error("strides should be greater than or equal to 1");
              } else r2.push(1);
              for (let e4 = 0; e4 < n2.length; e4++) if (e4 < o2.length) {
                if (o2[e4] < 0) throw new Error("dilations should be greater than or equal to 1");
              } else o2.push(1);
              for (let e4 = 0; e4 < 2 * n2.length; e4++) if (e4 < i2.length) {
                if (i2[e4] < 0) throw new Error("pad should be greater than or equal to 1");
              } else i2.push(0);
              for (let e4 = 0; e4 < n2.length; e4++) {
                if (n2[e4] <= 0) throw new Error("kernel shapes need to be greater than 0");
                if (i2[e4] >= n2[e4] || i2[e4 + n2.length] >= n2[e4]) throw new Error("pads should be smaller than kernel");
              }
            }
            static adjustPadsBasedOnAutoPad(e3, t2, n2, r2, o2, i2) {
              if (i2) {
                if (o2.length !== 2 * (e3.length - 2)) throw new Error("length of pads should be twice the length of data dimensions");
                if (t2.length !== e3.length - 2) throw new Error("length of strides should be the length of data dimensions");
                if (r2.length !== e3.length - 2) throw new Error("length of kernel shapes should be the length of data dimensions");
                for (let s2 = 0; s2 < e3.length - 2; s2++) f.adjustPadAndReturnShape(e3[s2 + 2], t2[s2], n2[s2], r2[s2], o2, s2, s2 + e3.length - 2, i2);
              }
            }
            static computePoolOutputShape(e3, t2, n2, r2, o2, i2, s2) {
              if (t2.length <= 0) throw new Error("input shape must be of size greater than 0");
              const a2 = [t2[0], t2[1]];
              return f.computeShapeHelper(e3, t2, a2, n2, r2, o2, i2, s2), a2;
            }
            static computeConvOutputShape(e3, t2, n2, r2, o2, i2, s2) {
              if (e3.length <= 0 || t2.length <= 0) throw new Error("invalid input tensor dims or invalid filter tensor dims");
              const a2 = [e3[0], t2[0]];
              return f.computeShapeHelper(false, e3, a2, n2, r2, o2, i2, s2), a2;
            }
            static computeShapeHelper(e3, t2, n2, r2, o2, i2, s2, a2) {
              if (e3) for (let e4 = 0; e4 < t2.length - 2; e4++) n2.push(1);
              else for (let e4 = 0; e4 < t2.length - 2; e4++) n2.push(f.adjustPadAndReturnShape(t2[e4 + 2], r2[e4], o2[e4], i2[e4], s2, e4, e4 + t2.length - 2, a2));
            }
            static adjustPadAndReturnShape(e3, t2, n2, r2, o2, i2, s2, a2) {
              const l2 = n2 * (r2 - 1) + 1;
              if (!a2 || "NOTSET" === a2) return Math.floor((e3 + o2[i2] + o2[s2] - l2) / t2 + 1);
              switch (a2) {
                case "VALID":
                  return o2[i2] = 0, o2[s2] = 0, Math.floor((e3 - l2) / t2 + 1);
                case "SAME_LOWER":
                case "SAME_UPPER":
                  if (1 !== n2) throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                  {
                    const n3 = ((e3 + t2 - 1) / t2 - 1) * t2 + r2 - e3;
                    return o2[i2] = "SAME_LOWER" === a2 ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), o2[s2] = n3 - o2[i2], Math.floor((e3 + n3 - r2) / t2 + 1);
                  }
                default:
                  throw new Error("Unsupported AutoPad type");
              }
            }
          }
          t.PoolConvUtil = f, t.MIN_CLIP = -34028234663852886e22, t.MAX_CLIP = 34028234663852886e22, t.decodeUtf8String = function(e3) {
            return new TextDecoder().decode(e3);
          };
        }, 7967: (e2, t) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.iterateExtraOptions = void 0, t.iterateExtraOptions = (e3, n, r, o) => {
            if ("object" == typeof e3 && null !== e3) {
              if (r.has(e3)) throw new Error("Circular reference in options");
              r.add(e3);
            }
            Object.entries(e3).forEach((([e4, i]) => {
              const s = n ? n + e4 : e4;
              if ("object" == typeof i) (0, t.iterateExtraOptions)(i, s + ".", r, o);
              else if ("string" == typeof i || "number" == typeof i) o(s, i.toString());
              else {
                if ("boolean" != typeof i) throw new Error("Can't handle extra config type: " + typeof i);
                o(s, i ? "1" : "0");
              }
            }));
          };
        }, 2157: function(e2, t, n) {
          var r, o = this && this.__createBinding || (Object.create ? function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var o2 = Object.getOwnPropertyDescriptor(t2, n2);
            o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
              return t2[n2];
            } }), Object.defineProperty(e3, r2, o2);
          } : function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2), e3[r2] = t2[n2];
          }), i = this && this.__setModuleDefault || (Object.create ? function(e3, t2) {
            Object.defineProperty(e3, "default", { enumerable: true, value: t2 });
          } : function(e3, t2) {
            e3.default = t2;
          }), s = this && this.__importStar || function(e3) {
            if (e3 && e3.__esModule) return e3;
            var t2 = {};
            if (null != e3) for (var n2 in e3) "default" !== n2 && Object.prototype.hasOwnProperty.call(e3, n2) && o(t2, e3, n2);
            return i(t2, e3), t2;
          };
          Object.defineProperty(t, "__esModule", { value: true }), t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initOrt = t.initWasm = void 0;
          const a = n(1670), l = s(n(349)), c = n(6361), u = () => !!a.env.wasm.proxy && "undefined" != typeof document;
          let p, d, _, h = false, f = false, m = false;
          const g = [], b = [], w = [], x = [], y = [], T = [], v = () => {
            if (h || !f || m || !p) throw new Error("worker not ready");
          }, k = (e3) => {
            switch (e3.data.type) {
              case "init-wasm":
                h = false, e3.data.err ? (m = true, d[1](e3.data.err)) : (f = true, d[0]());
                break;
              case "init-ort":
                e3.data.err ? _[1](e3.data.err) : _[0]();
                break;
              case "create_allocate":
                e3.data.err ? g.shift()[1](e3.data.err) : g.shift()[0](e3.data.out);
                break;
              case "create_finalize":
                e3.data.err ? b.shift()[1](e3.data.err) : b.shift()[0](e3.data.out);
                break;
              case "create":
                e3.data.err ? w.shift()[1](e3.data.err) : w.shift()[0](e3.data.out);
                break;
              case "release":
                e3.data.err ? x.shift()[1](e3.data.err) : x.shift()[0]();
                break;
              case "run":
                e3.data.err ? y.shift()[1](e3.data.err) : y.shift()[0](e3.data.out);
                break;
              case "end-profiling":
                e3.data.err ? T.shift()[1](e3.data.err) : T.shift()[0]();
            }
          }, M = "undefined" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;
          t.initWasm = async () => {
            if (u()) {
              if (f) return;
              if (h) throw new Error("multiple calls to 'initWasm()' detected.");
              if (m) throw new Error("previous call to 'initWasm()' failed.");
              return h = true, void 0 === a.env.wasm.wasmPaths && M && 0 !== M.indexOf("blob:") && (a.env.wasm.wasmPaths = M.substr(0, +M.lastIndexOf("/") + 1)), new Promise(((e3, t2) => {
                null == p || p.terminate(), p = n(9710).Z(), p.onmessage = k, d = [e3, t2];
                const r2 = { type: "init-wasm", in: a.env.wasm };
                p.postMessage(r2);
              }));
            }
            return (0, c.initializeWebAssembly)(a.env.wasm);
          }, t.initOrt = async (e3, t2) => {
            if (u()) return v(), new Promise(((n2, r2) => {
              _ = [n2, r2];
              const o2 = { type: "init-ort", in: { numThreads: e3, loggingLevel: t2 } };
              p.postMessage(o2);
            }));
            l.initOrt(e3, t2);
          }, t.createSessionAllocate = async (e3) => u() ? (v(), new Promise(((t2, n2) => {
            g.push([t2, n2]);
            const r2 = { type: "create_allocate", in: { model: e3 } };
            p.postMessage(r2, [e3.buffer]);
          }))) : l.createSessionAllocate(e3), t.createSessionFinalize = async (e3, t2) => u() ? (v(), new Promise(((n2, r2) => {
            b.push([n2, r2]);
            const o2 = { type: "create_finalize", in: { modeldata: e3, options: t2 } };
            p.postMessage(o2);
          }))) : l.createSessionFinalize(e3, t2), t.createSession = async (e3, t2) => u() ? (v(), new Promise(((n2, r2) => {
            w.push([n2, r2]);
            const o2 = { type: "create", in: { model: e3, options: t2 } };
            p.postMessage(o2, [e3.buffer]);
          }))) : l.createSession(e3, t2), t.releaseSession = async (e3) => {
            if (u()) return v(), new Promise(((t2, n2) => {
              x.push([t2, n2]);
              const r2 = { type: "release", in: e3 };
              p.postMessage(r2);
            }));
            l.releaseSession(e3);
          }, t.run = async (e3, t2, n2, r2, o2) => u() ? (v(), new Promise(((i2, s2) => {
            y.push([i2, s2]);
            const a2 = { type: "run", in: { sessionId: e3, inputIndices: t2, inputs: n2, outputIndices: r2, options: o2 } };
            p.postMessage(a2, l.extractTransferableBuffers(n2));
          }))) : l.run(e3, t2, n2, r2, o2), t.endProfiling = async (e3) => {
            if (u()) return v(), new Promise(((t2, n2) => {
              T.push([t2, n2]);
              const r2 = { type: "end-profiling", in: e3 };
              p.postMessage(r2);
            }));
            l.endProfiling(e3);
          };
        }, 586: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.setRunOptions = void 0;
          const r = n(7967), o = n(4983), i = n(6361);
          t.setRunOptions = (e3) => {
            const t2 = (0, i.getInstance)();
            let n2 = 0;
            const s = [], a = e3 || {};
            try {
              if (void 0 === (null == e3 ? void 0 : e3.logSeverityLevel)) a.logSeverityLevel = 2;
              else if ("number" != typeof e3.logSeverityLevel || !Number.isInteger(e3.logSeverityLevel) || e3.logSeverityLevel < 0 || e3.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e3.logSeverityLevel}`);
              if (void 0 === (null == e3 ? void 0 : e3.logVerbosityLevel)) a.logVerbosityLevel = 0;
              else if ("number" != typeof e3.logVerbosityLevel || !Number.isInteger(e3.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e3.logVerbosityLevel}`);
              void 0 === (null == e3 ? void 0 : e3.terminate) && (a.terminate = false);
              let i2 = 0;
              if (void 0 !== (null == e3 ? void 0 : e3.tag) && (i2 = (0, o.allocWasmString)(e3.tag, s)), n2 = t2._OrtCreateRunOptions(a.logSeverityLevel, a.logVerbosityLevel, !!a.terminate, i2), 0 === n2) throw new Error("Can't create run options");
              return void 0 !== (null == e3 ? void 0 : e3.extra) && (0, r.iterateExtraOptions)(e3.extra, "", /* @__PURE__ */ new WeakSet(), ((e4, r2) => {
                const i3 = (0, o.allocWasmString)(e4, s), a2 = (0, o.allocWasmString)(r2, s);
                if (0 !== t2._OrtAddRunConfigEntry(n2, i3, a2)) throw new Error(`Can't set a run config entry: ${e4} - ${r2}`);
              })), [n2, s];
            } catch (e4) {
              throw 0 !== n2 && t2._OrtReleaseRunOptions(n2), s.forEach(t2._free), e4;
            }
          };
        }, 2306: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.OnnxruntimeWebAssemblySessionHandler = void 0;
          const r = n(2806), o = n(1670), i = n(2850), s = n(2157);
          let a;
          t.OnnxruntimeWebAssemblySessionHandler = class {
            async createSessionAllocate(e3) {
              const t2 = await fetch(e3), n2 = await t2.arrayBuffer();
              return (0, s.createSessionAllocate)(new Uint8Array(n2));
            }
            async loadModel(e3, t2) {
              if (a || (await (0, s.initOrt)(o.env.wasm.numThreads, ((e4) => {
                switch (e4) {
                  case "verbose":
                    return 0;
                  case "info":
                    return 1;
                  case "warning":
                    return 2;
                  case "error":
                    return 3;
                  case "fatal":
                    return 4;
                  default:
                    throw new Error(`unsupported logging level: ${e4}`);
                }
              })(o.env.logLevel)), a = true), "string" == typeof e3) if ("undefined" == typeof fetch) {
                const n2 = await (0, i.promisify)(r.readFile)(e3);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, s.createSession)(n2, t2);
              } else {
                const n2 = await this.createSessionAllocate(e3);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, s.createSessionFinalize)(n2, t2);
              }
              else [this.sessionId, this.inputNames, this.outputNames] = await (0, s.createSession)(e3, t2);
            }
            async dispose() {
              return (0, s.releaseSession)(this.sessionId);
            }
            async run(e3, t2, n2) {
              const r2 = [], i2 = [];
              Object.entries(e3).forEach(((e4) => {
                const t3 = e4[0], n3 = e4[1], o2 = this.inputNames.indexOf(t3);
                if (-1 === o2) throw new Error(`invalid input '${t3}'`);
                r2.push(n3), i2.push(o2);
              }));
              const a2 = [];
              Object.entries(t2).forEach(((e4) => {
                const t3 = e4[0], n3 = this.outputNames.indexOf(t3);
                if (-1 === n3) throw new Error(`invalid output '${t3}'`);
                a2.push(n3);
              }));
              const l = await (0, s.run)(this.sessionId, i2, r2.map(((e4) => [e4.type, e4.dims, e4.data])), a2, n2), c = {};
              for (let e4 = 0; e4 < l.length; e4++) c[this.outputNames[a2[e4]]] = new o.Tensor(l[e4][0], l[e4][2], l[e4][1]);
              return c;
            }
            startProfiling() {
            }
            endProfiling() {
              (0, s.endProfiling)(this.sessionId);
            }
          };
        }, 4919: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.setSessionOptions = void 0;
          const r = n(7967), o = n(4983), i = n(6361);
          t.setSessionOptions = (e3) => {
            const t2 = (0, i.getInstance)();
            let n2 = 0;
            const s = [], a = e3 || {};
            ((e4) => {
              e4.extra || (e4.extra = {}), e4.extra.session || (e4.extra.session = {});
              const t3 = e4.extra.session;
              t3.use_ort_model_bytes_directly || (t3.use_ort_model_bytes_directly = "1");
            })(a);
            try {
              void 0 === (null == e3 ? void 0 : e3.graphOptimizationLevel) && (a.graphOptimizationLevel = "all");
              const l = ((e4) => {
                switch (e4) {
                  case "disabled":
                    return 0;
                  case "basic":
                    return 1;
                  case "extended":
                    return 2;
                  case "all":
                    return 99;
                  default:
                    throw new Error(`unsupported graph optimization level: ${e4}`);
                }
              })(a.graphOptimizationLevel);
              void 0 === (null == e3 ? void 0 : e3.enableCpuMemArena) && (a.enableCpuMemArena = true), void 0 === (null == e3 ? void 0 : e3.enableMemPattern) && (a.enableMemPattern = true), void 0 === (null == e3 ? void 0 : e3.executionMode) && (a.executionMode = "sequential");
              const c = ((e4) => {
                switch (e4) {
                  case "sequential":
                    return 0;
                  case "parallel":
                    return 1;
                  default:
                    throw new Error(`unsupported execution mode: ${e4}`);
                }
              })(a.executionMode);
              let u = 0;
              if (void 0 !== (null == e3 ? void 0 : e3.logId) && (u = (0, o.allocWasmString)(e3.logId, s)), void 0 === (null == e3 ? void 0 : e3.logSeverityLevel)) a.logSeverityLevel = 2;
              else if ("number" != typeof e3.logSeverityLevel || !Number.isInteger(e3.logSeverityLevel) || e3.logSeverityLevel < 0 || e3.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e3.logSeverityLevel}`);
              if (void 0 === (null == e3 ? void 0 : e3.logVerbosityLevel)) a.logVerbosityLevel = 0;
              else if ("number" != typeof e3.logVerbosityLevel || !Number.isInteger(e3.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e3.logVerbosityLevel}`);
              if (void 0 === (null == e3 ? void 0 : e3.enableProfiling) && (a.enableProfiling = false), n2 = t2._OrtCreateSessionOptions(l, !!a.enableCpuMemArena, !!a.enableMemPattern, c, !!a.enableProfiling, 0, u, a.logSeverityLevel, a.logVerbosityLevel), 0 === n2) throw new Error("Can't create session options");
              return (null == e3 ? void 0 : e3.executionProviders) && ((e4, t3, n3) => {
                for (const r2 of t3) {
                  let t4 = "string" == typeof r2 ? r2 : r2.name;
                  switch (t4) {
                    case "xnnpack":
                      t4 = "XNNPACK";
                      break;
                    case "wasm":
                    case "cpu":
                      continue;
                    default:
                      throw new Error(`not supported EP: ${t4}`);
                  }
                  const s2 = (0, o.allocWasmString)(t4, n3);
                  if (0 !== (0, i.getInstance)()._OrtAppendExecutionProvider(e4, s2)) throw new Error(`Can't append execution provider: ${t4}`);
                }
              })(n2, e3.executionProviders, s), void 0 !== (null == e3 ? void 0 : e3.extra) && (0, r.iterateExtraOptions)(e3.extra, "", /* @__PURE__ */ new WeakSet(), ((e4, r2) => {
                const i2 = (0, o.allocWasmString)(e4, s), a2 = (0, o.allocWasmString)(r2, s);
                if (0 !== t2._OrtAddSessionConfigEntry(n2, i2, a2)) throw new Error(`Can't set a session config entry: ${e4} - ${r2}`);
              })), [n2, s];
            } catch (e4) {
              throw 0 !== n2 && t2._OrtReleaseSessionOptions(n2), s.forEach(t2._free), e4;
            }
          };
        }, 4983: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.allocWasmString = void 0;
          const r = n(6361);
          t.allocWasmString = (e3, t2) => {
            const n2 = (0, r.getInstance)(), o = n2.lengthBytesUTF8(e3) + 1, i = n2._malloc(o);
            return n2.stringToUTF8(e3, i, o), t2.push(i), i;
          };
        }, 349: (e2, t, n) => {
          Object.defineProperty(t, "__esModule", { value: true }), t.extractTransferableBuffers = t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initOrt = void 0;
          const r = n(586), o = n(4919), i = n(4983), s = n(6361);
          t.initOrt = (e3, t2) => {
            const n2 = (0, s.getInstance)()._OrtInit(e3, t2);
            if (0 !== n2) throw new Error(`Can't initialize onnxruntime. error code = ${n2}`);
          };
          const a = /* @__PURE__ */ new Map();
          t.createSessionAllocate = (e3) => {
            const t2 = (0, s.getInstance)(), n2 = t2._malloc(e3.byteLength);
            return t2.HEAPU8.set(e3, n2), [n2, e3.byteLength];
          }, t.createSessionFinalize = (e3, t2) => {
            const n2 = (0, s.getInstance)();
            let r2 = 0, i2 = 0, l2 = [];
            try {
              if ([i2, l2] = (0, o.setSessionOptions)(t2), r2 = n2._OrtCreateSession(e3[0], e3[1], i2), 0 === r2) throw new Error("Can't create a session");
            } finally {
              n2._free(e3[0]), n2._OrtReleaseSessionOptions(i2), l2.forEach(n2._free);
            }
            const c2 = n2._OrtGetInputCount(r2), u2 = n2._OrtGetOutputCount(r2), p = [], d = [], _ = [], h = [];
            for (let e4 = 0; e4 < c2; e4++) {
              const t3 = n2._OrtGetInputName(r2, e4);
              if (0 === t3) throw new Error("Can't get an input name");
              d.push(t3), p.push(n2.UTF8ToString(t3));
            }
            for (let e4 = 0; e4 < u2; e4++) {
              const t3 = n2._OrtGetOutputName(r2, e4);
              if (0 === t3) throw new Error("Can't get an output name");
              h.push(t3), _.push(n2.UTF8ToString(t3));
            }
            return a.set(r2, [r2, d, h]), [r2, p, _];
          }, t.createSession = (e3, n2) => {
            const r2 = (0, t.createSessionAllocate)(e3);
            return (0, t.createSessionFinalize)(r2, n2);
          }, t.releaseSession = (e3) => {
            const t2 = (0, s.getInstance)(), n2 = a.get(e3);
            if (!n2) throw new Error("invalid session id");
            const r2 = n2[0], o2 = n2[1], i2 = n2[2];
            o2.forEach(t2._OrtFree), i2.forEach(t2._OrtFree), t2._OrtReleaseSession(r2), a.delete(e3);
          };
          const l = (e3) => {
            switch (e3) {
              case "int8":
                return 3;
              case "uint8":
                return 2;
              case "bool":
                return 9;
              case "int16":
                return 5;
              case "uint16":
                return 4;
              case "int32":
                return 6;
              case "uint32":
                return 12;
              case "float32":
                return 1;
              case "float64":
                return 11;
              case "string":
                return 8;
              case "int64":
                return 7;
              case "uint64":
                return 13;
              default:
                throw new Error(`unsupported data type: ${e3}`);
            }
          }, c = (e3) => {
            switch (e3) {
              case 3:
                return "int8";
              case 2:
                return "uint8";
              case 9:
                return "bool";
              case 5:
                return "int16";
              case 4:
                return "uint16";
              case 6:
                return "int32";
              case 12:
                return "uint32";
              case 1:
                return "float32";
              case 11:
                return "float64";
              case 8:
                return "string";
              case 7:
                return "int64";
              case 13:
                return "uint64";
              default:
                throw new Error(`unsupported data type: ${e3}`);
            }
          }, u = (e3) => {
            switch (e3) {
              case "float32":
                return Float32Array;
              case "uint8":
              case "bool":
                return Uint8Array;
              case "int8":
                return Int8Array;
              case "uint16":
                return Uint16Array;
              case "int16":
                return Int16Array;
              case "int32":
                return Int32Array;
              case "float64":
                return Float64Array;
              case "uint32":
                return Uint32Array;
              case "int64":
                return BigInt64Array;
              case "uint64":
                return BigUint64Array;
              default:
                throw new Error(`unsupported type: ${e3}`);
            }
          };
          t.run = (e3, t2, n2, o2, p) => {
            const d = (0, s.getInstance)(), _ = a.get(e3);
            if (!_) throw new Error("invalid session id");
            const h = _[0], f = _[1], m = _[2], g = t2.length, b = o2.length;
            let w = 0, x = [];
            const y = [], T = [];
            try {
              [w, x] = (0, r.setRunOptions)(p);
              for (let e5 = 0; e5 < g; e5++) {
                const t3 = n2[e5][0], r2 = n2[e5][1], o3 = n2[e5][2];
                let s3, a3;
                if (Array.isArray(o3)) {
                  a3 = 4 * o3.length, s3 = d._malloc(a3), T.push(s3);
                  let e6 = s3 / 4;
                  for (let t4 = 0; t4 < o3.length; t4++) {
                    if ("string" != typeof o3[t4]) throw new TypeError(`tensor data at index ${t4} is not a string`);
                    d.HEAPU32[e6++] = (0, i.allocWasmString)(o3[t4], T);
                  }
                } else a3 = o3.byteLength, s3 = d._malloc(a3), T.push(s3), d.HEAPU8.set(new Uint8Array(o3.buffer, o3.byteOffset, a3), s3);
                const c2 = d.stackSave(), u2 = d.stackAlloc(4 * r2.length);
                try {
                  let e6 = u2 / 4;
                  r2.forEach(((t4) => d.HEAP32[e6++] = t4));
                  const n3 = d._OrtCreateTensor(l(t3), s3, a3, u2, r2.length);
                  if (0 === n3) throw new Error("Can't create a tensor");
                  y.push(n3);
                } finally {
                  d.stackRestore(c2);
                }
              }
              const e4 = d.stackSave(), s2 = d.stackAlloc(4 * g), a2 = d.stackAlloc(4 * g), _2 = d.stackAlloc(4 * b), v = d.stackAlloc(4 * b);
              try {
                let e5 = s2 / 4, n3 = a2 / 4, r2 = _2 / 4, i2 = v / 4;
                for (let r3 = 0; r3 < g; r3++) d.HEAPU32[e5++] = y[r3], d.HEAPU32[n3++] = f[t2[r3]];
                for (let e6 = 0; e6 < b; e6++) d.HEAPU32[r2++] = 0, d.HEAPU32[i2++] = m[o2[e6]];
                let l2 = d._OrtRun(h, a2, s2, g, v, b, _2, w);
                const p2 = [];
                if (0 === l2) for (let e6 = 0; e6 < b; e6++) {
                  const t3 = d.HEAPU32[_2 / 4 + e6], n4 = d.stackSave(), r3 = d.stackAlloc(16);
                  let o3, i3 = 0;
                  try {
                    if (l2 = d._OrtGetTensorData(t3, r3, r3 + 4, r3 + 8, r3 + 12), 0 !== l2) throw new Error(`Can't access output tensor data. error code = ${l2}`);
                    let e7 = r3 / 4;
                    const n5 = d.HEAPU32[e7++];
                    i3 = d.HEAPU32[e7++];
                    const s3 = d.HEAPU32[e7++], a3 = d.HEAPU32[e7++], _3 = [];
                    for (let e8 = 0; e8 < a3; e8++) _3.push(d.HEAPU32[s3 / 4 + e8]);
                    d._OrtFree(s3);
                    const h2 = 0 === _3.length ? 1 : _3.reduce(((e8, t4) => e8 * t4));
                    if (o3 = c(n5), "string" === o3) {
                      const e8 = [];
                      let t4 = i3 / 4;
                      for (let n6 = 0; n6 < h2; n6++) {
                        const r4 = d.HEAPU32[t4++], o4 = n6 === h2 - 1 ? void 0 : d.HEAPU32[t4] - r4;
                        e8.push(d.UTF8ToString(r4, o4));
                      }
                      p2.push([o3, _3, e8]);
                    } else {
                      const e8 = new (u(o3))(h2);
                      new Uint8Array(e8.buffer, e8.byteOffset, e8.byteLength).set(d.HEAPU8.subarray(i3, i3 + e8.byteLength)), p2.push([o3, _3, e8]);
                    }
                  } finally {
                    d.stackRestore(n4), "string" === o3 && i3 && d._free(i3), d._OrtReleaseTensor(t3);
                  }
                }
                if (0 === l2) return p2;
                throw new Error(`failed to call OrtRun(). error code = ${l2}.`);
              } finally {
                d.stackRestore(e4);
              }
            } finally {
              y.forEach(d._OrtReleaseTensor), T.forEach(d._free), d._OrtReleaseRunOptions(w), x.forEach(d._free);
            }
          }, t.endProfiling = (e3) => {
            const t2 = (0, s.getInstance)(), n2 = a.get(e3);
            if (!n2) throw new Error("invalid session id");
            const r2 = n2[0], o2 = t2._OrtEndProfiling(r2);
            if (0 === o2) throw new Error("Can't get an profile file name");
            t2._OrtFree(o2);
          }, t.extractTransferableBuffers = (e3) => {
            const t2 = [];
            for (const n2 of e3) {
              const e4 = n2[2];
              !Array.isArray(e4) && e4.buffer && t2.push(e4.buffer);
            }
            return t2;
          };
        }, 6361: function(e2, t, n) {
          var r = this && this.__createBinding || (Object.create ? function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var o2 = Object.getOwnPropertyDescriptor(t2, n2);
            o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
              return t2[n2];
            } }), Object.defineProperty(e3, r2, o2);
          } : function(e3, t2, n2, r2) {
            void 0 === r2 && (r2 = n2), e3[r2] = t2[n2];
          }), o = this && this.__setModuleDefault || (Object.create ? function(e3, t2) {
            Object.defineProperty(e3, "default", { enumerable: true, value: t2 });
          } : function(e3, t2) {
            e3.default = t2;
          }), i = this && this.__importStar || function(e3) {
            if (e3 && e3.__esModule) return e3;
            var t2 = {};
            if (null != e3) for (var n2 in e3) "default" !== n2 && Object.prototype.hasOwnProperty.call(e3, n2) && r(t2, e3, n2);
            return o(t2, e3), t2;
          }, s = this && this.__importDefault || function(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          };
          Object.defineProperty(t, "__esModule", { value: true }), t.dispose = t.getInstance = t.initializeWebAssembly = void 0;
          const a = i(n(6449)), l = s(n(932)), c = n(3474);
          let u, p = false, d = false, _ = false;
          const h = (e3, t2) => t2 ? e3 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : e3 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm";
          t.initializeWebAssembly = async (e3) => {
            if (p) return Promise.resolve();
            if (d) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
            if (_) throw new Error("previous call to 'initializeWebAssembly()' failed.");
            d = true;
            const t2 = e3.initTimeout, r2 = e3.numThreads, o2 = e3.simd, i2 = r2 > 1 && (() => {
              try {
                return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
              } catch (e4) {
                return false;
              }
            })(), s2 = o2 && (() => {
              try {
                return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
              } catch (e4) {
                return false;
              }
            })(), f = "string" == typeof e3.wasmPaths ? e3.wasmPaths : void 0, m = h(false, i2), g = h(s2, i2), b = "object" == typeof e3.wasmPaths ? e3.wasmPaths[g] : void 0;
            let w = false;
            const x = [];
            if (t2 > 0 && x.push(new Promise(((e4) => {
              setTimeout((() => {
                w = true, e4();
              }), t2);
            }))), x.push(new Promise(((e4, t3) => {
              const r3 = i2 ? c : l.default, o3 = { locateFile: (e5, t4) => i2 && e5.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], { type: "text/javascript" })) : e5 === m ? null != b ? b : (null != f ? f : t4) + g : t4 + e5 };
              if (i2) if ("undefined" == typeof Blob) o3.mainScriptUrlOrBlob = a.join("/", "ort-wasm-threaded.js");
              else {
                const e5 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r3.toString()}})();`;
                o3.mainScriptUrlOrBlob = new Blob([e5], { type: "text/javascript" });
              }
              r3(o3).then(((t4) => {
                d = false, p = true, u = t4, e4();
              }), ((e5) => {
                d = false, _ = true, t3(e5);
              }));
            }))), await Promise.race(x), w) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t2}ms`);
          }, t.getInstance = () => {
            if (p && u) return u;
            throw new Error("WebAssembly is not initialized yet.");
          }, t.dispose = () => {
            var e3;
            !p || d || _ || (d = true, null === (e3 = u.PThread) || void 0 === e3 || e3.terminateAllThreads(), u = void 0, d = false, p = false, _ = true);
          };
        }, 9710: (e2, t, n) => {
          n.d(t, { Z: () => i });
          var r = n(477), o = n.n(r);
          function i() {
            return o()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n', "Worker", void 0, void 0);
          }
        }, 477: (e2) => {
          e2.exports = function(e3, t, n, r) {
            var o = self || window;
            try {
              try {
                var i;
                try {
                  i = new o.Blob([e3]);
                } catch (t2) {
                  (i = new (o.BlobBuilder || o.WebKitBlobBuilder || o.MozBlobBuilder || o.MSBlobBuilder)()).append(e3), i = i.getBlob();
                }
                var s = o.URL || o.webkitURL, a = s.createObjectURL(i), l = new o[t](a, n);
                return s.revokeObjectURL(a), l;
              } catch (r2) {
                return new o[t]("data:application/javascript,".concat(encodeURIComponent(e3)), n);
              }
            } catch (e4) {
              if (!r) throw Error("Inline worker is not supported");
              return new o[t](r, n);
            }
          };
        }, 4154: (e2) => {
          e2.exports = '"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n';
        }, 1670: (e2) => {
          e2.exports = __WEBPACK_EXTERNAL_MODULE__1670__;
        }, 7067: () => {
        }, 1296: () => {
        }, 1384: () => {
        }, 3993: () => {
        }, 908: () => {
        }, 6953: () => {
        }, 9925: () => {
        }, 2806: () => {
        }, 6449: () => {
        }, 2850: () => {
        }, 5381: () => {
        }, 5686: (e2, t, n) => {
          n.r(t), n.d(t, { flatbuffers: () => r });
          var r = {};
          r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function(e3, t2) {
            this.low = 0 | e3, this.high = 0 | t2;
          }, r.Long.create = function(e3, t2) {
            return 0 == e3 && 0 == t2 ? r.Long.ZERO : new r.Long(e3, t2);
          }, r.Long.prototype.toFloat64 = function() {
            return (this.low >>> 0) + 4294967296 * this.high;
          }, r.Long.prototype.equals = function(e3) {
            return this.low == e3.low && this.high == e3.high;
          }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(e3) {
            if (e3) t2 = e3;
            else var t2 = 1024;
            this.bb = r.ByteBuffer.allocate(t2), this.space = t2, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
          }, r.Builder.prototype.clear = function() {
            this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
          }, r.Builder.prototype.forceDefaults = function(e3) {
            this.force_defaults = e3;
          }, r.Builder.prototype.dataBuffer = function() {
            return this.bb;
          }, r.Builder.prototype.asUint8Array = function() {
            return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
          }, r.Builder.prototype.prep = function(e3, t2) {
            e3 > this.minalign && (this.minalign = e3);
            for (var n2 = 1 + ~(this.bb.capacity() - this.space + t2) & e3 - 1; this.space < n2 + e3 + t2; ) {
              var o = this.bb.capacity();
              this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - o;
            }
            this.pad(n2);
          }, r.Builder.prototype.pad = function(e3) {
            for (var t2 = 0; t2 < e3; t2++) this.bb.writeInt8(--this.space, 0);
          }, r.Builder.prototype.writeInt8 = function(e3) {
            this.bb.writeInt8(this.space -= 1, e3);
          }, r.Builder.prototype.writeInt16 = function(e3) {
            this.bb.writeInt16(this.space -= 2, e3);
          }, r.Builder.prototype.writeInt32 = function(e3) {
            this.bb.writeInt32(this.space -= 4, e3);
          }, r.Builder.prototype.writeInt64 = function(e3) {
            this.bb.writeInt64(this.space -= 8, e3);
          }, r.Builder.prototype.writeFloat32 = function(e3) {
            this.bb.writeFloat32(this.space -= 4, e3);
          }, r.Builder.prototype.writeFloat64 = function(e3) {
            this.bb.writeFloat64(this.space -= 8, e3);
          }, r.Builder.prototype.addInt8 = function(e3) {
            this.prep(1, 0), this.writeInt8(e3);
          }, r.Builder.prototype.addInt16 = function(e3) {
            this.prep(2, 0), this.writeInt16(e3);
          }, r.Builder.prototype.addInt32 = function(e3) {
            this.prep(4, 0), this.writeInt32(e3);
          }, r.Builder.prototype.addInt64 = function(e3) {
            this.prep(8, 0), this.writeInt64(e3);
          }, r.Builder.prototype.addFloat32 = function(e3) {
            this.prep(4, 0), this.writeFloat32(e3);
          }, r.Builder.prototype.addFloat64 = function(e3) {
            this.prep(8, 0), this.writeFloat64(e3);
          }, r.Builder.prototype.addFieldInt8 = function(e3, t2, n2) {
            (this.force_defaults || t2 != n2) && (this.addInt8(t2), this.slot(e3));
          }, r.Builder.prototype.addFieldInt16 = function(e3, t2, n2) {
            (this.force_defaults || t2 != n2) && (this.addInt16(t2), this.slot(e3));
          }, r.Builder.prototype.addFieldInt32 = function(e3, t2, n2) {
            (this.force_defaults || t2 != n2) && (this.addInt32(t2), this.slot(e3));
          }, r.Builder.prototype.addFieldInt64 = function(e3, t2, n2) {
            !this.force_defaults && t2.equals(n2) || (this.addInt64(t2), this.slot(e3));
          }, r.Builder.prototype.addFieldFloat32 = function(e3, t2, n2) {
            (this.force_defaults || t2 != n2) && (this.addFloat32(t2), this.slot(e3));
          }, r.Builder.prototype.addFieldFloat64 = function(e3, t2, n2) {
            (this.force_defaults || t2 != n2) && (this.addFloat64(t2), this.slot(e3));
          }, r.Builder.prototype.addFieldOffset = function(e3, t2, n2) {
            (this.force_defaults || t2 != n2) && (this.addOffset(t2), this.slot(e3));
          }, r.Builder.prototype.addFieldStruct = function(e3, t2, n2) {
            t2 != n2 && (this.nested(t2), this.slot(e3));
          }, r.Builder.prototype.nested = function(e3) {
            if (e3 != this.offset()) throw new Error("FlatBuffers: struct must be serialized inline.");
          }, r.Builder.prototype.notNested = function() {
            if (this.isNested) throw new Error("FlatBuffers: object serialization must not be nested.");
          }, r.Builder.prototype.slot = function(e3) {
            this.vtable[e3] = this.offset();
          }, r.Builder.prototype.offset = function() {
            return this.bb.capacity() - this.space;
          }, r.Builder.growByteBuffer = function(e3) {
            var t2 = e3.capacity();
            if (3221225472 & t2) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
            var n2 = t2 << 1, o = r.ByteBuffer.allocate(n2);
            return o.setPosition(n2 - t2), o.bytes().set(e3.bytes(), n2 - t2), o;
          }, r.Builder.prototype.addOffset = function(e3) {
            this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - e3 + r.SIZEOF_INT);
          }, r.Builder.prototype.startObject = function(e3) {
            this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = e3;
            for (var t2 = 0; t2 < e3; t2++) this.vtable[t2] = 0;
            this.isNested = true, this.object_start = this.offset();
          }, r.Builder.prototype.endObject = function() {
            if (null == this.vtable || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
            this.addInt32(0);
            for (var e3 = this.offset(), t2 = this.vtable_in_use - 1; t2 >= 0 && 0 == this.vtable[t2]; t2--) ;
            for (var n2 = t2 + 1; t2 >= 0; t2--) this.addInt16(0 != this.vtable[t2] ? e3 - this.vtable[t2] : 0);
            this.addInt16(e3 - this.object_start);
            var o = (n2 + 2) * r.SIZEOF_SHORT;
            this.addInt16(o);
            var i = 0, s = this.space;
            e: for (t2 = 0; t2 < this.vtables.length; t2++) {
              var a = this.bb.capacity() - this.vtables[t2];
              if (o == this.bb.readInt16(a)) {
                for (var l = r.SIZEOF_SHORT; l < o; l += r.SIZEOF_SHORT) if (this.bb.readInt16(s + l) != this.bb.readInt16(a + l)) continue e;
                i = this.vtables[t2];
                break;
              }
            }
            return i ? (this.space = this.bb.capacity() - e3, this.bb.writeInt32(this.space, i - e3)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e3, this.offset() - e3)), this.isNested = false, e3;
          }, r.Builder.prototype.finish = function(e3, t2, n2) {
            var o = n2 ? r.SIZE_PREFIX_LENGTH : 0;
            if (t2) {
              var i = t2;
              if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + o), i.length != r.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
              for (var s = r.FILE_IDENTIFIER_LENGTH - 1; s >= 0; s--) this.writeInt8(i.charCodeAt(s));
            }
            this.prep(this.minalign, r.SIZEOF_INT + o), this.addOffset(e3), o && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
          }, r.Builder.prototype.finishSizePrefixed = function(e3, t2) {
            this.finish(e3, t2, true);
          }, r.Builder.prototype.requiredField = function(e3, t2) {
            var n2 = this.bb.capacity() - e3, r2 = n2 - this.bb.readInt32(n2);
            if (0 == this.bb.readInt16(r2 + t2)) throw new Error("FlatBuffers: field " + t2 + " must be set");
          }, r.Builder.prototype.startVector = function(e3, t2, n2) {
            this.notNested(), this.vector_num_elems = t2, this.prep(r.SIZEOF_INT, e3 * t2), this.prep(n2, e3 * t2);
          }, r.Builder.prototype.endVector = function() {
            return this.writeInt32(this.vector_num_elems), this.offset();
          }, r.Builder.prototype.createString = function(e3) {
            if (e3 instanceof Uint8Array) var t2 = e3;
            else {
              t2 = [];
              for (var n2 = 0; n2 < e3.length; ) {
                var r2, o = e3.charCodeAt(n2++);
                (r2 = o < 55296 || o >= 56320 ? o : (o << 10) + e3.charCodeAt(n2++) + -56613888) < 128 ? t2.push(r2) : (r2 < 2048 ? t2.push(r2 >> 6 & 31 | 192) : (r2 < 65536 ? t2.push(r2 >> 12 & 15 | 224) : t2.push(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128), t2.push(r2 >> 6 & 63 | 128)), t2.push(63 & r2 | 128));
              }
            }
            this.addInt8(0), this.startVector(1, t2.length, 1), this.bb.setPosition(this.space -= t2.length), n2 = 0;
            for (var i = this.space, s = this.bb.bytes(); n2 < t2.length; n2++) s[i++] = t2[n2];
            return this.endVector();
          }, r.Builder.prototype.createLong = function(e3, t2) {
            return r.Long.create(e3, t2);
          }, r.ByteBuffer = function(e3) {
            this.bytes_ = e3, this.position_ = 0;
          }, r.ByteBuffer.allocate = function(e3) {
            return new r.ByteBuffer(new Uint8Array(e3));
          }, r.ByteBuffer.prototype.clear = function() {
            this.position_ = 0;
          }, r.ByteBuffer.prototype.bytes = function() {
            return this.bytes_;
          }, r.ByteBuffer.prototype.position = function() {
            return this.position_;
          }, r.ByteBuffer.prototype.setPosition = function(e3) {
            this.position_ = e3;
          }, r.ByteBuffer.prototype.capacity = function() {
            return this.bytes_.length;
          }, r.ByteBuffer.prototype.readInt8 = function(e3) {
            return this.readUint8(e3) << 24 >> 24;
          }, r.ByteBuffer.prototype.readUint8 = function(e3) {
            return this.bytes_[e3];
          }, r.ByteBuffer.prototype.readInt16 = function(e3) {
            return this.readUint16(e3) << 16 >> 16;
          }, r.ByteBuffer.prototype.readUint16 = function(e3) {
            return this.bytes_[e3] | this.bytes_[e3 + 1] << 8;
          }, r.ByteBuffer.prototype.readInt32 = function(e3) {
            return this.bytes_[e3] | this.bytes_[e3 + 1] << 8 | this.bytes_[e3 + 2] << 16 | this.bytes_[e3 + 3] << 24;
          }, r.ByteBuffer.prototype.readUint32 = function(e3) {
            return this.readInt32(e3) >>> 0;
          }, r.ByteBuffer.prototype.readInt64 = function(e3) {
            return new r.Long(this.readInt32(e3), this.readInt32(e3 + 4));
          }, r.ByteBuffer.prototype.readUint64 = function(e3) {
            return new r.Long(this.readUint32(e3), this.readUint32(e3 + 4));
          }, r.ByteBuffer.prototype.readFloat32 = function(e3) {
            return r.int32[0] = this.readInt32(e3), r.float32[0];
          }, r.ByteBuffer.prototype.readFloat64 = function(e3) {
            return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(e3), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(e3 + 4), r.float64[0];
          }, r.ByteBuffer.prototype.writeInt8 = function(e3, t2) {
            this.bytes_[e3] = t2;
          }, r.ByteBuffer.prototype.writeUint8 = function(e3, t2) {
            this.bytes_[e3] = t2;
          }, r.ByteBuffer.prototype.writeInt16 = function(e3, t2) {
            this.bytes_[e3] = t2, this.bytes_[e3 + 1] = t2 >> 8;
          }, r.ByteBuffer.prototype.writeUint16 = function(e3, t2) {
            this.bytes_[e3] = t2, this.bytes_[e3 + 1] = t2 >> 8;
          }, r.ByteBuffer.prototype.writeInt32 = function(e3, t2) {
            this.bytes_[e3] = t2, this.bytes_[e3 + 1] = t2 >> 8, this.bytes_[e3 + 2] = t2 >> 16, this.bytes_[e3 + 3] = t2 >> 24;
          }, r.ByteBuffer.prototype.writeUint32 = function(e3, t2) {
            this.bytes_[e3] = t2, this.bytes_[e3 + 1] = t2 >> 8, this.bytes_[e3 + 2] = t2 >> 16, this.bytes_[e3 + 3] = t2 >> 24;
          }, r.ByteBuffer.prototype.writeInt64 = function(e3, t2) {
            this.writeInt32(e3, t2.low), this.writeInt32(e3 + 4, t2.high);
          }, r.ByteBuffer.prototype.writeUint64 = function(e3, t2) {
            this.writeUint32(e3, t2.low), this.writeUint32(e3 + 4, t2.high);
          }, r.ByteBuffer.prototype.writeFloat32 = function(e3, t2) {
            r.float32[0] = t2, this.writeInt32(e3, r.int32[0]);
          }, r.ByteBuffer.prototype.writeFloat64 = function(e3, t2) {
            r.float64[0] = t2, this.writeInt32(e3, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(e3 + 4, r.int32[r.isLittleEndian ? 1 : 0]);
          }, r.ByteBuffer.prototype.getBufferIdentifier = function() {
            if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
            for (var e3 = "", t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++) e3 += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + t2));
            return e3;
          }, r.ByteBuffer.prototype.__offset = function(e3, t2) {
            var n2 = e3 - this.readInt32(e3);
            return t2 < this.readInt16(n2) ? this.readInt16(n2 + t2) : 0;
          }, r.ByteBuffer.prototype.__union = function(e3, t2) {
            return e3.bb_pos = t2 + this.readInt32(t2), e3.bb = this, e3;
          }, r.ByteBuffer.prototype.__string = function(e3, t2) {
            e3 += this.readInt32(e3);
            var n2 = this.readInt32(e3), o = "", i = 0;
            if (e3 += r.SIZEOF_INT, t2 === r.Encoding.UTF8_BYTES) return this.bytes_.subarray(e3, e3 + n2);
            for (; i < n2; ) {
              var s, a = this.readUint8(e3 + i++);
              if (a < 192) s = a;
              else {
                var l = this.readUint8(e3 + i++);
                if (a < 224) s = (31 & a) << 6 | 63 & l;
                else {
                  var c = this.readUint8(e3 + i++);
                  s = a < 240 ? (15 & a) << 12 | (63 & l) << 6 | 63 & c : (7 & a) << 18 | (63 & l) << 12 | (63 & c) << 6 | 63 & this.readUint8(e3 + i++);
                }
              }
              s < 65536 ? o += String.fromCharCode(s) : (s -= 65536, o += String.fromCharCode(55296 + (s >> 10), 56320 + (1023 & s)));
            }
            return o;
          }, r.ByteBuffer.prototype.__indirect = function(e3) {
            return e3 + this.readInt32(e3);
          }, r.ByteBuffer.prototype.__vector = function(e3) {
            return e3 + this.readInt32(e3) + r.SIZEOF_INT;
          }, r.ByteBuffer.prototype.__vector_len = function(e3) {
            return this.readInt32(e3 + this.readInt32(e3));
          }, r.ByteBuffer.prototype.__has_identifier = function(e3) {
            if (e3.length != r.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
            for (var t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++) if (e3.charCodeAt(t2) != this.readInt8(this.position_ + r.SIZEOF_INT + t2)) return false;
            return true;
          }, r.ByteBuffer.prototype.createLong = function(e3, t2) {
            return r.Long.create(e3, t2);
          };
        } }, __webpack_module_cache__ = {};
        function __nested_webpack_require_546802__(e2) {
          var t = __webpack_module_cache__[e2];
          if (void 0 !== t) return t.exports;
          var n = __webpack_module_cache__[e2] = { exports: {} };
          return __webpack_modules__[e2].call(n.exports, n, n.exports, __nested_webpack_require_546802__), n.exports;
        }
        __nested_webpack_require_546802__.n = (e2) => {
          var t = e2 && e2.__esModule ? () => e2.default : () => e2;
          return __nested_webpack_require_546802__.d(t, { a: t }), t;
        }, __nested_webpack_require_546802__.d = (e2, t) => {
          for (var n in t) __nested_webpack_require_546802__.o(t, n) && !__nested_webpack_require_546802__.o(e2, n) && Object.defineProperty(e2, n, { enumerable: true, get: t[n] });
        }, __nested_webpack_require_546802__.g = (function() {
          if ("object" == typeof globalThis) return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e2) {
            if ("object" == typeof window) return window;
          }
        })(), __nested_webpack_require_546802__.o = (e2, t) => Object.prototype.hasOwnProperty.call(e2, t), __nested_webpack_require_546802__.r = (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        };
        var __nested_webpack_exports__ = __nested_webpack_require_546802__(6018);
        return __nested_webpack_exports__;
      })(), module.exports = e(__webpack_require__(
        /*! onnxruntime-common */
        "./node_modules/onnxruntime-common/dist/lib/index.js"
      ));
    }
  ), "?2ce3": (
    /*!**********************************!*\
      !*** onnxruntime-node (ignored) ***!
      \**********************************/
    () => {
    }
  ), "?7a2c": (
    /*!********************!*\
      !*** fs (ignored) ***!
      \********************/
    () => {
    }
  ), "?a42a": (
    /*!**********************!*\
      !*** path (ignored) ***!
      \**********************/
    () => {
    }
  ), "?2b25": (
    /*!***********************!*\
      !*** sharp (ignored) ***!
      \***********************/
    () => {
    }
  ), "?e65c": (
    /*!****************************!*\
      !*** stream/web (ignored) ***!
      \****************************/
    () => {
    }
  ), "?569f": (
    /*!********************!*\
      !*** fs (ignored) ***!
      \********************/
    () => {
    }
  ), "?3f59": (
    /*!**********************!*\
      !*** path (ignored) ***!
      \**********************/
    () => {
    }
  ), "?154a": (
    /*!*********************!*\
      !*** url (ignored) ***!
      \*********************/
    () => {
    }
  ), "./node_modules/@huggingface/jinja/dist/index.js": (
    /*!*******************************************************!*\
      !*** ./node_modules/@huggingface/jinja/dist/index.js ***!
      \*******************************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { Environment: () => H, Interpreter: () => X, Template: () => Y, parse: () => I, tokenize: () => u });
      var r = Object.freeze({ Text: "Text", NumericLiteral: "NumericLiteral", BooleanLiteral: "BooleanLiteral", StringLiteral: "StringLiteral", Identifier: "Identifier", Equals: "Equals", OpenParen: "OpenParen", CloseParen: "CloseParen", OpenStatement: "OpenStatement", CloseStatement: "CloseStatement", OpenExpression: "OpenExpression", CloseExpression: "CloseExpression", OpenSquareBracket: "OpenSquareBracket", CloseSquareBracket: "CloseSquareBracket", OpenCurlyBracket: "OpenCurlyBracket", CloseCurlyBracket: "CloseCurlyBracket", Comma: "Comma", Dot: "Dot", Colon: "Colon", Pipe: "Pipe", CallOperator: "CallOperator", AdditiveBinaryOperator: "AdditiveBinaryOperator", MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator", ComparisonBinaryOperator: "ComparisonBinaryOperator", UnaryOperator: "UnaryOperator", Set: "Set", If: "If", For: "For", In: "In", Is: "Is", NotIn: "NotIn", Else: "Else", EndIf: "EndIf", ElseIf: "ElseIf", EndFor: "EndFor", And: "And", Or: "Or", Not: "UnaryOperator" }), o = Object.freeze({ set: r.Set, for: r.For, in: r.In, is: r.Is, if: r.If, else: r.Else, endif: r.EndIf, elif: r.ElseIf, endfor: r.EndFor, and: r.And, or: r.Or, not: r.Not, "not in": r.NotIn, true: r.BooleanLiteral, false: r.BooleanLiteral }), i = class {
        constructor(e3, t2) {
          this.value = e3, this.type = t2;
        }
      };
      function s(e3) {
        return /\w/.test(e3);
      }
      function a(e3) {
        return /[0-9]/.test(e3);
      }
      var l = [["{%", r.OpenStatement], ["%}", r.CloseStatement], ["{{", r.OpenExpression], ["}}", r.CloseExpression], ["(", r.OpenParen], [")", r.CloseParen], ["{", r.OpenCurlyBracket], ["}", r.CloseCurlyBracket], ["[", r.OpenSquareBracket], ["]", r.CloseSquareBracket], [",", r.Comma], [".", r.Dot], [":", r.Colon], ["|", r.Pipe], ["<=", r.ComparisonBinaryOperator], [">=", r.ComparisonBinaryOperator], ["==", r.ComparisonBinaryOperator], ["!=", r.ComparisonBinaryOperator], ["<", r.ComparisonBinaryOperator], [">", r.ComparisonBinaryOperator], ["+", r.AdditiveBinaryOperator], ["-", r.AdditiveBinaryOperator], ["*", r.MultiplicativeBinaryOperator], ["/", r.MultiplicativeBinaryOperator], ["%", r.MultiplicativeBinaryOperator], ["=", r.Equals]], c = /* @__PURE__ */ new Map([["n", "\n"], ["t", "	"], ["r", "\r"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["'", "'"], ['"', '"'], ["\\", "\\"]]);
      function u(e3, t2 = {}) {
        const n2 = [], u2 = (function(e4, t3 = {}) {
          return e4.endsWith("\n") && (e4 = e4.slice(0, -1)), e4 = e4.replace(/{#.*?#}/gs, "{##}"), t3.lstrip_blocks && (e4 = e4.replace(/^[ \t]*({[#%])/gm, "$1")), t3.trim_blocks && (e4 = e4.replace(/([#%]})\n/g, "$1")), e4.replace(/{##}/g, "").replace(/-%}\s*/g, "%}").replace(/\s*{%-/g, "{%").replace(/-}}\s*/g, "}}").replace(/\s*{{-/g, "{{");
        })(e3, t2);
        let p2 = 0;
        const d2 = (e4) => {
          let t3 = "";
          for (; e4(u2[p2]); ) if ("\\" !== u2[p2]) {
            if (t3 += u2[p2++], p2 >= u2.length) throw new SyntaxError("Unexpected end of input");
          } else {
            if (++p2, p2 >= u2.length) throw new SyntaxError("Unexpected end of input");
            const e5 = u2[p2++], n3 = c.get(e5);
            if (void 0 === n3) throw new SyntaxError(`Unexpected escaped character: ${e5}`);
            t3 += n3;
          }
          return t3;
        };
        e: for (; p2 < u2.length; ) {
          const e4 = n2.at(-1)?.type;
          if (void 0 === e4 || e4 === r.CloseStatement || e4 === r.CloseExpression) {
            let e5 = "";
            for (; p2 < u2.length && ("{" !== u2[p2] || "%" !== u2[p2 + 1] && "{" !== u2[p2 + 1]); ) e5 += u2[p2++];
            if (e5.length > 0) {
              n2.push(new i(e5, r.Text));
              continue;
            }
          }
          d2(((e5) => /\s/.test(e5)));
          const t3 = u2[p2];
          if ("-" === t3 || "+" === t3) {
            const e5 = n2.at(-1)?.type;
            if (e5 === r.Text || void 0 === e5) throw new SyntaxError(`Unexpected character: ${t3}`);
            switch (e5) {
              case r.Identifier:
              case r.NumericLiteral:
              case r.BooleanLiteral:
              case r.StringLiteral:
              case r.CloseParen:
              case r.CloseSquareBracket:
                break;
              default: {
                ++p2;
                const e6 = d2(a);
                n2.push(new i(`${t3}${e6}`, e6.length > 0 ? r.NumericLiteral : r.UnaryOperator));
                continue;
              }
            }
          }
          for (const [e5, t4] of l) {
            if (u2.slice(p2, p2 + e5.length) === e5) {
              n2.push(new i(e5, t4)), p2 += e5.length;
              continue e;
            }
          }
          if ("'" !== t3 && '"' !== t3) if (a(t3)) {
            const e5 = d2(a);
            n2.push(new i(e5, r.NumericLiteral));
          } else {
            if (!s(t3)) throw new SyntaxError(`Unexpected character: ${t3}`);
            {
              const e5 = d2(s), t4 = Object.hasOwn(o, e5) ? o[e5] : r.Identifier;
              t4 === r.In && n2.at(-1)?.type === r.Not ? (n2.pop(), n2.push(new i("not in", r.NotIn))) : n2.push(new i(e5, t4));
            }
          }
          else {
            ++p2;
            const e5 = d2(((e6) => e6 !== t3));
            n2.push(new i(e5, r.StringLiteral)), ++p2;
          }
        }
        return n2;
      }
      var p = class {
        type = "Statement";
      }, d = class extends p {
        constructor(e3) {
          super(), this.body = e3;
        }
        type = "Program";
      }, _ = class extends p {
        constructor(e3, t2, n2) {
          super(), this.test = e3, this.body = t2, this.alternate = n2;
        }
        type = "If";
      }, h = class extends p {
        constructor(e3, t2, n2) {
          super(), this.loopvar = e3, this.iterable = t2, this.body = n2;
        }
        type = "For";
      }, f = class extends p {
        constructor(e3, t2) {
          super(), this.assignee = e3, this.value = t2;
        }
        type = "Set";
      }, m = class extends p {
        type = "Expression";
      }, g = class extends m {
        constructor(e3, t2, n2) {
          super(), this.object = e3, this.property = t2, this.computed = n2;
        }
        type = "MemberExpression";
      }, b = class extends m {
        constructor(e3, t2) {
          super(), this.callee = e3, this.args = t2;
        }
        type = "CallExpression";
      }, w = class extends m {
        constructor(e3) {
          super(), this.value = e3;
        }
        type = "Identifier";
      }, x = class extends m {
        constructor(e3) {
          super(), this.value = e3;
        }
        type = "Literal";
      }, y = class extends x {
        type = "NumericLiteral";
      }, T = class extends x {
        type = "StringLiteral";
      }, v = class extends x {
        type = "BooleanLiteral";
      }, k = class extends x {
        type = "ArrayLiteral";
      }, M = class extends x {
        type = "TupleLiteral";
      }, S = class extends x {
        type = "ObjectLiteral";
      }, P = class extends m {
        constructor(e3, t2, n2) {
          super(), this.operator = e3, this.left = t2, this.right = n2;
        }
        type = "BinaryExpression";
      }, A = class extends m {
        constructor(e3, t2) {
          super(), this.operand = e3, this.filter = t2;
        }
        type = "FilterExpression";
      }, F = class extends m {
        constructor(e3, t2, n2) {
          super(), this.operand = e3, this.negate = t2, this.test = n2;
        }
        type = "TestExpression";
      }, C = class extends m {
        constructor(e3, t2) {
          super(), this.operator = e3, this.argument = t2;
        }
        type = "UnaryExpression";
      }, E = class extends m {
        constructor(e3 = void 0, t2 = void 0, n2 = void 0) {
          super(), this.start = e3, this.stop = t2, this.step = n2;
        }
        type = "SliceExpression";
      }, O = class extends m {
        constructor(e3, t2) {
          super(), this.key = e3, this.value = t2;
        }
        type = "KeywordArgumentExpression";
      };
      function I(e3) {
        const t2 = new d([]);
        let n2 = 0;
        function o2(t3, r2) {
          const o3 = e3[n2++];
          if (!o3 || o3.type !== t3) throw new Error(`Parser Error: ${r2}. ${o3.type} !== ${t3}.`);
          return o3;
        }
        function i2() {
          switch (e3[n2].type) {
            case r.Text:
              return new T(o2(r.Text, "Expected text token").value);
            case r.OpenStatement:
              return (function() {
                let t3;
                switch (o2(r.OpenStatement, "Expected opening statement token"), e3[n2].type) {
                  case r.Set:
                    ++n2, t3 = l2(), o2(r.CloseStatement, "Expected closing statement token");
                    break;
                  case r.If:
                    ++n2, t3 = c2(), o2(r.OpenStatement, "Expected {% token"), o2(r.EndIf, "Expected endif token"), o2(r.CloseStatement, "Expected %} token");
                    break;
                  case r.For:
                    ++n2, t3 = (function() {
                      const e4 = u2(true);
                      if (!(e4 instanceof w || e4 instanceof M)) throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e4.type} instead`);
                      o2(r.In, "Expected `in` keyword following loop variable");
                      const t4 = p2();
                      o2(r.CloseStatement, "Expected closing statement token");
                      const n3 = [];
                      for (; s2(r.OpenStatement, r.EndFor); ) n3.push(i2());
                      return new h(e4, t4, n3);
                    })(), o2(r.OpenStatement, "Expected {% token"), o2(r.EndFor, "Expected endfor token"), o2(r.CloseStatement, "Expected %} token");
                    break;
                  default:
                    throw new SyntaxError(`Unknown statement type: ${e3[n2].type}`);
                }
                return t3;
              })();
            case r.OpenExpression:
              return (function() {
                o2(r.OpenExpression, "Expected opening expression token");
                const e4 = p2();
                return o2(r.CloseExpression, "Expected closing expression token"), e4;
              })();
            default:
              throw new SyntaxError(`Unexpected token type: ${e3[n2].type}`);
          }
        }
        function s2(...t3) {
          return n2 + t3.length <= e3.length && t3.some(((t4, r2) => t4 !== e3[n2 + r2].type));
        }
        function a2(...t3) {
          return n2 + t3.length <= e3.length && t3.every(((t4, r2) => t4 === e3[n2 + r2].type));
        }
        function l2() {
          const e4 = p2();
          if (a2(r.Equals)) {
            ++n2;
            const t3 = l2();
            return new f(e4, t3);
          }
          return e4;
        }
        function c2() {
          const t3 = p2();
          o2(r.CloseStatement, "Expected closing statement token");
          const s3 = [], l3 = [];
          for (; e3[n2]?.type !== r.OpenStatement || e3[n2 + 1]?.type !== r.ElseIf && e3[n2 + 1]?.type !== r.Else && e3[n2 + 1]?.type !== r.EndIf; ) s3.push(i2());
          if (e3[n2]?.type === r.OpenStatement && e3[n2 + 1]?.type !== r.EndIf) if (++n2, a2(r.ElseIf)) o2(r.ElseIf, "Expected elseif token"), l3.push(c2());
          else for (o2(r.Else, "Expected else token"), o2(r.CloseStatement, "Expected closing statement token"); e3[n2]?.type !== r.OpenStatement || e3[n2 + 1]?.type !== r.EndIf; ) l3.push(i2());
          return new _(t3, s3, l3);
        }
        function u2(e4 = false) {
          const t3 = e4 ? R2 : p2, o3 = [t3()], i3 = a2(r.Comma);
          for (; i3 && (++n2, o3.push(t3()), a2(r.Comma)); ) ;
          return i3 ? new M(o3) : o3[0];
        }
        function p2() {
          return (function() {
            const e4 = m2();
            if (a2(r.If)) {
              ++n2;
              const t3 = m2();
              o2(r.Else, "Expected else token");
              const i3 = m2();
              return new _(t3, [e4], [i3]);
            }
            return e4;
          })();
        }
        function m2() {
          let t3 = x2();
          for (; a2(r.Or); ) {
            const r2 = e3[n2];
            ++n2;
            const o3 = x2();
            t3 = new P(r2, t3, o3);
          }
          return t3;
        }
        function x2() {
          let t3 = I2();
          for (; a2(r.And); ) {
            const r2 = e3[n2];
            ++n2;
            const o3 = I2();
            t3 = new P(r2, t3, o3);
          }
          return t3;
        }
        function I2() {
          let t3;
          for (; a2(r.Not); ) {
            const r2 = e3[n2];
            ++n2;
            const o3 = I2();
            t3 = new C(r2, o3);
          }
          return t3 ?? (function() {
            let t4 = D2();
            for (; a2(r.ComparisonBinaryOperator) || a2(r.In) || a2(r.NotIn); ) {
              const r2 = e3[n2];
              ++n2;
              const o3 = D2();
              t4 = new P(r2, t4, o3);
            }
            return t4;
          })();
        }
        function D2() {
          let t3 = B2();
          for (; a2(r.AdditiveBinaryOperator); ) {
            const r2 = e3[n2];
            ++n2;
            const o3 = B2();
            t3 = new P(r2, t3, o3);
          }
          return t3;
        }
        function L2() {
          const t3 = (function() {
            let t4 = R2();
            for (; a2(r.Dot) || a2(r.OpenSquareBracket); ) {
              const i3 = e3[n2];
              let s3;
              ++n2;
              const a3 = i3.type !== r.Dot;
              if (a3) s3 = N2(), o2(r.CloseSquareBracket, "Expected closing square bracket");
              else if (s3 = R2(), "Identifier" !== s3.type) throw new SyntaxError("Expected identifier following dot operator");
              t4 = new g(t4, s3, a3);
            }
            return t4;
          })();
          return a2(r.OpenParen) ? $2(t3) : t3;
        }
        function $2(e4) {
          let t3 = new b(e4, (function() {
            o2(r.OpenParen, "Expected opening parenthesis for arguments list");
            const e5 = (function() {
              const e6 = [];
              for (; !a2(r.CloseParen); ) {
                let t4 = p2();
                if (a2(r.Equals)) {
                  if (++n2, !(t4 instanceof w)) throw new SyntaxError("Expected identifier for keyword argument");
                  const e7 = p2();
                  t4 = new O(t4, e7);
                }
                e6.push(t4), a2(r.Comma) && ++n2;
              }
              return e6;
            })();
            return o2(r.CloseParen, "Expected closing parenthesis for arguments list"), e5;
          })());
          return a2(r.OpenParen) && (t3 = $2(t3)), t3;
        }
        function N2() {
          const e4 = [];
          let t3 = false;
          for (; !a2(r.CloseSquareBracket); ) a2(r.Colon) ? (e4.push(void 0), ++n2, t3 = true) : (e4.push(p2()), a2(r.Colon) && (++n2, t3 = true));
          if (0 === e4.length) throw new SyntaxError("Expected at least one argument for member/slice expression");
          if (t3) {
            if (e4.length > 3) throw new SyntaxError("Expected 0-3 arguments for slice expression");
            return new E(...e4);
          }
          return e4[0];
        }
        function B2() {
          let t3 = z2();
          for (; a2(r.MultiplicativeBinaryOperator); ) {
            const r2 = e3[n2];
            ++n2;
            const o3 = z2();
            t3 = new P(r2, t3, o3);
          }
          return t3;
        }
        function z2() {
          let e4 = (function() {
            let e5 = L2();
            for (; a2(r.Pipe); ) {
              ++n2;
              let t3 = R2();
              if (!(t3 instanceof w)) throw new SyntaxError("Expected identifier for the filter");
              a2(r.OpenParen) && (t3 = $2(t3)), e5 = new A(e5, t3);
            }
            return e5;
          })();
          for (; a2(r.Is); ) {
            ++n2;
            const t3 = a2(r.Not);
            t3 && ++n2;
            let o3 = R2();
            if (o3 instanceof v && (o3 = new w(o3.value.toString())), !(o3 instanceof w)) throw new SyntaxError("Expected identifier for the test");
            e4 = new F(e4, t3, o3);
          }
          return e4;
        }
        function R2() {
          const t3 = e3[n2];
          switch (t3.type) {
            case r.NumericLiteral:
              return ++n2, new y(Number(t3.value));
            case r.StringLiteral:
              return ++n2, new T(t3.value);
            case r.BooleanLiteral:
              return ++n2, new v("true" === t3.value);
            case r.Identifier:
              return ++n2, new w(t3.value);
            case r.OpenParen: {
              ++n2;
              const t4 = u2();
              if (e3[n2].type !== r.CloseParen) throw new SyntaxError(`Expected closing parenthesis, got ${e3[n2].type} instead`);
              return ++n2, t4;
            }
            case r.OpenSquareBracket: {
              ++n2;
              const e4 = [];
              for (; !a2(r.CloseSquareBracket); ) e4.push(p2()), a2(r.Comma) && ++n2;
              return ++n2, new k(e4);
            }
            case r.OpenCurlyBracket: {
              ++n2;
              const e4 = /* @__PURE__ */ new Map();
              for (; !a2(r.CloseCurlyBracket); ) {
                const t4 = p2();
                o2(r.Colon, "Expected colon between key and value in object literal");
                const i3 = p2();
                e4.set(t4, i3), a2(r.Comma) && ++n2;
              }
              return ++n2, new S(e4);
            }
            default:
              throw new SyntaxError(`Unexpected token: ${t3.type}`);
          }
        }
        for (; n2 < e3.length; ) t2.body.push(i2());
        return t2;
      }
      function D(e3, t2, n2 = 1) {
        void 0 === t2 && (t2 = e3, e3 = 0);
        const r2 = [];
        for (let o2 = e3; o2 < t2; o2 += n2) r2.push(o2);
        return r2;
      }
      function L(e3, t2, n2, r2 = 1) {
        const o2 = Math.sign(r2);
        o2 >= 0 ? (t2 = (t2 ??= 0) < 0 ? Math.max(e3.length + t2, 0) : Math.min(t2, e3.length), n2 = (n2 ??= e3.length) < 0 ? Math.max(e3.length + n2, 0) : Math.min(n2, e3.length)) : (t2 = (t2 ??= e3.length - 1) < 0 ? Math.max(e3.length + t2, -1) : Math.min(t2, e3.length - 1), n2 = (n2 ??= -1) < -1 ? Math.max(e3.length + n2, -1) : Math.min(n2, e3.length - 1));
        const i2 = [];
        for (let s2 = t2; o2 * s2 < o2 * n2; s2 += r2) i2.push(e3[s2]);
        return i2;
      }
      function $(e3) {
        return e3.replace(/\b\w/g, ((e4) => e4.toUpperCase()));
      }
      var N = class {
        type = "RuntimeValue";
        value;
        builtins = /* @__PURE__ */ new Map();
        constructor(e3 = void 0) {
          this.value = e3;
        }
        __bool__() {
          return new R(!!this.value);
        }
      }, B = class extends N {
        type = "NumericValue";
      }, z = class extends N {
        type = "StringValue";
        builtins = /* @__PURE__ */ new Map([["upper", new G((() => new z(this.value.toUpperCase())))], ["lower", new G((() => new z(this.value.toLowerCase())))], ["strip", new G((() => new z(this.value.trim())))], ["title", new G((() => new z($(this.value))))], ["length", new B(this.value.length)]]);
      }, R = class extends N {
        type = "BooleanValue";
      }, j = class extends N {
        type = "ObjectValue";
        __bool__() {
          return new R(this.value.size > 0);
        }
        builtins = /* @__PURE__ */ new Map([["get", new G((([e3, t2]) => {
          if (!(e3 instanceof z)) throw new Error(`Object key must be a string: got ${e3.type}`);
          return this.value.get(e3.value) ?? t2 ?? new q();
        }))], ["items", new G((() => new V(Array.from(this.value.entries()).map((([e3, t2]) => new V([new z(e3), t2]))))))]]);
      }, V = class extends N {
        type = "ArrayValue";
        builtins = /* @__PURE__ */ new Map([["length", new B(this.value.length)]]);
        __bool__() {
          return new R(this.value.length > 0);
        }
      }, U = class extends V {
        type = "TupleValue";
      }, G = class extends N {
        type = "FunctionValue";
      }, q = class extends N {
        type = "NullValue";
      }, W = class extends N {
        type = "UndefinedValue";
      }, H = class {
        constructor(e3) {
          this.parent = e3;
        }
        variables = /* @__PURE__ */ new Map([["namespace", new G(((e3) => {
          if (0 === e3.length) return new j(/* @__PURE__ */ new Map());
          if (1 !== e3.length || !(e3[0] instanceof j)) throw new Error("`namespace` expects either zero arguments or a single object argument");
          return e3[0];
        }))]]);
        tests = /* @__PURE__ */ new Map([["boolean", (e3) => "BooleanValue" === e3.type], ["callable", (e3) => e3 instanceof G], ["odd", (e3) => {
          if ("NumericValue" !== e3.type) throw new Error(`Cannot apply test "odd" to type: ${e3.type}`);
          return e3.value % 2 != 0;
        }], ["even", (e3) => {
          if ("NumericValue" !== e3.type) throw new Error(`Cannot apply test "even" to type: ${e3.type}`);
          return e3.value % 2 == 0;
        }], ["false", (e3) => "BooleanValue" === e3.type && !e3.value], ["true", (e3) => "BooleanValue" === e3.type && e3.value], ["number", (e3) => "NumericValue" === e3.type], ["integer", (e3) => "NumericValue" === e3.type && Number.isInteger(e3.value)], ["iterable", (e3) => e3 instanceof V || e3 instanceof z], ["lower", (e3) => {
          const t2 = e3.value;
          return "StringValue" === e3.type && t2 === t2.toLowerCase();
        }], ["upper", (e3) => {
          const t2 = e3.value;
          return "StringValue" === e3.type && t2 === t2.toUpperCase();
        }], ["none", (e3) => "NullValue" === e3.type], ["defined", (e3) => "UndefinedValue" !== e3.type], ["undefined", (e3) => "UndefinedValue" === e3.type], ["equalto", (e3, t2) => e3.value === t2.value]]);
        set(e3, t2) {
          return this.declareVariable(e3, Q(t2));
        }
        declareVariable(e3, t2) {
          if (this.variables.has(e3)) throw new SyntaxError(`Variable already declared: ${e3}`);
          return this.variables.set(e3, t2), t2;
        }
        setVariable(e3, t2) {
          return this.variables.set(e3, t2), t2;
        }
        resolve(e3) {
          if (this.variables.has(e3)) return this;
          if (this.parent) return this.parent.resolve(e3);
          throw new Error(`Unknown variable: ${e3}`);
        }
        lookupVariable(e3) {
          try {
            return this.resolve(e3).variables.get(e3) ?? new W();
          } catch {
            return new W();
          }
        }
      }, X = class {
        global;
        constructor(e3) {
          this.global = e3 ?? new H();
        }
        run(e3) {
          return this.evaluate(e3, this.global);
        }
        evaluateBinaryExpression(e3, t2) {
          const n2 = this.evaluate(e3.left, t2);
          switch (e3.operator.value) {
            case "and":
              return n2.__bool__().value ? this.evaluate(e3.right, t2) : n2;
            case "or":
              return n2.__bool__().value ? n2 : this.evaluate(e3.right, t2);
          }
          const r2 = this.evaluate(e3.right, t2);
          switch (e3.operator.value) {
            case "==":
              return new R(n2.value == r2.value);
            case "!=":
              return new R(n2.value != r2.value);
          }
          if (n2 instanceof W || r2 instanceof W) throw new Error("Cannot perform operation on undefined values");
          if (n2 instanceof q || r2 instanceof q) throw new Error("Cannot perform operation on null values");
          if (n2 instanceof B && r2 instanceof B) switch (e3.operator.value) {
            case "+":
              return new B(n2.value + r2.value);
            case "-":
              return new B(n2.value - r2.value);
            case "*":
              return new B(n2.value * r2.value);
            case "/":
              return new B(n2.value / r2.value);
            case "%":
              return new B(n2.value % r2.value);
            case "<":
              return new R(n2.value < r2.value);
            case ">":
              return new R(n2.value > r2.value);
            case ">=":
              return new R(n2.value >= r2.value);
            case "<=":
              return new R(n2.value <= r2.value);
          }
          else if (n2 instanceof V && r2 instanceof V) {
            if ("+" === e3.operator.value) return new V(n2.value.concat(r2.value));
          } else if (r2 instanceof V) {
            const t3 = void 0 !== r2.value.find(((e4) => e4.value === n2.value));
            switch (e3.operator.value) {
              case "in":
                return new R(t3);
              case "not in":
                return new R(!t3);
            }
          }
          if ((n2 instanceof z || r2 instanceof z) && "+" === e3.operator.value) return new z(n2.value.toString() + r2.value.toString());
          if (n2 instanceof z && r2 instanceof z) switch (e3.operator.value) {
            case "in":
              return new R(r2.value.includes(n2.value));
            case "not in":
              return new R(!r2.value.includes(n2.value));
          }
          if (n2 instanceof z && r2 instanceof j) switch (e3.operator.value) {
            case "in":
              return new R(r2.value.has(n2.value));
            case "not in":
              return new R(!r2.value.has(n2.value));
          }
          throw new SyntaxError(`Unknown operator "${e3.operator.value}" between ${n2.type} and ${r2.type}`);
        }
        evaluateFilterExpression(e3, t2) {
          const n2 = this.evaluate(e3.operand, t2);
          if ("Identifier" === e3.filter.type) {
            const t3 = e3.filter;
            if (n2 instanceof V) switch (t3.value) {
              case "list":
                return n2;
              case "first":
                return n2.value[0];
              case "last":
                return n2.value[n2.value.length - 1];
              case "length":
                return new B(n2.value.length);
              case "reverse":
                return new V(n2.value.reverse());
              case "sort":
                return new V(n2.value.sort(((e4, t4) => {
                  if (e4.type !== t4.type) throw new Error(`Cannot compare different types: ${e4.type} and ${t4.type}`);
                  switch (e4.type) {
                    case "NumericValue":
                      return e4.value - t4.value;
                    case "StringValue":
                      return e4.value.localeCompare(t4.value);
                    default:
                      throw new Error(`Cannot compare type: ${e4.type}`);
                  }
                })));
              default:
                throw new Error(`Unknown ArrayValue filter: ${t3.value}`);
            }
            else if (n2 instanceof z) switch (t3.value) {
              case "length":
                return new B(n2.value.length);
              case "upper":
                return new z(n2.value.toUpperCase());
              case "lower":
                return new z(n2.value.toLowerCase());
              case "title":
                return new z($(n2.value));
              case "capitalize":
                return new z(n2.value.charAt(0).toUpperCase() + n2.value.slice(1));
              case "trim":
                return new z(n2.value.trim());
              default:
                throw new Error(`Unknown StringValue filter: ${t3.value}`);
            }
            else {
              if (n2 instanceof B) {
                if ("abs" === t3.value) return new B(Math.abs(n2.value));
                throw new Error(`Unknown NumericValue filter: ${t3.value}`);
              }
              if (n2 instanceof j) switch (t3.value) {
                case "items":
                  return new V(Array.from(n2.value.entries()).map((([e4, t4]) => new V([new z(e4), t4]))));
                case "length":
                  return new B(n2.value.size);
                default:
                  throw new Error(`Unknown ObjectValue filter: ${t3.value}`);
              }
            }
            throw new Error(`Cannot apply filter "${t3.value}" to type: ${n2.type}`);
          }
          if ("CallExpression" === e3.filter.type) {
            const r2 = e3.filter;
            if ("Identifier" !== r2.callee.type) throw new Error(`Unknown filter: ${r2.callee.type}`);
            const o2 = r2.callee.value;
            if (n2 instanceof V) {
              if ("selectattr" === o2) {
                if (n2.value.some(((e5) => !(e5 instanceof j)))) throw new Error("`selectattr` can only be applied to array of objects");
                if (r2.args.some(((e5) => "StringLiteral" !== e5.type))) throw new Error("arguments of `selectattr` must be strings");
                const [e4, o3, i2] = r2.args.map(((e5) => this.evaluate(e5, t2)));
                let s2;
                if (o3) {
                  const e5 = t2.tests.get(o3.value);
                  if (!e5) throw new Error(`Unknown test: ${o3.value}`);
                  s2 = e5;
                } else s2 = (...e5) => e5[0].__bool__().value;
                const a2 = n2.value.filter(((t3) => {
                  const n3 = t3.value.get(e4.value);
                  return !!n3 && s2(n3, i2);
                }));
                return new V(a2);
              }
              throw new Error(`Unknown ArrayValue filter: ${o2}`);
            }
            throw new Error(`Cannot apply filter "${o2}" to type: ${n2.type}`);
          }
          throw new Error(`Unknown filter: ${e3.filter.type}`);
        }
        evaluateTestExpression(e3, t2) {
          const n2 = this.evaluate(e3.operand, t2), r2 = t2.tests.get(e3.test.value);
          if (!r2) throw new Error(`Unknown test: ${e3.test.value}`);
          const o2 = r2(n2);
          return new R(e3.negate ? !o2 : o2);
        }
        evaluateUnaryExpression(e3, t2) {
          const n2 = this.evaluate(e3.argument, t2);
          if ("not" === e3.operator.value) return new R(!n2.value);
          throw new SyntaxError(`Unknown operator: ${e3.operator.value}`);
        }
        evalProgram(e3, t2) {
          return this.evaluateBlock(e3.body, t2);
        }
        evaluateBlock(e3, t2) {
          let n2 = "";
          for (const r2 of e3) {
            const e4 = this.evaluate(r2, t2);
            "NullValue" !== e4.type && "UndefinedValue" !== e4.type && (n2 += e4.value);
          }
          return new z(n2);
        }
        evaluateIdentifier(e3, t2) {
          return t2.lookupVariable(e3.value);
        }
        evaluateCallExpression(e3, t2) {
          const n2 = [], r2 = /* @__PURE__ */ new Map();
          for (const o3 of e3.args) if ("KeywordArgumentExpression" === o3.type) {
            const e4 = o3;
            r2.set(e4.key.value, this.evaluate(e4.value, t2));
          } else n2.push(this.evaluate(o3, t2));
          r2.size > 0 && n2.push(new j(r2));
          const o2 = this.evaluate(e3.callee, t2);
          if ("FunctionValue" !== o2.type) throw new Error(`Cannot call something that is not a function: got ${o2.type}`);
          return o2.value(n2, t2);
        }
        evaluateSliceExpression(e3, t2, n2) {
          if (!(e3 instanceof V || e3 instanceof z)) throw new Error("Slice object must be an array or string");
          const r2 = this.evaluate(t2.start, n2), o2 = this.evaluate(t2.stop, n2), i2 = this.evaluate(t2.step, n2);
          if (!(r2 instanceof B || r2 instanceof W)) throw new Error("Slice start must be numeric or undefined");
          if (!(o2 instanceof B || o2 instanceof W)) throw new Error("Slice stop must be numeric or undefined");
          if (!(i2 instanceof B || i2 instanceof W)) throw new Error("Slice step must be numeric or undefined");
          return e3 instanceof V ? new V(L(e3.value, r2.value, o2.value, i2.value)) : new z(L(Array.from(e3.value), r2.value, o2.value, i2.value).join(""));
        }
        evaluateMemberExpression(e3, t2) {
          const n2 = this.evaluate(e3.object, t2);
          let r2, o2;
          if (e3.computed) {
            if ("SliceExpression" === e3.property.type) return this.evaluateSliceExpression(n2, e3.property, t2);
            r2 = this.evaluate(e3.property, t2);
          } else r2 = new z(e3.property.value);
          if (n2 instanceof j) {
            if (!(r2 instanceof z)) throw new Error(`Cannot access property with non-string: got ${r2.type}`);
            o2 = n2.value.get(r2.value) ?? n2.builtins.get(r2.value);
          } else if (n2 instanceof V || n2 instanceof z) if (r2 instanceof B) o2 = n2.value.at(r2.value), n2 instanceof z && (o2 = new z(n2.value.at(r2.value)));
          else {
            if (!(r2 instanceof z)) throw new Error(`Cannot access property with non-string/non-number: got ${r2.type}`);
            o2 = n2.builtins.get(r2.value);
          }
          else {
            if (!(r2 instanceof z)) throw new Error(`Cannot access property with non-string: got ${r2.type}`);
            o2 = n2.builtins.get(r2.value);
          }
          return o2 instanceof N ? o2 : new W();
        }
        evaluateSet(e3, t2) {
          const n2 = this.evaluate(e3.value, t2);
          if ("Identifier" === e3.assignee.type) {
            const r2 = e3.assignee.value;
            t2.setVariable(r2, n2);
          } else {
            if ("MemberExpression" !== e3.assignee.type) throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e3.assignee)}`);
            {
              const r2 = e3.assignee, o2 = this.evaluate(r2.object, t2);
              if (!(o2 instanceof j)) throw new Error("Cannot assign to member of non-object");
              if ("Identifier" !== r2.property.type) throw new Error("Cannot assign to member with non-identifier property");
              o2.value.set(r2.property.value, n2);
            }
          }
          return new q();
        }
        evaluateIf(e3, t2) {
          const n2 = this.evaluate(e3.test, t2);
          return this.evaluateBlock(n2.__bool__().value ? e3.body : e3.alternate, t2);
        }
        evaluateFor(e3, t2) {
          const n2 = new H(t2), r2 = this.evaluate(e3.iterable, n2);
          if (!(r2 instanceof V)) throw new Error(`Expected iterable type in for loop: got ${r2.type}`);
          let o2 = "";
          for (let t3 = 0; t3 < r2.value.length; ++t3) {
            const i2 = /* @__PURE__ */ new Map([["index", new B(t3 + 1)], ["index0", new B(t3)], ["revindex", new B(r2.value.length - t3)], ["revindex0", new B(r2.value.length - t3 - 1)], ["first", new R(0 === t3)], ["last", new R(t3 === r2.value.length - 1)], ["length", new B(r2.value.length)], ["previtem", t3 > 0 ? r2.value[t3 - 1] : new W()], ["nextitem", t3 < r2.value.length - 1 ? r2.value[t3 + 1] : new W()]]);
            n2.setVariable("loop", new j(i2));
            const s2 = r2.value[t3];
            if ("Identifier" === e3.loopvar.type) n2.setVariable(e3.loopvar.value, s2);
            else if ("TupleLiteral" === e3.loopvar.type) {
              const t4 = e3.loopvar;
              if ("ArrayValue" !== s2.type) throw new Error(`Cannot unpack non-iterable type: ${s2.type}`);
              const r3 = s2;
              if (t4.value.length !== r3.value.length) throw new Error(`Too ${t4.value.length > r3.value.length ? "few" : "many"} items to unpack`);
              for (let e4 = 0; e4 < t4.value.length; ++e4) {
                if ("Identifier" !== t4.value[e4].type) throw new Error(`Cannot unpack non-identifier type: ${t4.value[e4].type}`);
                n2.setVariable(t4.value[e4].value, r3.value[e4]);
              }
            }
            o2 += this.evaluateBlock(e3.body, n2).value;
          }
          return new z(o2);
        }
        evaluate(e3, t2) {
          if (void 0 === e3) return new W();
          switch (e3.type) {
            case "Program":
              return this.evalProgram(e3, t2);
            case "Set":
              return this.evaluateSet(e3, t2);
            case "If":
              return this.evaluateIf(e3, t2);
            case "For":
              return this.evaluateFor(e3, t2);
            case "NumericLiteral":
              return new B(Number(e3.value));
            case "StringLiteral":
              return new z(e3.value);
            case "BooleanLiteral":
              return new R(e3.value);
            case "ArrayLiteral":
              return new V(e3.value.map(((e4) => this.evaluate(e4, t2))));
            case "TupleLiteral":
              return new U(e3.value.map(((e4) => this.evaluate(e4, t2))));
            case "ObjectLiteral": {
              const n2 = /* @__PURE__ */ new Map();
              for (const [r2, o2] of e3.value) {
                const e4 = this.evaluate(r2, t2);
                if (!(e4 instanceof z)) throw new Error(`Object keys must be strings: got ${e4.type}`);
                n2.set(e4.value, this.evaluate(o2, t2));
              }
              return new j(n2);
            }
            case "Identifier":
              return this.evaluateIdentifier(e3, t2);
            case "CallExpression":
              return this.evaluateCallExpression(e3, t2);
            case "MemberExpression":
              return this.evaluateMemberExpression(e3, t2);
            case "UnaryExpression":
              return this.evaluateUnaryExpression(e3, t2);
            case "BinaryExpression":
              return this.evaluateBinaryExpression(e3, t2);
            case "FilterExpression":
              return this.evaluateFilterExpression(e3, t2);
            case "TestExpression":
              return this.evaluateTestExpression(e3, t2);
            default:
              throw new SyntaxError(`Unknown node type: ${e3.type}`);
          }
        }
      };
      function Q(e3) {
        switch (typeof e3) {
          case "number":
            return new B(e3);
          case "string":
            return new z(e3);
          case "boolean":
            return new R(e3);
          case "object":
            return null === e3 ? new q() : Array.isArray(e3) ? new V(e3.map(Q)) : new j(new Map(Object.entries(e3).map((([e4, t2]) => [e4, Q(t2)]))));
          case "function":
            return new G(((t2, n2) => Q(e3(...t2.map(((e4) => e4.value))) ?? null)));
          default:
            throw new Error(`Cannot convert to runtime value: ${e3}`);
        }
      }
      var Y = class {
        parsed;
        constructor(e3) {
          const t2 = u(e3, { lstrip_blocks: true, trim_blocks: true });
          this.parsed = I(t2);
        }
        render(e3) {
          const t2 = new H();
          t2.set("false", false), t2.set("true", true), t2.set("raise_exception", ((e4) => {
            throw new Error(e4);
          })), t2.set("range", D);
          for (const [n2, r2] of Object.entries(e3)) t2.set(n2, r2);
          return new X(t2).run(this.parsed).value;
        }
      };
    }
  ), "./src/backends/onnx.js": (
    /*!******************************!*\
      !*** ./src/backends/onnx.js ***!
      \******************************/
    (e2, t, n) => {
      var r, o;
      n.r(t), n.d(t, { ONNX: () => a, executionProviders: () => l });
      var i = n(
        /*! onnxruntime-node */
        "?2ce3"
      ), s = n(
        /*! onnxruntime-web */
        "./node_modules/onnxruntime-web/dist/ort-web.min.js"
      );
      let a;
      const l = ["wasm"];
      if ("undefined" != typeof process && "node" === process?.release?.name) a = i ?? (r || (r = n.t(i, 2))), l.unshift("cpu");
      else {
        a = s ?? (o || (o = n.t(s, 2)));
        "undefined" != typeof navigator && /iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent) && (a.env.wasm.simd = false);
      }
    }
  ), "./src/configs.js": (
    /*!************************!*\
      !*** ./src/configs.js ***!
      \************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { AutoConfig: () => i, PretrainedConfig: () => o });
      var r = n(
        /*! ./utils/hub.js */
        "./src/utils/hub.js"
      );
      class o {
        constructor(e3) {
          this.model_type = null, this.is_encoder_decoder = false, Object.assign(this, e3);
        }
        static async from_pretrained(e3, { progress_callback: t2 = null, config: n2 = null, cache_dir: o2 = null, local_files_only: i2 = false, revision: s = "main" } = {}) {
          let a = n2 ?? await (async function(e4, t3) {
            return await (0, r.getModelJSON)(e4, "config.json", true, t3);
          })(e3, { progress_callback: t2, config: n2, cache_dir: o2, local_files_only: i2, revision: s });
          return new this(a);
        }
      }
      class i {
        static async from_pretrained(...e3) {
          return o.from_pretrained(...e3);
        }
      }
    }
  ), "./src/env.js": (
    /*!********************!*\
      !*** ./src/env.js ***!
      \********************/
    (e2, t, n) => {
      n.r(t), n.d(t, { env: () => g });
      var r = n(
        /*! fs */
        "?569f"
      ), o = n(
        /*! path */
        "?3f59"
      ), i = n(
        /*! url */
        "?154a"
      ), s = n(
        /*! ./backends/onnx.js */
        "./src/backends/onnx.js"
      );
      const { env: a } = s.ONNX, l = "2.17.1", c = "undefined" != typeof self && "caches" in self, u = !b(r), p = !b(o), d = u && p, _ = d ? o.dirname(o.dirname(i.fileURLToPath("file:///home/runner/work/transformers.js/transformers.js/src/env.js"))) : "./", h = d ? o.join(_, "/.cache/") : null, f = "/models/", m = d ? o.join(_, f) : f;
      a?.wasm && (a.wasm.wasmPaths = d ? o.join(_, "/dist/") : `https://cdn.jsdelivr.net/npm/@xenova/transformers@${l}/dist/`);
      const g = { backends: { onnx: a, tfjs: {} }, __dirname: _, version: l, allowRemoteModels: true, remoteHost: "https://huggingface.co/", remotePathTemplate: "{model}/resolve/{revision}/", allowLocalModels: true, localModelPath: m, useFS: u, useBrowserCache: c, useFSCache: u, cacheDir: h, useCustomCache: false, customCache: null };
      function b(e3) {
        return 0 === Object.keys(e3).length;
      }
    }
  ), "./src/models.js": (
    /*!***********************!*\
      !*** ./src/models.js ***!
      \***********************/
    (e2, t, n) => {
      n.r(t), n.d(t, { ASTForAudioClassification: () => Jt, ASTModel: () => Zt, ASTPreTrainedModel: () => Kt, AlbertForMaskedLM: () => lt, AlbertForQuestionAnswering: () => at, AlbertForSequenceClassification: () => st, AlbertModel: () => it, AlbertPreTrainedModel: () => ot, AutoModel: () => ts, AutoModelForAudioClassification: () => ws, AutoModelForAudioFrameClassification: () => ys, AutoModelForCTC: () => bs, AutoModelForCausalLM: () => ls, AutoModelForDepthEstimation: () => Ms, AutoModelForDocumentQuestionAnswering: () => Ts, AutoModelForImageClassification: () => ds, AutoModelForImageFeatureExtraction: () => Ss, AutoModelForImageMatting: () => vs, AutoModelForImageSegmentation: () => _s, AutoModelForImageToImage: () => ks, AutoModelForMaskGeneration: () => gs, AutoModelForMaskedLM: () => cs, AutoModelForObjectDetection: () => fs, AutoModelForQuestionAnswering: () => us, AutoModelForSemanticSegmentation: () => hs, AutoModelForSeq2SeqLM: () => os, AutoModelForSequenceClassification: () => ns, AutoModelForSpeechSeq2Seq: () => is, AutoModelForTextToSpectrogram: () => ss, AutoModelForTextToWaveform: () => as, AutoModelForTokenClassification: () => rs, AutoModelForVision2Seq: () => ps, AutoModelForXVector: () => xs, AutoModelForZeroShotObjectDetection: () => ms, BartForConditionalGeneration: () => xt, BartForSequenceClassification: () => yt, BartModel: () => wt, BartPretrainedModel: () => bt, BaseModelOutput: () => R, BeitForImageClassification: () => mr, BeitModel: () => fr, BeitPreTrainedModel: () => hr, BertForMaskedLM: () => U, BertForQuestionAnswering: () => W, BertForSequenceClassification: () => G, BertForTokenClassification: () => q, BertModel: () => V, BertPreTrainedModel: () => j, BlenderbotForConditionalGeneration: () => Ft, BlenderbotModel: () => At, BlenderbotPreTrainedModel: () => Pt, BlenderbotSmallForConditionalGeneration: () => Ot, BlenderbotSmallModel: () => Et, BlenderbotSmallPreTrainedModel: () => Ct, BloomForCausalLM: () => Hn, BloomModel: () => Wn, BloomPreTrainedModel: () => qn, CLIPModel: () => sn, CLIPPreTrainedModel: () => on, CLIPSegForImageSegmentation: () => gn, CLIPSegModel: () => mn, CLIPSegPreTrainedModel: () => fn, CLIPTextModelWithProjection: () => an, CLIPVisionModelWithProjection: () => ln, CamembertForMaskedLM: () => fe, CamembertForQuestionAnswering: () => be, CamembertForSequenceClassification: () => me, CamembertForTokenClassification: () => ge, CamembertModel: () => he, CamembertPreTrainedModel: () => _e, CausalLMOutput: () => Is, CausalLMOutputWithPast: () => Ds, ChineseCLIPModel: () => hn, ChineseCLIPPreTrainedModel: () => _n, ClapAudioModelWithProjection: () => pi, ClapModel: () => ci, ClapPreTrainedModel: () => li, ClapTextModelWithProjection: () => ui, CodeGenForCausalLM: () => Ln, CodeGenModel: () => Dn, CodeGenPreTrainedModel: () => In, ConvBertForMaskedLM: () => re, ConvBertForQuestionAnswering: () => se, ConvBertForSequenceClassification: () => oe, ConvBertForTokenClassification: () => ie, ConvBertModel: () => ne, ConvBertPreTrainedModel: () => te, ConvNextForImageClassification: () => Kr, ConvNextModel: () => Yr, ConvNextPreTrainedModel: () => Qr, ConvNextV2ForImageClassification: () => eo, ConvNextV2Model: () => Jr, ConvNextV2PreTrainedModel: () => Zr, DPTForDepthEstimation: () => jr, DPTModel: () => Rr, DPTPreTrainedModel: () => zr, DebertaForMaskedLM: () => ye, DebertaForQuestionAnswering: () => ke, DebertaForSequenceClassification: () => Te, DebertaForTokenClassification: () => ve, DebertaModel: () => xe, DebertaPreTrainedModel: () => we, DebertaV2ForMaskedLM: () => Pe, DebertaV2ForQuestionAnswering: () => Ce, DebertaV2ForSequenceClassification: () => Ae, DebertaV2ForTokenClassification: () => Fe, DebertaV2Model: () => Se, DebertaV2PreTrainedModel: () => Me, DeiTForImageClassification: () => Fr, DeiTModel: () => Ar, DeiTPreTrainedModel: () => Pr, DepthAnythingForDepthEstimation: () => Ur, DepthAnythingPreTrainedModel: () => Vr, DetrForObjectDetection: () => wr, DetrForSegmentation: () => xr, DetrModel: () => br, DetrObjectDetectionOutput: () => yr, DetrPreTrainedModel: () => gr, DetrSegmentationOutput: () => Tr, Dinov2ForImageClassification: () => ro, Dinov2Model: () => no, Dinov2PreTrainedModel: () => to, DistilBertForMaskedLM: () => $e, DistilBertForQuestionAnswering: () => Le, DistilBertForSequenceClassification: () => Ie, DistilBertForTokenClassification: () => De, DistilBertModel: () => Oe, DistilBertPreTrainedModel: () => Ee, DonutSwinModel: () => Xr, DonutSwinPreTrainedModel: () => Hr, EfficientNetForImageClassification: () => vi, EfficientNetModel: () => Ti, EfficientNetPreTrainedModel: () => yi, ElectraForMaskedLM: () => ce, ElectraForQuestionAnswering: () => de, ElectraForSequenceClassification: () => ue, ElectraForTokenClassification: () => pe, ElectraModel: () => le, ElectraPreTrainedModel: () => ae, EsmForMaskedLM: () => ze, EsmForSequenceClassification: () => Re, EsmForTokenClassification: () => je, EsmModel: () => Be, EsmPreTrainedModel: () => Ne, FalconForCausalLM: () => ai, FalconModel: () => si, FalconPreTrainedModel: () => ii, GLPNForDepthEstimation: () => Wr, GLPNModel: () => qr, GLPNPreTrainedModel: () => Gr, GPT2LMHeadModel: () => xn, GPT2Model: () => wn, GPT2PreTrainedModel: () => bn, GPTBigCodeForCausalLM: () => On, GPTBigCodeModel: () => En, GPTBigCodePreTrainedModel: () => Cn, GPTJForCausalLM: () => Fn, GPTJModel: () => An, GPTJPreTrainedModel: () => Pn, GPTNeoForCausalLM: () => vn, GPTNeoModel: () => Tn, GPTNeoPreTrainedModel: () => yn, GPTNeoXForCausalLM: () => Sn, GPTNeoXModel: () => Mn, GPTNeoXPreTrainedModel: () => kn, HubertForCTC: () => Bo, HubertForSequenceClassification: () => zo, HubertModel: () => No, HubertPreTrainedModel: () => $o, ImageMattingOutput: () => Ls, LlamaForCausalLM: () => Bn, LlamaModel: () => Nn, LlamaPreTrainedModel: () => $n, LongT5ForConditionalGeneration: () => ht, LongT5Model: () => _t, LongT5PreTrainedModel: () => dt, M2M100ForConditionalGeneration: () => go, M2M100Model: () => mo, M2M100PreTrainedModel: () => fo, MBartForCausalLM: () => St, MBartForConditionalGeneration: () => kt, MBartForSequenceClassification: () => Mt, MBartModel: () => vt, MBartPreTrainedModel: () => Tt, MPNetForMaskedLM: () => Qe, MPNetForQuestionAnswering: () => Ze, MPNetForSequenceClassification: () => Ye, MPNetForTokenClassification: () => Ke, MPNetModel: () => Xe, MPNetPreTrainedModel: () => He, MT5ForConditionalGeneration: () => gt, MT5Model: () => mt, MT5PreTrainedModel: () => ft, MarianMTModel: () => ho, MarianModel: () => _o, MarianPreTrainedModel: () => po, MaskedLMOutput: () => Es, MistralForCausalLM: () => ti, MistralModel: () => ei, MistralPreTrainedModel: () => Jo, MobileBertForMaskedLM: () => Ge, MobileBertForQuestionAnswering: () => We, MobileBertForSequenceClassification: () => qe, MobileBertModel: () => Ue, MobileBertPreTrainedModel: () => Ve, MobileViTForImageClassification: () => ar, MobileViTModel: () => sr, MobileViTPreTrainedModel: () => ir, ModelOutput: () => z, MptForCausalLM: () => Yn, MptModel: () => Qn, MptPreTrainedModel: () => Xn, NomicBertModel: () => X, NomicBertPreTrainedModel: () => H, OPTForCausalLM: () => Jn, OPTModel: () => Zn, OPTPreTrainedModel: () => Kn, OwlViTForObjectDetection: () => ur, OwlViTModel: () => cr, OwlViTPreTrainedModel: () => lr, Owlv2ForObjectDetection: () => _r, Owlv2Model: () => dr, Owlv2PreTrainedModel: () => pr, PhiForCausalLM: () => Gn, PhiModel: () => Un, PhiPreTrainedModel: () => Vn, PreTrainedModel: () => B, PretrainedMixin: () => ki, QuestionAnsweringModelOutput: () => Os, Qwen2ForCausalLM: () => jn, Qwen2Model: () => Rn, Qwen2PreTrainedModel: () => zn, ResNetForImageClassification: () => Or, ResNetModel: () => Er, ResNetPreTrainedModel: () => Cr, RoFormerForMaskedLM: () => K, RoFormerForQuestionAnswering: () => ee, RoFormerForSequenceClassification: () => Z, RoFormerForTokenClassification: () => J, RoFormerModel: () => Y, RoFormerPreTrainedModel: () => Q, RobertaForMaskedLM: () => Lt, RobertaForQuestionAnswering: () => Bt, RobertaForSequenceClassification: () => $t, RobertaForTokenClassification: () => Nt, RobertaModel: () => Dt, RobertaPreTrainedModel: () => It, SamImageSegmentationOutput: () => uo, SamModel: () => co, SamPreTrainedModel: () => lo, SegformerForImageClassification: () => mi, SegformerForSemanticSegmentation: () => gi, SegformerModel: () => fi, SegformerPreTrainedModel: () => hi, Seq2SeqLMOutput: () => Ps, SequenceClassifierOutput: () => As, SiglipModel: () => un, SiglipPreTrainedModel: () => cn, SiglipTextModel: () => pn, SiglipVisionModel: () => dn, SpeechT5ForSpeechToText: () => Xo, SpeechT5ForTextToSpeech: () => Qo, SpeechT5HifiGan: () => Yo, SpeechT5Model: () => Ho, SpeechT5PreTrainedModel: () => Wo, SqueezeBertForMaskedLM: () => tt, SqueezeBertForQuestionAnswering: () => rt, SqueezeBertForSequenceClassification: () => nt, SqueezeBertModel: () => et, SqueezeBertPreTrainedModel: () => Je, StableLmForCausalLM: () => xi, StableLmModel: () => wi, StableLmPreTrainedModel: () => bi, Starcoder2ForCausalLM: () => oi, Starcoder2Model: () => ri, Starcoder2PreTrainedModel: () => ni, Swin2SRForImageSuperResolution: () => Br, Swin2SRModel: () => Nr, Swin2SRPreTrainedModel: () => $r, SwinForImageClassification: () => Lr, SwinModel: () => Dr, SwinPreTrainedModel: () => Ir, T5ForConditionalGeneration: () => pt, T5Model: () => ut, T5PreTrainedModel: () => ct, TableTransformerForObjectDetection: () => Mr, TableTransformerModel: () => kr, TableTransformerObjectDetectionOutput: () => Sr, TableTransformerPreTrainedModel: () => vr, TokenClassifierOutput: () => Cs, TrOCRForCausalLM: () => Zo, TrOCRPreTrainedModel: () => Ko, UniSpeechForCTC: () => Mo, UniSpeechForSequenceClassification: () => So, UniSpeechModel: () => ko, UniSpeechPreTrainedModel: () => vo, UniSpeechSatForAudioFrameClassification: () => Eo, UniSpeechSatForCTC: () => Fo, UniSpeechSatForSequenceClassification: () => Co, UniSpeechSatModel: () => Ao, UniSpeechSatPreTrainedModel: () => Po, ViTForImageClassification: () => nr, ViTModel: () => tr, ViTPreTrainedModel: () => er, VisionEncoderDecoderModel: () => rn, VitMatteForImageMatting: () => or, VitMattePreTrainedModel: () => rr, VitsModel: () => _i, VitsModelOutput: () => $s, VitsPreTrainedModel: () => di, Wav2Vec2BertForCTC: () => Do, Wav2Vec2BertForSequenceClassification: () => Lo, Wav2Vec2BertModel: () => Io, Wav2Vec2BertPreTrainedModel: () => Oo, Wav2Vec2ForAudioFrameClassification: () => To, Wav2Vec2ForCTC: () => xo, Wav2Vec2ForSequenceClassification: () => yo, Wav2Vec2Model: () => wo, Wav2Vec2PreTrainedModel: () => bo, WavLMForAudioFrameClassification: () => qo, WavLMForCTC: () => Vo, WavLMForSequenceClassification: () => Uo, WavLMForXVector: () => Go, WavLMModel: () => jo, WavLMPreTrainedModel: () => Ro, WhisperForConditionalGeneration: () => nn, WhisperModel: () => tn, WhisperPreTrainedModel: () => en, XLMForQuestionAnswering: () => Gt, XLMForSequenceClassification: () => Vt, XLMForTokenClassification: () => Ut, XLMModel: () => Rt, XLMPreTrainedModel: () => zt, XLMRobertaForMaskedLM: () => Ht, XLMRobertaForQuestionAnswering: () => Yt, XLMRobertaForSequenceClassification: () => Xt, XLMRobertaForTokenClassification: () => Qt, XLMRobertaModel: () => Wt, XLMRobertaPreTrainedModel: () => qt, XLMWithLMHeadModel: () => jt, XVectorOutput: () => Fs, YolosForObjectDetection: () => so, YolosModel: () => io, YolosObjectDetectionOutput: () => ao, YolosPreTrainedModel: () => oo });
      var r = n(
        /*! ./configs.js */
        "./src/configs.js"
      ), o = n(
        /*! ./utils/core.js */
        "./src/utils/core.js"
      ), i = n(
        /*! ./utils/hub.js */
        "./src/utils/hub.js"
      ), s = n(
        /*! ./utils/generation.js */
        "./src/utils/generation.js"
      ), a = n(
        /*! ./utils/tensor.js */
        "./src/utils/tensor.js"
      ), l = n(
        /*! ./backends/onnx.js */
        "./src/backends/onnx.js"
      ), c = n(
        /*! ./transformers.js */
        "./src/transformers.js"
      );
      const { InferenceSession: u, Tensor: p, env: d } = l.ONNX, _ = 0, h = 1, f = 2, m = 3, g = 4, b = 5, w = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map();
      async function T(e3, t2, n2) {
        let r2 = `onnx/${t2}${n2.quantized ? "_quantized" : ""}.onnx`, o2 = await (0, i.getModelFile)(e3, r2, true, n2);
        try {
          return await u.create(o2, { executionProviders: l.executionProviders });
        } catch (e4) {
          if (1 === l.executionProviders.length && "wasm" === l.executionProviders[0]) throw e4;
          return console.warn(e4), console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "), await u.create(o2, { executionProviders: ["wasm"] });
        }
      }
      async function v(e3, t2) {
        const n2 = (function(e4, t3) {
          const n3 = /* @__PURE__ */ Object.create(null), r2 = [];
          for (const o3 of e4.inputNames) {
            const e5 = t3[o3];
            e5 instanceof a.Tensor ? n3[o3] = d.wasm.proxy ? e5.clone() : e5 : r2.push(o3);
          }
          if (r2.length > 0) throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r2.join(", ")}.`);
          const o2 = Object.keys(t3).length, i2 = e4.inputNames.length;
          if (o2 > i2) {
            let n4 = Object.keys(t3).filter(((t4) => !e4.inputNames.includes(t4)));
            console.warn(`WARNING: Too many inputs were provided (${o2} > ${i2}). The following inputs will be ignored: "${n4.join(", ")}".`);
          }
          return n3;
        })(e3, t2);
        try {
          let t3 = await e3.run(n2);
          return t3 = k(t3), t3;
        } catch (e4) {
          throw console.error(`An error occurred during model execution: "${e4}".`), console.error("Inputs given to model:", n2), e4;
        }
      }
      function k(e3) {
        for (let t2 in e3) e3[t2] instanceof p ? e3[t2] = new a.Tensor(e3[t2]) : "object" == typeof e3[t2] && k(e3[t2]);
        return e3;
      }
      function M(e3) {
        if (e3 instanceof a.Tensor) return e3;
        if (0 === e3.length) throw Error("items must be non-empty");
        if (Array.isArray(e3[0])) {
          if (e3.some(((t2) => t2.length !== e3[0].length))) throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");
          return new a.Tensor("int64", BigInt64Array.from(e3.flat().map(((e4) => BigInt(e4)))), [e3.length, e3[0].length]);
        }
        return new a.Tensor("int64", BigInt64Array.from(e3.map(((e4) => BigInt(e4)))), [1, e3.length]);
      }
      function S(e3, t2) {
        let n2 = e3.config.pad_token_id ?? null, r2 = e3.config.eos_token_id ?? null;
        (0, o.isIntegralNumber)(r2) && (r2 = [r2]);
        let i2 = -1 !== t2.indexOf(n2), s2 = null === r2 || !r2.includes(n2);
        if (i2 && s2) {
          let e4 = BigInt64Array.from(t2.data.map(((e5) => e5 != n2)));
          return new a.Tensor("int64", e4, t2.dims);
        }
        return (0, a.ones_like)(t2);
      }
      function P(e3, t2, n2) {
        if (!e3.inputNames.includes("position_ids")) return;
        const r2 = new BigInt64Array(t2.attention_mask.data.length);
        for (let e4 = 0; e4 < t2.attention_mask.dims[0]; ++e4) {
          let n3 = e4 * t2.attention_mask.dims[1], o2 = BigInt(0);
          for (let e5 = 0; e5 < t2.attention_mask.dims[1]; ++e5) {
            const i2 = n3 + e5;
            0n === t2.attention_mask.data[i2] ? r2[i2] = BigInt(1) : (r2[i2] = o2, o2 += t2.attention_mask.data[i2]);
          }
        }
        t2.position_ids = new a.Tensor("int64", r2, t2.attention_mask.dims), n2 && (t2.position_ids = t2.position_ids.slice(null, -1).unsqueeze_(-1));
      }
      function A(e3) {
        return new a.Tensor("bool", [e3], [1]);
      }
      async function F(e3, t2) {
        let { encoder_outputs: n2, past_key_values: r2 } = t2;
        n2 || (n2 = (await I(e3, t2)).last_hidden_state);
        let o2 = { input_ids: t2.decoder_input_ids, encoder_hidden_states: n2 };
        const i2 = !!r2;
        e3.decoder_merged_session.inputNames.includes("use_cache_branch") && (o2.use_cache_branch = A(i2)), e3.decoder_merged_session.inputNames.includes("encoder_attention_mask") && (o2.encoder_attention_mask = t2.attention_mask), P(e3.decoder_merged_session, o2, i2), e3.addPastKeyValues(o2, r2);
        const s2 = await v(e3.decoder_merged_session, o2);
        let a2 = s2.logits;
        r2 = e3.getPastKeyValues(s2, r2);
        const l2 = e3.getAttentions(s2);
        return new Ps({ logits: a2, past_key_values: r2, encoder_outputs: n2, ...l2 });
      }
      function C(e3, t2, n2, r2) {
        let o2 = [], i2 = 0;
        const s2 = e3.requires_attention_mask ?? true;
        let l2 = n2.decoder_input_ids ?? n2.decoder_start_token_id ?? n2.bos_token_id ?? n2.eos_token_id;
        l2 instanceof a.Tensor ? l2 = l2.tolist().flat() : Array.isArray(l2) || (l2 = [l2]);
        for (let n3 of t2) {
          n3.dims = [1, ...n3.dims];
          let t3 = { inputs: n3, encoder_outputs: null, prev_model_outputs: null, output_token_ids: l2, done: false, score: 0, id: i2++ };
          s2 && (t3.attention_mask = S(e3, n3)), o2.push(t3);
        }
        return o2;
      }
      async function E(e3, t2) {
        const n2 = e3.main_input_name;
        let r2 = t2.output_token_ids;
        t2.prev_model_outputs && (r2 = r2.slice(-1));
        let o2 = { [n2]: t2.inputs, decoder_input_ids: M(r2), encoder_outputs: t2.encoder_outputs, past_key_values: t2.prev_model_outputs?.past_key_values };
        t2.attention_mask && (o2.attention_mask = t2.attention_mask);
        let i2 = await e3.forward(o2);
        return t2.prev_model_outputs = i2, t2.encoder_outputs = i2.encoder_outputs, i2;
      }
      function O(e3, t2) {
        e3.output_token_ids = [...e3.output_token_ids, t2];
      }
      async function I(e3, t2) {
        const n2 = /* @__PURE__ */ Object.create(null);
        for (const r2 of e3.session.inputNames) n2[r2] = t2[r2];
        return e3.session.inputNames.includes("token_type_ids") && !n2.token_type_ids && (n2.token_type_ids = new a.Tensor("int64", new BigInt64Array(n2.input_ids.data.length), n2.input_ids.dims)), await v(e3.session, n2);
      }
      async function D(e3, t2) {
        let { input_ids: n2, past_key_values: r2, attention_mask: o2 } = t2, i2 = { input_ids: n2, attention_mask: o2 ?? S(e3, n2) };
        const s2 = !!r2;
        e3.session.inputNames.includes("use_cache_branch") && (i2.use_cache_branch = A(s2)), P(e3.session, i2, s2), e3.addPastKeyValues(i2, r2);
        let a2 = await v(e3.session, i2), l2 = a2.logits;
        return r2 = e3.getPastKeyValues(a2, r2), { logits: l2, past_key_values: r2 };
      }
      function L(e3, t2, n2, r2, o2) {
        let i2 = [], s2 = 0;
        for (let n3 of t2) {
          let t3, a2 = n3.tolist().map(Number);
          n3.dims = [1, ...n3.dims], o2 ? (t3 = o2[s2], t3.dims = [1, ...t3.dims]) : t3 = S(e3, n3);
          let l2 = { input: n3, model_input_ids: n3, attention_mask: t3, prev_model_outputs: null, output_token_ids: a2, num_output_tokens: r2, done: false, score: 0, id: s2++ };
          i2.push(l2);
        }
        return i2;
      }
      async function $(e3, t2) {
        let n2 = new BigInt64Array(t2.output_token_ids.length).fill(1n), r2 = { input_ids: t2.model_input_ids, attention_mask: new a.Tensor("int64", n2, [1, n2.length]), past_key_values: t2.prev_model_outputs?.past_key_values }, o2 = await e3.forward(r2);
        return t2.prev_model_outputs = o2, o2;
      }
      function N(e3, t2) {
        e3.output_token_ids = [...e3.output_token_ids, t2], e3.model_input_ids = new a.Tensor("int64", [BigInt(t2)], [1, 1]);
      }
      class B extends o.Callable {
        main_input_name = "input_ids";
        constructor(e3, t2) {
          super(), this.config = e3, this.session = t2;
          const n2 = y.get(this.constructor), r2 = w.get(n2);
          this.can_generate = false, this._runBeam = null, this._getStartBeams = null, this._updateBeam = null, this._forward = null, r2 === g ? (this.can_generate = true, this._runBeam = $, this._getStartBeams = L, this._updateBeam = N, this._forward = D) : r2 === f || r2 === m ? (this.can_generate = true, this._runBeam = E, this._getStartBeams = C, this._updateBeam = O, this._forward = F) : this._forward = I;
        }
        async dispose() {
          const e3 = [];
          for (let t2 of Object.keys(this)) {
            const n2 = this[t2];
            n2 instanceof u && e3.push(n2.handler.dispose());
          }
          return await Promise.all(e3);
        }
        static async from_pretrained(e3, { quantized: t2 = true, progress_callback: n2 = null, config: o2 = null, cache_dir: s2 = null, local_files_only: a2 = false, revision: l2 = "main", model_file_name: c2 = null } = {}) {
          let u2 = { quantized: t2, progress_callback: n2, config: o2, cache_dir: s2, local_files_only: a2, revision: l2, model_file_name: c2 };
          const p2 = y.get(this), d2 = w.get(p2);
          let x2;
          return d2 === g ? x2 = await Promise.all([r.AutoConfig.from_pretrained(e3, u2), T(e3, u2.model_file_name ?? "decoder_model_merged", u2), (0, i.getModelJSON)(e3, "generation_config.json", false, u2)]) : d2 === f || d2 === m ? x2 = await Promise.all([r.AutoConfig.from_pretrained(e3, u2), T(e3, "encoder_model", u2), T(e3, "decoder_model_merged", u2), (0, i.getModelJSON)(e3, "generation_config.json", false, u2)]) : d2 === b ? x2 = await Promise.all([r.AutoConfig.from_pretrained(e3, u2), T(e3, "vision_encoder", u2), T(e3, "prompt_encoder_mask_decoder", u2)]) : d2 === h ? x2 = await Promise.all([r.AutoConfig.from_pretrained(e3, u2), T(e3, "encoder_model", u2), T(e3, "decoder_model_merged", u2)]) : (d2 !== _ && console.warn(`Model type for '${p2 ?? o2?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`), x2 = await Promise.all([r.AutoConfig.from_pretrained(e3, u2), T(e3, u2.model_file_name ?? "model", u2)])), new this(...x2);
        }
        async _call(e3) {
          return await this.forward(e3);
        }
        async forward(e3) {
          return await this._forward(this, e3);
        }
        _get_logits_processor(e3, t2, n2 = null) {
          const r2 = new s.LogitsProcessorList();
          if (null !== e3.repetition_penalty && 1 !== e3.repetition_penalty && r2.push(new s.RepetitionPenaltyLogitsProcessor(e3.repetition_penalty)), null !== e3.no_repeat_ngram_size && e3.no_repeat_ngram_size > 0 && r2.push(new s.NoRepeatNGramLogitsProcessor(e3.no_repeat_ngram_size)), null !== e3.bad_words_ids && r2.push(new s.NoBadWordsLogitsProcessor(e3.bad_words_ids, e3.eos_token_id)), null !== e3.min_length && null !== e3.eos_token_id && e3.min_length > 0 && r2.push(new s.MinLengthLogitsProcessor(e3.min_length, e3.eos_token_id)), null !== e3.min_new_tokens && null !== e3.eos_token_id && e3.min_new_tokens > 0 && r2.push(new s.MinNewTokensLengthLogitsProcessor(t2, e3.min_new_tokens, e3.eos_token_id)), null !== e3.forced_bos_token_id && r2.push(new s.ForcedBOSTokenLogitsProcessor(e3.forced_bos_token_id)), null !== e3.forced_eos_token_id && r2.push(new s.ForcedEOSTokenLogitsProcessor(e3.max_length, e3.forced_eos_token_id)), null !== e3.begin_suppress_tokens) {
            let n3 = t2 > 1 || null === e3.forced_bos_token_id ? t2 : t2 + 1;
            null !== e3.forced_decoder_ids && (n3 += e3.forced_decoder_ids[e3.forced_decoder_ids.length - 1][0]), r2.push(new s.SuppressTokensAtBeginLogitsProcessor(e3.begin_suppress_tokens, n3));
          }
          return null !== e3.forced_decoder_ids && r2.push(new s.ForceTokensLogitsProcessor(e3.forced_decoder_ids)), null !== n2 && r2.extend(n2), r2;
        }
        _get_generation_config(e3) {
          let t2 = new s.GenerationConfig(this.config);
          return "generation_config" in this && Object.assign(t2, this.generation_config), null !== e3 && Object.assign(t2, e3), t2;
        }
        async generate(e3, t2 = null, n2 = null, { inputs_attention_mask: r2 = null } = {}) {
          if (!this.can_generate) {
            let e4 = `The current model class (${y.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;
            const t3 = this.config.model_type, n3 = Di.get(t3) ?? Ii.get(t3) ?? Ai.get(t3) ?? Ni.get(t3);
            throw n3 && (e4 += ` Please use the following class instead: '${n3[0]}'`), Error(e4);
          }
          if (!(e3 instanceof a.Tensor || (0, o.isTypedArray)(e3) || Array.isArray(e3))) throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${e3.constructor.name}".`);
          let i2;
          if (this.config.is_encoder_decoder) i2 = 0;
          else if (i2 = e3 instanceof a.Tensor ? e3.dims.at(-1) : e3.length, 0 === i2) throw Error("Must supply a non-empty array of input token ids.");
          t2 = this._get_generation_config(t2), n2 = n2 ?? new s.LogitsProcessorList(), n2 = this._get_logits_processor(t2, i2, n2);
          let l2 = t2.eos_token_id;
          null === l2 || Array.isArray(l2) || (l2 = [l2]);
          let c2 = 1;
          const u2 = c2 + (t2.max_new_tokens ?? 1 / 0), p2 = Number.isInteger(t2.max_length) && null === (t2.max_new_tokens ?? null);
          let d2 = s.Sampler.getSampler(t2), _2 = this.getStartBeams(e3, t2, c2, r2);
          for (; _2.some(((e4) => !e4.done)) && c2 < u2; ) {
            let e4 = [];
            for (let r3 of _2) {
              if (r3.done) {
                e4.push(r3);
                continue;
              }
              if (p2 && r3.output_token_ids.length >= t2.max_length) {
                r3.done = true, e4.push(r3);
                continue;
              }
              let o2 = await this.runBeam(r3);
              t2.output_attentions && this.addAttentionsToBeam(r3, o2), t2.output_scores;
              let i3 = o2.logits.slice(null, -1, null);
              n2(r3.output_token_ids, i3);
              let s2 = d2(i3);
              for (let [t3, n3] of s2) {
                let o3 = { ...r3 };
                this.updateBeam(o3, t3), o3.score += n3, l2 && l2.includes(t3) && (o3.done = true), e4.push(o3);
              }
            }
            ++c2, e4 = this.groupBeams(e4).map(((e5) => e5.sort(((e6, t3) => t3.score - e6.score)).slice(0, t2.num_beams))), _2 = e4.flat(), t2.callback_function && t2.callback_function(_2);
          }
          const h2 = this.groupBeams(_2), f2 = (e4) => h2.map(((n3) => t2.num_return_sequences > 1 ? n3.slice(0, t2.num_return_sequences).map(((t3) => t3[e4])) : [n3[0][e4]])).flat(), m2 = f2("output_token_ids");
          if (t2.return_dict_in_generate) {
            return { sequences: m2, decoder_attentions: f2("decoder_attentions"), cross_attentions: f2("cross_attentions") };
          }
          return m2;
        }
        addAttentionsToBeam(e3, t2) {
          if (this.config.is_encoder_decoder) {
            if (!t2.cross_attentions || 0 === t2.cross_attentions.length) throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");
            e3.cross_attentions || (e3.cross_attentions = []), e3.cross_attentions.push(t2.cross_attentions);
          }
          if (!t2.decoder_attentions || 0 === t2.decoder_attentions.length) throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");
          e3.decoder_attentions || (e3.decoder_attentions = []), e3.decoder_attentions.push(t2.decoder_attentions);
        }
        groupBeams(e3) {
          const t2 = /* @__PURE__ */ Object.create(null);
          for (const n2 of e3) void 0 === t2[n2.id] ? t2[n2.id] = [n2] : t2[n2.id].push(n2);
          return Object.values(t2);
        }
        getPastKeyValues(e3, t2) {
          const n2 = /* @__PURE__ */ Object.create(null);
          for (const r2 in e3) if (r2.startsWith("present")) {
            let o2 = r2.replace("present", "past_key_values");
            t2 && r2.includes("encoder") ? n2[o2] = t2[o2] : n2[o2] = e3[r2];
          }
          return n2;
        }
        getAttentions(e3) {
          const t2 = /* @__PURE__ */ Object.create(null);
          for (const n2 of ["cross_attentions", "decoder_attentions"]) {
            const r2 = [];
            for (const t3 in e3) if (t3.startsWith(n2)) {
              r2[t3.split(".").pop()] = e3[t3];
            }
            t2[n2] = r2;
          }
          return t2;
        }
        addPastKeyValues(e3, t2) {
          if (t2) Object.assign(e3, t2);
          else {
            const t3 = 1;
            if (this.config.is_encoder_decoder && (this.add_encoder_pkv ?? 1)) {
              let n2 = [t3, this.num_encoder_heads, 0, this.encoder_dim_kv], r2 = [t3, this.num_decoder_heads, 0, this.decoder_dim_kv];
              for (let t4 = 0; t4 < this.num_decoder_layers; ++t4) e3[`past_key_values.${t4}.encoder.key`] = new a.Tensor("float32", [], n2), e3[`past_key_values.${t4}.encoder.value`] = new a.Tensor("float32", [], n2), e3[`past_key_values.${t4}.decoder.key`] = new a.Tensor("float32", [], r2), e3[`past_key_values.${t4}.decoder.value`] = new a.Tensor("float32", [], r2);
            } else if ("falcon" === this.config.model_type) {
              let n2 = [t3 * this.num_heads, 0, this.dim_kv];
              for (let t4 = 0; t4 < this.num_layers; ++t4) e3[`past_key_values.${t4}.key`] = new a.Tensor("float32", [], n2), e3[`past_key_values.${t4}.value`] = new a.Tensor("float32", [], n2);
            } else if (this.config.multi_query) {
              let n2 = [t3 * this.num_heads, 0, 2 * this.dim_kv];
              for (let t4 = 0; t4 < this.num_layers; ++t4) e3[`past_key_values.${t4}.key_value`] = new a.Tensor("float32", [], n2);
            } else if ("bloom" === this.config.model_type) {
              let n2 = [t3 * this.num_heads, this.dim_kv, 0], r2 = [t3 * this.num_heads, 0, this.dim_kv];
              for (let t4 = 0; t4 < this.num_layers; ++t4) e3[`past_key_values.${t4}.key`] = new a.Tensor("float32", [], n2), e3[`past_key_values.${t4}.value`] = new a.Tensor("float32", [], r2);
            } else {
              let n2 = [t3, this.num_heads, 0, this.dim_kv];
              for (let t4 = 0; t4 < this.num_layers; ++t4) e3[`past_key_values.${t4}.key`] = new a.Tensor("float32", [], n2), e3[`past_key_values.${t4}.value`] = new a.Tensor("float32", [], n2);
            }
          }
        }
        getStartBeams(e3, t2, n2, r2) {
          return this._getStartBeams(this, e3, t2, n2, r2);
        }
        async runBeam(e3) {
          return await this._runBeam(this, e3);
        }
        updateBeam(e3, t2) {
          return this._updateBeam(e3, t2);
        }
      }
      class z {
      }
      class R extends z {
        constructor({ last_hidden_state: e3, hidden_states: t2 = null, attentions: n2 = null }) {
          super(), this.last_hidden_state = e3, this.hidden_states = t2, this.attentions = n2;
        }
      }
      class j extends B {
      }
      class V extends j {
      }
      class U extends j {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class G extends j {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class q extends j {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class W extends j {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class H extends B {
      }
      class X extends H {
      }
      class Q extends B {
      }
      class Y extends Q {
      }
      class K extends Q {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Z extends Q {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class J extends Q {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class ee extends Q {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class te extends B {
      }
      class ne extends te {
      }
      class re extends te {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class oe extends te {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class ie extends te {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class se extends te {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class ae extends B {
      }
      class le extends ae {
      }
      class ce extends ae {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class ue extends ae {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class pe extends ae {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class de extends ae {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class _e extends B {
      }
      class he extends _e {
      }
      class fe extends _e {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class me extends _e {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class ge extends _e {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class be extends _e {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class we extends B {
      }
      class xe extends we {
      }
      class ye extends we {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Te extends we {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class ve extends we {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class ke extends we {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class Me extends B {
      }
      class Se extends Me {
      }
      class Pe extends Me {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Ae extends Me {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Fe extends Me {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Ce extends Me {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class Ee extends B {
      }
      class Oe extends Ee {
      }
      class Ie extends Ee {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class De extends Ee {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Le extends Ee {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class $e extends Ee {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Ne extends B {
      }
      class Be extends Ne {
      }
      class ze extends Ne {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Re extends Ne {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class je extends Ne {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Ve extends B {
      }
      class Ue extends Ve {
      }
      class Ge extends Ve {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class qe extends Ve {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class We extends Ve {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class He extends B {
      }
      class Xe extends He {
      }
      class Qe extends He {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Ye extends He {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Ke extends He {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Ze extends He {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class Je extends B {
      }
      class et extends Je {
      }
      class tt extends Je {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class nt extends Je {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class rt extends Je {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class ot extends B {
      }
      class it extends ot {
      }
      class st extends ot {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class at extends ot {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class lt extends ot {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class ct extends B {
      }
      class ut extends ct {
      }
      class pt extends ct {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.num_decoder_layers, this.num_decoder_heads = this.config.num_heads, this.decoder_dim_kv = this.config.d_kv, this.num_encoder_layers = this.config.num_layers, this.num_encoder_heads = this.config.num_heads, this.encoder_dim_kv = this.config.d_kv;
        }
      }
      class dt extends B {
      }
      class _t extends dt {
      }
      class ht extends dt {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.num_decoder_layers, this.num_decoder_heads = this.config.num_heads, this.decoder_dim_kv = this.config.d_kv, this.num_encoder_layers = this.config.num_layers, this.num_encoder_heads = this.config.num_heads, this.encoder_dim_kv = this.config.d_kv;
        }
      }
      class ft extends B {
      }
      class mt extends ft {
      }
      class gt extends ft {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.num_decoder_layers, this.num_decoder_heads = this.config.num_heads, this.decoder_dim_kv = this.config.d_kv, this.num_encoder_layers = this.config.num_layers, this.num_encoder_heads = this.config.num_heads, this.encoder_dim_kv = this.config.d_kv;
        }
      }
      class bt extends B {
      }
      class wt extends bt {
      }
      class xt extends bt {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
      }
      class yt extends bt {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Tt extends B {
      }
      class vt extends Tt {
      }
      class kt extends Tt {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
      }
      class Mt extends Tt {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class St extends Tt {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
      }
      class Pt extends B {
      }
      class At extends Pt {
      }
      class Ft extends Pt {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
      }
      class Ct extends B {
      }
      class Et extends Ct {
      }
      class Ot extends Ct {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
      }
      class It extends B {
      }
      class Dt extends It {
      }
      class Lt extends It {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class $t extends It {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Nt extends It {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Bt extends It {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class zt extends B {
      }
      class Rt extends zt {
      }
      class jt extends zt {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Vt extends zt {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Ut extends zt {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Gt extends zt {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class qt extends B {
      }
      class Wt extends qt {
      }
      class Ht extends qt {
        async _call(e3) {
          return new Es(await super._call(e3));
        }
      }
      class Xt extends qt {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Qt extends qt {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Yt extends qt {
        async _call(e3) {
          return new Os(await super._call(e3));
        }
      }
      class Kt extends B {
      }
      class Zt extends Kt {
      }
      class Jt extends Kt {
      }
      class en extends B {
      }
      class tn extends en {
      }
      class nn extends en {
        requires_attention_mask = false;
        main_input_name = "input_features";
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
        async generate(e3, t2 = null, n2 = null) {
          if (t2 = this._get_generation_config(t2), t2.return_timestamps ??= false, t2.return_timestamps && (n2 = [new s.WhisperTimeStampLogitsProcessor(t2)]), t2.return_token_timestamps && (t2.output_attentions = true, t2.return_dict_in_generate = true, "translate" === t2.task && console.warn("Token-level timestamps may not be reliable for task 'translate'."), !t2.alignment_heads)) throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");
          const r2 = await super.generate(e3, t2, n2);
          return t2.return_token_timestamps && t2.alignment_heads && (r2.token_timestamps = this._extract_token_timestamps(r2, t2.alignment_heads, t2.num_frames)), r2;
        }
        _extract_token_timestamps(e3, t2, n2 = null, r2 = 0.02) {
          if (!e3.cross_attentions) throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");
          let i2 = this.config.median_filter_width;
          void 0 === i2 && (console.warn("Model config has no `median_filter_width`, using default value of 7."), i2 = 7);
          const s2 = e3.cross_attentions.map(((e4) => {
            let r3 = Array.from({ length: this.config.decoder_layers }, ((t3, n3) => (0, a.cat)(e4.map(((e5) => e5[n3])), 2))), o2 = (0, a.stack)(t2.map((([e5, t3]) => n2 ? r3[e5].slice(null, t3, null, [0, n2]) : r3[e5].slice(null, t3))));
            o2 = o2.transpose(1, 0, 2, 3);
            let [s3, l3] = (0, a.std_mean)(o2, -2, 0, true), u3 = o2.clone();
            for (let e5 = 0; e5 < u3.dims[0]; ++e5) {
              let t3 = u3[e5];
              for (let n3 = 0; n3 < t3.dims[0]; ++n3) {
                let r4 = t3[n3];
                const o3 = s3[e5][n3][0], a2 = l3[e5][n3][0];
                for (let e6 = 0; e6 < r4.dims[0]; ++e6) {
                  let t4 = r4[e6];
                  for (let e7 = 0; e7 < t4.data.length; ++e7) t4.data[e7] = (t4.data[e7] - a2.data[e7]) / o3.data[e7];
                  t4.data.set((0, c.medianFilter)(t4.data, i2));
                }
              }
            }
            return (0, a.mean)(u3, 1);
          })), l2 = [e3.sequences.length, e3.sequences[0].length], u2 = new a.Tensor("float32", new Float32Array(l2[0] * l2[1]), l2);
          for (let e4 = 0; e4 < l2[0]; ++e4) {
            const t3 = s2[e4].neg().squeeze_(0);
            let [n3, i3] = (0, a.dynamicTimeWarping)(t3), l3 = Array.from({ length: n3.length - 1 }, ((e5, t4) => n3[t4 + 1] - n3[t4])), c2 = (0, o.mergeArrays)([1], l3).map(((e5) => !!e5)), p2 = [];
            for (let e5 = 0; e5 < c2.length; ++e5) c2[e5] && p2.push(i3[e5] * r2);
            u2[e4].data.set(p2, 1);
          }
          return u2;
        }
      }
      class rn extends B {
        main_input_name = "pixel_values";
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2;
          const o2 = this.config.encoder, i2 = this.config.decoder, s2 = o2.model_type;
          (Mi.get(s2) ?? Si.get(s2)) || console.warn(`Model type for encoder '${s2}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);
          const a2 = Di.get(i2.model_type);
          if (!a2) throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);
          const l2 = new (0, a2[1])(i2, n2, r2);
          this.add_encoder_pkv = "num_decoder_layers" in l2, this.add_encoder_pkv ? (this.num_decoder_layers = l2.num_decoder_layers, this.num_decoder_heads = l2.num_decoder_heads, this.decoder_dim_kv = l2.decoder_dim_kv, this.num_encoder_layers = l2.num_encoder_layers, this.num_encoder_heads = l2.num_encoder_heads, this.encoder_dim_kv = l2.encoder_dim_kv) : (this.num_layers = l2.num_layers, this.num_heads = l2.num_heads, this.dim_kv = l2.dim_kv);
        }
      }
      class on extends B {
      }
      class sn extends on {
      }
      class an extends on {
        static async from_pretrained(e3, t2 = {}) {
          return t2.model_file_name ??= "text_model", super.from_pretrained(e3, t2);
        }
      }
      class ln extends on {
        static async from_pretrained(e3, t2 = {}) {
          return t2.model_file_name ??= "vision_model", super.from_pretrained(e3, t2);
        }
      }
      class cn extends B {
      }
      class un extends cn {
      }
      class pn extends cn {
        static async from_pretrained(e3, t2 = {}) {
          return t2.model_file_name ??= "text_model", super.from_pretrained(e3, t2);
        }
      }
      class dn extends on {
        static async from_pretrained(e3, t2 = {}) {
          return t2.model_file_name ??= "vision_model", super.from_pretrained(e3, t2);
        }
      }
      class _n extends B {
      }
      class hn extends _n {
      }
      class fn extends B {
      }
      class mn extends fn {
      }
      class gn extends fn {
      }
      class bn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.n_head, this.num_layers = this.config.n_layer, this.dim_kv = this.config.n_embd / this.num_heads;
        }
      }
      class wn extends bn {
      }
      class xn extends bn {
      }
      class yn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_heads, this.num_layers = this.config.num_layers, this.dim_kv = this.config.hidden_size / this.num_heads;
        }
      }
      class Tn extends yn {
      }
      class vn extends yn {
      }
      class kn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_attention_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.num_heads;
        }
      }
      class Mn extends kn {
      }
      class Sn extends kn {
      }
      class Pn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.n_head, this.num_layers = this.config.n_layer, this.dim_kv = this.config.n_embd / this.num_heads;
        }
      }
      class An extends Pn {
      }
      class Fn extends Pn {
      }
      class Cn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.n_head, this.num_layers = this.config.n_layer, this.dim_kv = this.config.n_embd / this.num_heads;
        }
      }
      class En extends Cn {
      }
      class On extends Cn {
      }
      class In extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.n_head, this.num_layers = this.config.n_layer, this.dim_kv = this.config.n_embd / this.num_heads;
        }
      }
      class Dn extends In {
      }
      class Ln extends In {
      }
      class $n extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_key_value_heads ?? this.config.num_attention_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
        }
      }
      class Nn extends $n {
      }
      class Bn extends $n {
      }
      class zn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_key_value_heads ?? this.config.num_attention_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
        }
      }
      class Rn extends zn {
      }
      class jn extends zn {
      }
      class Vn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_attention_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.num_heads;
        }
      }
      class Un extends Vn {
      }
      class Gn extends Vn {
      }
      class qn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.n_head, this.num_layers = this.config.n_layer, this.dim_kv = this.config.hidden_size / this.num_heads;
        }
      }
      class Wn extends qn {
      }
      class Hn extends qn {
      }
      class Xn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.n_heads, this.num_layers = this.config.n_layers, this.dim_kv = this.config.d_model / this.num_heads;
        }
      }
      class Qn extends Xn {
      }
      class Yn extends Xn {
      }
      class Kn extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_attention_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.num_heads;
        }
      }
      class Zn extends Kn {
      }
      class Jn extends Kn {
      }
      class er extends B {
      }
      class tr extends er {
      }
      class nr extends er {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class rr extends B {
      }
      class or extends rr {
        async _call(e3) {
          return new Ls(await super._call(e3));
        }
      }
      class ir extends B {
      }
      class sr extends ir {
      }
      class ar extends ir {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class lr extends B {
      }
      class cr extends lr {
      }
      class ur extends lr {
      }
      class pr extends B {
      }
      class dr extends pr {
      }
      class _r extends pr {
      }
      class hr extends B {
      }
      class fr extends hr {
      }
      class mr extends hr {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class gr extends B {
      }
      class br extends gr {
      }
      class wr extends gr {
        async _call(e3) {
          return new yr(await super._call(e3));
        }
      }
      class xr extends gr {
        async _call(e3) {
          return new Tr(await super._call(e3));
        }
      }
      class yr extends z {
        constructor({ logits: e3, pred_boxes: t2 }) {
          super(), this.logits = e3, this.pred_boxes = t2;
        }
      }
      class Tr extends z {
        constructor({ logits: e3, pred_boxes: t2, pred_masks: n2 }) {
          super(), this.logits = e3, this.pred_boxes = t2, this.pred_masks = n2;
        }
      }
      class vr extends B {
      }
      class kr extends vr {
      }
      class Mr extends vr {
        async _call(e3) {
          return new Sr(await super._call(e3));
        }
      }
      class Sr extends yr {
      }
      class Pr extends B {
      }
      class Ar extends Pr {
      }
      class Fr extends Pr {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Cr extends B {
      }
      class Er extends Cr {
      }
      class Or extends Cr {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Ir extends B {
      }
      class Dr extends Ir {
      }
      class Lr extends Ir {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class $r extends B {
      }
      class Nr extends $r {
      }
      class Br extends $r {
      }
      class zr extends B {
      }
      class Rr extends zr {
      }
      class jr extends zr {
      }
      class Vr extends B {
      }
      class Ur extends Vr {
      }
      class Gr extends B {
      }
      class qr extends Gr {
      }
      class Wr extends Gr {
      }
      class Hr extends B {
      }
      class Xr extends Hr {
      }
      class Qr extends B {
      }
      class Yr extends Qr {
      }
      class Kr extends Qr {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Zr extends B {
      }
      class Jr extends Zr {
      }
      class eo extends Zr {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class to extends B {
      }
      class no extends to {
      }
      class ro extends to {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class oo extends B {
      }
      class io extends oo {
      }
      class so extends oo {
        async _call(e3) {
          return new ao(await super._call(e3));
        }
      }
      class ao extends z {
        constructor({ logits: e3, pred_boxes: t2 }) {
          super(), this.logits = e3, this.pred_boxes = t2;
        }
      }
      class lo extends B {
      }
      class co extends lo {
        constructor(e3, t2, n2) {
          super(e3, t2), this.prompt_encoder_mask_decoder = n2;
        }
        async get_image_embeddings({ pixel_values: e3 }) {
          return await I(this, { pixel_values: e3 });
        }
        async forward(e3) {
          if (e3.image_embeddings && e3.image_positional_embeddings || (e3 = { ...e3, ...await this.get_image_embeddings(e3) }), !e3.input_labels) {
            const t2 = e3.input_points.dims.slice(0, -1), n2 = t2.reduce(((e4, t3) => e4 * t3), 1);
            e3.input_labels = new a.Tensor("int64", new BigInt64Array(n2).fill(1n), t2);
          }
          return await v(this.prompt_encoder_mask_decoder, { input_points: e3.input_points, input_labels: e3.input_labels, image_embeddings: e3.image_embeddings, image_positional_embeddings: e3.image_positional_embeddings });
        }
        async _call(e3) {
          return new uo(await super._call(e3));
        }
      }
      class uo extends z {
        constructor({ iou_scores: e3, pred_masks: t2 }) {
          super(), this.iou_scores = e3, this.pred_masks = t2;
        }
      }
      class po extends B {
      }
      class _o extends po {
      }
      class ho extends po {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
      }
      class fo extends B {
      }
      class mo extends fo {
      }
      class go extends fo {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
      }
      class bo extends B {
      }
      class wo extends bo {
      }
      class xo extends bo {
        async _call(e3) {
          return new Is(await super._call(e3));
        }
      }
      class yo extends bo {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class To extends bo {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class vo extends B {
      }
      class ko extends vo {
      }
      class Mo extends vo {
        async _call(e3) {
          return new Is(await super._call(e3));
        }
      }
      class So extends vo {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Po extends B {
      }
      class Ao extends Po {
      }
      class Fo extends Po {
        async _call(e3) {
          return new Is(await super._call(e3));
        }
      }
      class Co extends Po {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Eo extends Po {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Oo extends B {
      }
      class Io extends Oo {
      }
      class Do extends Oo {
        async _call(e3) {
          return new Is(await super._call(e3));
        }
      }
      class Lo extends Oo {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class $o extends B {
      }
      class No extends bo {
      }
      class Bo extends bo {
        async _call(e3) {
          return new Is(await super._call(e3));
        }
      }
      class zo extends bo {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Ro extends B {
      }
      class jo extends Ro {
      }
      class Vo extends Ro {
        async _call(e3) {
          return new Is(await super._call(e3));
        }
      }
      class Uo extends Ro {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class Go extends Ro {
        async _call(e3) {
          return new Fs(await super._call(e3));
        }
      }
      class qo extends Ro {
        async _call(e3) {
          return new Cs(await super._call(e3));
        }
      }
      class Wo extends B {
      }
      class Ho extends Wo {
      }
      class Xo extends Wo {
      }
      class Qo extends Wo {
        constructor(e3, t2, n2, r2) {
          super(e3, t2), this.decoder_merged_session = n2, this.generation_config = r2, this.num_decoder_layers = this.config.decoder_layers, this.num_decoder_heads = this.config.decoder_attention_heads, this.decoder_dim_kv = this.config.hidden_size / this.num_decoder_heads, this.num_encoder_layers = this.config.encoder_layers, this.num_encoder_heads = this.config.encoder_attention_heads, this.encoder_dim_kv = this.config.hidden_size / this.num_encoder_heads;
        }
        async generate_speech(e3, t2, { threshold: n2 = 0.5, minlenratio: r2 = 0, maxlenratio: o2 = 20, vocoder: i2 = null } = {}) {
          const s2 = { input_ids: e3 }, { encoder_outputs: l2, encoder_attention_mask: c2 } = await I(this, s2), u2 = l2.dims[1] / this.config.reduction_factor, p2 = Math.floor(u2 * o2), d2 = Math.floor(u2 * r2), _2 = this.config.num_mel_bins;
          let h2 = [], f2 = null, m2 = null, g2 = 0;
          for (; ; ) {
            ++g2;
            const e4 = A(!!m2);
            let r3;
            r3 = m2 ? m2.output_sequence_out : new a.Tensor("float32", new Float32Array(_2), [1, 1, _2]);
            let o3 = { use_cache_branch: e4, output_sequence: r3, encoder_attention_mask: c2, speaker_embeddings: t2, encoder_hidden_states: l2 };
            this.addPastKeyValues(o3, f2), m2 = await v(this.decoder_merged_session, o3), f2 = this.getPastKeyValues(m2, f2);
            const { prob: i3, spectrum: s3 } = m2;
            if (h2.push(s3), g2 >= d2 && (Array.from(i3.data).filter(((e5) => e5 >= n2)).length > 0 || g2 >= p2)) break;
          }
          const b2 = (0, a.cat)(h2), { waveform: w2 } = await v(i2.session, { spectrogram: b2 });
          return { spectrogram: b2, waveform: w2 };
        }
      }
      class Yo extends B {
        main_input_name = "spectrogram";
      }
      class Ko extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_encoder_layers = this.num_decoder_layers = this.config.decoder_layers, this.num_encoder_heads = this.num_decoder_heads = this.config.decoder_attention_heads, this.encoder_dim_kv = this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
        }
      }
      class Zo extends Ko {
      }
      class Jo extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_key_value_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
        }
      }
      class ei extends Jo {
      }
      class ti extends Jo {
      }
      class ni extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_key_value_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
        }
      }
      class ri extends ni {
      }
      class oi extends ni {
      }
      class ii extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_attention_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
        }
      }
      class si extends ii {
      }
      class ai extends ii {
      }
      class li extends B {
      }
      class ci extends li {
      }
      class ui extends li {
        static async from_pretrained(e3, t2 = {}) {
          return t2.model_file_name ??= "text_model", super.from_pretrained(e3, t2);
        }
      }
      class pi extends li {
        static async from_pretrained(e3, t2 = {}) {
          return t2.model_file_name ??= "audio_model", super.from_pretrained(e3, t2);
        }
      }
      class di extends B {
      }
      class _i extends di {
        async _call(e3) {
          return new $s(await super._call(e3));
        }
      }
      class hi extends B {
      }
      class fi extends hi {
      }
      class mi extends hi {
      }
      class gi extends hi {
      }
      class bi extends B {
        constructor(e3, t2, n2) {
          super(e3, t2), this.generation_config = n2, this.config.pad_token_id = this.config.eos_token_id, this.num_heads = this.config.num_attention_heads, this.num_layers = this.config.num_hidden_layers, this.dim_kv = this.config.hidden_size / this.num_heads;
        }
      }
      class wi extends bi {
      }
      class xi extends bi {
      }
      class yi extends B {
      }
      class Ti extends yi {
      }
      class vi extends yi {
        async _call(e3) {
          return new As(await super._call(e3));
        }
      }
      class ki {
        static MODEL_CLASS_MAPPINGS = null;
        static BASE_IF_FAIL = false;
        static async from_pretrained(e3, { quantized: t2 = true, progress_callback: n2 = null, config: o2 = null, cache_dir: i2 = null, local_files_only: s2 = false, revision: a2 = "main", model_file_name: l2 = null } = {}) {
          let c2 = { quantized: t2, progress_callback: n2, config: o2, cache_dir: i2, local_files_only: s2, revision: a2, model_file_name: l2 };
          if (o2 = await r.AutoConfig.from_pretrained(e3, c2), c2.config || (c2.config = o2), !this.MODEL_CLASS_MAPPINGS) throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: " + this.name);
          for (let t3 of this.MODEL_CLASS_MAPPINGS) {
            const n3 = t3.get(o2.model_type);
            if (n3) return await n3[1].from_pretrained(e3, c2);
          }
          if (this.BASE_IF_FAIL) return console.warn(`Unknown model class "${o2.model_type}", attempting to construct from base class.`), await B.from_pretrained(e3, c2);
          throw Error(`Unsupported model type: ${o2.model_type}`);
        }
      }
      const Mi = /* @__PURE__ */ new Map([["bert", ["BertModel", V]], ["nomic_bert", ["NomicBertModel", X]], ["roformer", ["RoFormerModel", Y]], ["electra", ["ElectraModel", le]], ["esm", ["EsmModel", Be]], ["convbert", ["ConvBertModel", ne]], ["camembert", ["CamembertModel", he]], ["deberta", ["DebertaModel", xe]], ["deberta-v2", ["DebertaV2Model", Se]], ["mpnet", ["MPNetModel", Xe]], ["albert", ["AlbertModel", it]], ["distilbert", ["DistilBertModel", Oe]], ["roberta", ["RobertaModel", Dt]], ["xlm", ["XLMModel", Rt]], ["xlm-roberta", ["XLMRobertaModel", Wt]], ["clap", ["ClapModel", ci]], ["clip", ["CLIPModel", sn]], ["clipseg", ["CLIPSegModel", mn]], ["chinese_clip", ["ChineseCLIPModel", hn]], ["siglip", ["SiglipModel", un]], ["mobilebert", ["MobileBertModel", Ue]], ["squeezebert", ["SqueezeBertModel", et]], ["wav2vec2", ["Wav2Vec2Model", wo]], ["wav2vec2-bert", ["Wav2Vec2BertModel", Io]], ["unispeech", ["UniSpeechModel", ko]], ["unispeech-sat", ["UniSpeechSatModel", Ao]], ["hubert", ["HubertModel", No]], ["wavlm", ["WavLMModel", jo]], ["audio-spectrogram-transformer", ["ASTModel", Zt]], ["vits", ["VitsModel", _i]], ["detr", ["DetrModel", br]], ["table-transformer", ["TableTransformerModel", kr]], ["vit", ["ViTModel", tr]], ["mobilevit", ["MobileViTModel", sr]], ["owlvit", ["OwlViTModel", cr]], ["owlv2", ["Owlv2Model", dr]], ["beit", ["BeitModel", fr]], ["deit", ["DeiTModel", Ar]], ["convnext", ["ConvNextModel", Yr]], ["convnextv2", ["ConvNextV2Model", Jr]], ["dinov2", ["Dinov2Model", no]], ["resnet", ["ResNetModel", Er]], ["swin", ["SwinModel", Dr]], ["swin2sr", ["Swin2SRModel", Nr]], ["donut-swin", ["DonutSwinModel", Xr]], ["yolos", ["YolosModel", io]], ["dpt", ["DPTModel", Rr]], ["glpn", ["GLPNModel", qr]], ["hifigan", ["SpeechT5HifiGan", Yo]], ["efficientnet", ["EfficientNetModel", Ti]]]), Si = /* @__PURE__ */ new Map([["t5", ["T5Model", ut]], ["longt5", ["LongT5Model", _t]], ["mt5", ["MT5Model", mt]], ["bart", ["BartModel", wt]], ["mbart", ["MBartModel", vt]], ["marian", ["MarianModel", _o]], ["whisper", ["WhisperModel", tn]], ["m2m_100", ["M2M100Model", mo]], ["blenderbot", ["BlenderbotModel", At]], ["blenderbot-small", ["BlenderbotSmallModel", Et]]]), Pi = /* @__PURE__ */ new Map([["bloom", ["BloomModel", Wn]], ["gpt2", ["GPT2Model", wn]], ["gptj", ["GPTJModel", An]], ["gpt_bigcode", ["GPTBigCodeModel", En]], ["gpt_neo", ["GPTNeoModel", Tn]], ["gpt_neox", ["GPTNeoXModel", Mn]], ["codegen", ["CodeGenModel", Dn]], ["llama", ["LlamaModel", Nn]], ["qwen2", ["Qwen2Model", Rn]], ["phi", ["PhiModel", Un]], ["mpt", ["MptModel", Qn]], ["opt", ["OPTModel", Zn]], ["mistral", ["MistralModel", ei]], ["starcoder2", ["Starcoder2Model", ri]], ["falcon", ["FalconModel", si]]]), Ai = /* @__PURE__ */ new Map([["speecht5", ["SpeechT5ForSpeechToText", Xo]], ["whisper", ["WhisperForConditionalGeneration", nn]]]), Fi = /* @__PURE__ */ new Map([["speecht5", ["SpeechT5ForTextToSpeech", Qo]]]), Ci = /* @__PURE__ */ new Map([["vits", ["VitsModel", _i]]]), Ei = /* @__PURE__ */ new Map([["bert", ["BertForSequenceClassification", G]], ["roformer", ["RoFormerForSequenceClassification", Z]], ["electra", ["ElectraForSequenceClassification", ue]], ["esm", ["EsmForSequenceClassification", Re]], ["convbert", ["ConvBertForSequenceClassification", oe]], ["camembert", ["CamembertForSequenceClassification", me]], ["deberta", ["DebertaForSequenceClassification", Te]], ["deberta-v2", ["DebertaV2ForSequenceClassification", Ae]], ["mpnet", ["MPNetForSequenceClassification", Ye]], ["albert", ["AlbertForSequenceClassification", st]], ["distilbert", ["DistilBertForSequenceClassification", Ie]], ["roberta", ["RobertaForSequenceClassification", $t]], ["xlm", ["XLMForSequenceClassification", Vt]], ["xlm-roberta", ["XLMRobertaForSequenceClassification", Xt]], ["bart", ["BartForSequenceClassification", yt]], ["mbart", ["MBartForSequenceClassification", Mt]], ["mobilebert", ["MobileBertForSequenceClassification", qe]], ["squeezebert", ["SqueezeBertForSequenceClassification", nt]]]), Oi = /* @__PURE__ */ new Map([["bert", ["BertForTokenClassification", q]], ["roformer", ["RoFormerForTokenClassification", J]], ["electra", ["ElectraForTokenClassification", pe]], ["esm", ["EsmForTokenClassification", je]], ["convbert", ["ConvBertForTokenClassification", ie]], ["camembert", ["CamembertForTokenClassification", ge]], ["deberta", ["DebertaForTokenClassification", ve]], ["deberta-v2", ["DebertaV2ForTokenClassification", Fe]], ["mpnet", ["MPNetForTokenClassification", Ke]], ["distilbert", ["DistilBertForTokenClassification", De]], ["roberta", ["RobertaForTokenClassification", Nt]], ["xlm", ["XLMForTokenClassification", Ut]], ["xlm-roberta", ["XLMRobertaForTokenClassification", Qt]]]), Ii = /* @__PURE__ */ new Map([["t5", ["T5ForConditionalGeneration", pt]], ["longt5", ["LongT5ForConditionalGeneration", ht]], ["mt5", ["MT5ForConditionalGeneration", gt]], ["bart", ["BartForConditionalGeneration", xt]], ["mbart", ["MBartForConditionalGeneration", kt]], ["marian", ["MarianMTModel", ho]], ["m2m_100", ["M2M100ForConditionalGeneration", go]], ["blenderbot", ["BlenderbotForConditionalGeneration", Ft]], ["blenderbot-small", ["BlenderbotSmallForConditionalGeneration", Ot]]]), Di = /* @__PURE__ */ new Map([["bloom", ["BloomForCausalLM", Hn]], ["gpt2", ["GPT2LMHeadModel", xn]], ["gptj", ["GPTJForCausalLM", Fn]], ["gpt_bigcode", ["GPTBigCodeForCausalLM", On]], ["gpt_neo", ["GPTNeoForCausalLM", vn]], ["gpt_neox", ["GPTNeoXForCausalLM", Sn]], ["codegen", ["CodeGenForCausalLM", Ln]], ["llama", ["LlamaForCausalLM", Bn]], ["qwen2", ["Qwen2ForCausalLM", jn]], ["phi", ["PhiForCausalLM", Gn]], ["mpt", ["MptForCausalLM", Yn]], ["opt", ["OPTForCausalLM", Jn]], ["mbart", ["MBartForCausalLM", St]], ["mistral", ["MistralForCausalLM", ti]], ["starcoder2", ["Starcoder2ForCausalLM", oi]], ["falcon", ["FalconForCausalLM", ai]], ["trocr", ["TrOCRForCausalLM", Zo]], ["stablelm", ["StableLmForCausalLM", xi]]]), Li = /* @__PURE__ */ new Map([["bert", ["BertForMaskedLM", U]], ["roformer", ["RoFormerForMaskedLM", K]], ["electra", ["ElectraForMaskedLM", ce]], ["esm", ["EsmForMaskedLM", ze]], ["convbert", ["ConvBertForMaskedLM", re]], ["camembert", ["CamembertForMaskedLM", fe]], ["deberta", ["DebertaForMaskedLM", ye]], ["deberta-v2", ["DebertaV2ForMaskedLM", Pe]], ["mpnet", ["MPNetForMaskedLM", Qe]], ["albert", ["AlbertForMaskedLM", lt]], ["distilbert", ["DistilBertForMaskedLM", $e]], ["roberta", ["RobertaForMaskedLM", Lt]], ["xlm", ["XLMWithLMHeadModel", jt]], ["xlm-roberta", ["XLMRobertaForMaskedLM", Ht]], ["mobilebert", ["MobileBertForMaskedLM", Ge]], ["squeezebert", ["SqueezeBertForMaskedLM", tt]]]), $i = /* @__PURE__ */ new Map([["bert", ["BertForQuestionAnswering", W]], ["roformer", ["RoFormerForQuestionAnswering", ee]], ["electra", ["ElectraForQuestionAnswering", de]], ["convbert", ["ConvBertForQuestionAnswering", se]], ["camembert", ["CamembertForQuestionAnswering", be]], ["deberta", ["DebertaForQuestionAnswering", ke]], ["deberta-v2", ["DebertaV2ForQuestionAnswering", Ce]], ["mpnet", ["MPNetForQuestionAnswering", Ze]], ["albert", ["AlbertForQuestionAnswering", at]], ["distilbert", ["DistilBertForQuestionAnswering", Le]], ["roberta", ["RobertaForQuestionAnswering", Bt]], ["xlm", ["XLMForQuestionAnswering", Gt]], ["xlm-roberta", ["XLMRobertaForQuestionAnswering", Yt]], ["mobilebert", ["MobileBertForQuestionAnswering", We]], ["squeezebert", ["SqueezeBertForQuestionAnswering", rt]]]), Ni = /* @__PURE__ */ new Map([["vision-encoder-decoder", ["VisionEncoderDecoderModel", rn]]]), Bi = /* @__PURE__ */ new Map([["vision-encoder-decoder", ["VisionEncoderDecoderModel", rn]]]), zi = /* @__PURE__ */ new Map([["vit", ["ViTForImageClassification", nr]], ["mobilevit", ["MobileViTForImageClassification", ar]], ["beit", ["BeitForImageClassification", mr]], ["deit", ["DeiTForImageClassification", Fr]], ["convnext", ["ConvNextForImageClassification", Kr]], ["convnextv2", ["ConvNextV2ForImageClassification", eo]], ["dinov2", ["Dinov2ForImageClassification", ro]], ["resnet", ["ResNetForImageClassification", Or]], ["swin", ["SwinForImageClassification", Lr]], ["segformer", ["SegformerForImageClassification", mi]], ["efficientnet", ["EfficientNetForImageClassification", vi]]]), Ri = /* @__PURE__ */ new Map([["detr", ["DetrForObjectDetection", wr]], ["table-transformer", ["TableTransformerForObjectDetection", Mr]], ["yolos", ["YolosForObjectDetection", so]]]), ji = /* @__PURE__ */ new Map([["owlvit", ["OwlViTForObjectDetection", ur]], ["owlv2", ["Owlv2ForObjectDetection", _r]]]), Vi = /* @__PURE__ */ new Map([["detr", ["DetrForSegmentation", xr]], ["clipseg", ["CLIPSegForImageSegmentation", gn]]]), Ui = /* @__PURE__ */ new Map([["segformer", ["SegformerForSemanticSegmentation", gi]]]), Gi = /* @__PURE__ */ new Map([["sam", ["SamModel", co]]]), qi = /* @__PURE__ */ new Map([["wav2vec2", ["Wav2Vec2ForCTC", xo]], ["wav2vec2-bert", ["Wav2Vec2BertForCTC", Do]], ["unispeech", ["UniSpeechForCTC", Mo]], ["unispeech-sat", ["UniSpeechSatForCTC", Fo]], ["wavlm", ["WavLMForCTC", Vo]], ["hubert", ["HubertForCTC", Bo]]]), Wi = /* @__PURE__ */ new Map([["wav2vec2", ["Wav2Vec2ForSequenceClassification", yo]], ["wav2vec2-bert", ["Wav2Vec2BertForSequenceClassification", Lo]], ["unispeech", ["UniSpeechForSequenceClassification", So]], ["unispeech-sat", ["UniSpeechSatForSequenceClassification", Co]], ["wavlm", ["WavLMForSequenceClassification", Uo]], ["hubert", ["HubertForSequenceClassification", zo]], ["audio-spectrogram-transformer", ["ASTForAudioClassification", Jt]]]), Hi = /* @__PURE__ */ new Map([["wavlm", ["WavLMForXVector", Go]]]), Xi = /* @__PURE__ */ new Map([["unispeech-sat", ["UniSpeechSatForAudioFrameClassification", Eo]], ["wavlm", ["WavLMForAudioFrameClassification", qo]], ["wav2vec2", ["Wav2Vec2ForAudioFrameClassification", To]]]), Qi = /* @__PURE__ */ new Map([["vitmatte", ["VitMatteForImageMatting", or]]]), Yi = /* @__PURE__ */ new Map([["swin2sr", ["Swin2SRForImageSuperResolution", Br]]]), Ki = /* @__PURE__ */ new Map([["dpt", ["DPTForDepthEstimation", jr]], ["depth_anything", ["DepthAnythingForDepthEstimation", Ur]], ["glpn", ["GLPNForDepthEstimation", Wr]]]), Zi = /* @__PURE__ */ new Map([["clip", ["CLIPVisionModelWithProjection", ln]], ["siglip", ["SiglipVisionModel", dn]]]), Ji = [[Mi, _], [Si, h], [Pi, g], [Ei, _], [Oi, _], [Ii, f], [Ai, f], [Di, g], [Li, _], [$i, _], [Ni, m], [zi, _], [Vi, _], [Ui, _], [Qi, _], [Yi, _], [Ki, _], [Ri, _], [ji, _], [Gi, b], [qi, _], [Wi, _], [Fi, f], [Ci, _], [Hi, _], [Xi, _], [Zi, _]];
      for (const [e3, t2] of Ji) for (const [n2, r2] of e3.values()) w.set(n2, t2), y.set(r2, n2), x.set(n2, r2);
      const es = [["CLIPTextModelWithProjection", an, _], ["SiglipTextModel", pn, _], ["ClapTextModelWithProjection", ui, _], ["ClapAudioModelWithProjection", pi, _]];
      for (const [e3, t2, n2] of es) w.set(e3, n2), y.set(t2, e3), x.set(e3, t2);
      class ts extends ki {
        static MODEL_CLASS_MAPPINGS = Ji.map(((e3) => e3[0]));
        static BASE_IF_FAIL = true;
      }
      class ns extends ki {
        static MODEL_CLASS_MAPPINGS = [Ei];
      }
      class rs extends ki {
        static MODEL_CLASS_MAPPINGS = [Oi];
      }
      class os extends ki {
        static MODEL_CLASS_MAPPINGS = [Ii];
      }
      class is extends ki {
        static MODEL_CLASS_MAPPINGS = [Ai];
      }
      class ss extends ki {
        static MODEL_CLASS_MAPPINGS = [Fi];
      }
      class as extends ki {
        static MODEL_CLASS_MAPPINGS = [Ci];
      }
      class ls extends ki {
        static MODEL_CLASS_MAPPINGS = [Di];
      }
      class cs extends ki {
        static MODEL_CLASS_MAPPINGS = [Li];
      }
      class us extends ki {
        static MODEL_CLASS_MAPPINGS = [$i];
      }
      class ps extends ki {
        static MODEL_CLASS_MAPPINGS = [Ni];
      }
      class ds extends ki {
        static MODEL_CLASS_MAPPINGS = [zi];
      }
      class _s extends ki {
        static MODEL_CLASS_MAPPINGS = [Vi];
      }
      class hs extends ki {
        static MODEL_CLASS_MAPPINGS = [Ui];
      }
      class fs extends ki {
        static MODEL_CLASS_MAPPINGS = [Ri];
      }
      class ms extends ki {
        static MODEL_CLASS_MAPPINGS = [ji];
      }
      class gs extends ki {
        static MODEL_CLASS_MAPPINGS = [Gi];
      }
      class bs extends ki {
        static MODEL_CLASS_MAPPINGS = [qi];
      }
      class ws extends ki {
        static MODEL_CLASS_MAPPINGS = [Wi];
      }
      class xs extends ki {
        static MODEL_CLASS_MAPPINGS = [Hi];
      }
      class ys extends ki {
        static MODEL_CLASS_MAPPINGS = [Xi];
      }
      class Ts extends ki {
        static MODEL_CLASS_MAPPINGS = [Bi];
      }
      class vs extends ki {
        static MODEL_CLASS_MAPPINGS = [Qi];
      }
      class ks extends ki {
        static MODEL_CLASS_MAPPINGS = [Yi];
      }
      class Ms extends ki {
        static MODEL_CLASS_MAPPINGS = [Ki];
      }
      class Ss extends ki {
        static MODEL_CLASS_MAPPINGS = [Zi];
      }
      class Ps extends z {
        constructor({ logits: e3, past_key_values: t2, encoder_outputs: n2, decoder_attentions: r2 = null, cross_attentions: o2 = null }) {
          super(), this.logits = e3, this.past_key_values = t2, this.encoder_outputs = n2, this.decoder_attentions = r2, this.cross_attentions = o2;
        }
      }
      class As extends z {
        constructor({ logits: e3 }) {
          super(), this.logits = e3;
        }
      }
      class Fs extends z {
        constructor({ logits: e3, embeddings: t2 }) {
          super(), this.logits = e3, this.embeddings = t2;
        }
      }
      class Cs extends z {
        constructor({ logits: e3 }) {
          super(), this.logits = e3;
        }
      }
      class Es extends z {
        constructor({ logits: e3 }) {
          super(), this.logits = e3;
        }
      }
      class Os extends z {
        constructor({ start_logits: e3, end_logits: t2 }) {
          super(), this.start_logits = e3, this.end_logits = t2;
        }
      }
      class Is extends z {
        constructor({ logits: e3 }) {
          super(), this.logits = e3;
        }
      }
      class Ds extends z {
        constructor({ logits: e3, past_key_values: t2 }) {
          super(), this.logits = e3, this.past_key_values = t2;
        }
      }
      class Ls extends z {
        constructor({ alphas: e3 }) {
          super(), this.alphas = e3;
        }
      }
      class $s extends z {
        constructor({ waveform: e3, spectrogram: t2 }) {
          super(), this.waveform = e3, this.spectrogram = t2;
        }
      }
    }
  ), "./src/pipelines.js": (
    /*!**************************!*\
      !*** ./src/pipelines.js ***!
      \**************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { AudioClassificationPipeline: () => P, AutomaticSpeechRecognitionPipeline: () => F, DepthEstimationPipeline: () => z, DocumentQuestionAnsweringPipeline: () => $, FeatureExtractionPipeline: () => M, FillMaskPipeline: () => b, ImageClassificationPipeline: () => E, ImageFeatureExtractionPipeline: () => S, ImageSegmentationPipeline: () => O, ImageToImagePipeline: () => B, ImageToTextPipeline: () => C, ObjectDetectionPipeline: () => D, Pipeline: () => h, QuestionAnsweringPipeline: () => g, SummarizationPipeline: () => x, Text2TextGenerationPipeline: () => w, TextClassificationPipeline: () => f, TextGenerationPipeline: () => v, TextToAudioPipeline: () => N, TokenClassificationPipeline: () => m, TranslationPipeline: () => y, ZeroShotAudioClassificationPipeline: () => A, ZeroShotClassificationPipeline: () => k, ZeroShotImageClassificationPipeline: () => I, ZeroShotObjectDetectionPipeline: () => L, pipeline: () => V });
      var r = n(
        /*! ./tokenizers.js */
        "./src/tokenizers.js"
      ), o = n(
        /*! ./models.js */
        "./src/models.js"
      ), i = n(
        /*! ./processors.js */
        "./src/processors.js"
      ), s = n(
        /*! ./utils/core.js */
        "./src/utils/core.js"
      ), a = n(
        /*! ./utils/maths.js */
        "./src/utils/maths.js"
      ), l = n(
        /*! ./utils/audio.js */
        "./src/utils/audio.js"
      ), c = n(
        /*! ./utils/tensor.js */
        "./src/utils/tensor.js"
      ), u = n(
        /*! ./utils/image.js */
        "./src/utils/image.js"
      );
      async function p(e3) {
        return Array.isArray(e3) || (e3 = [e3]), await Promise.all(e3.map(((e4) => u.RawImage.read(e4))));
      }
      async function d(e3, t2) {
        return Array.isArray(e3) || (e3 = [e3]), await Promise.all(e3.map(((e4) => "string" == typeof e4 || e4 instanceof URL ? (0, l.read_audio)(e4, t2) : e4 instanceof Float64Array ? new Float32Array(e4) : e4)));
      }
      function _(e3, t2) {
        t2 && (e3 = e3.map(((e4) => 0 | e4)));
        const [n2, r2, o2, i2] = e3;
        return { xmin: n2, ymin: r2, xmax: o2, ymax: i2 };
      }
      class h extends s.Callable {
        constructor({ task: e3, model: t2, tokenizer: n2 = null, processor: r2 = null }) {
          super(), this.task = e3, this.model = t2, this.tokenizer = n2, this.processor = r2;
        }
        async dispose() {
          await this.model.dispose();
        }
      }
      class f extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { topk: t2 = 1 } = {}) {
          const n2 = this.tokenizer(e3, { padding: true, truncation: true }), r2 = await this.model(n2), o2 = "multi_label_classification" === this.model.config.problem_type ? (e4) => e4.sigmoid().data : (e4) => (0, a.softmax)(e4.data), i2 = this.model.config.id2label, s2 = [];
          for (const e4 of r2.logits) {
            const n3 = o2(e4), r3 = (0, a.getTopItems)(n3, t2).map(((e5) => ({ label: i2[e5[0]], score: e5[1] })));
            1 === t2 ? s2.push(...r3) : s2.push(r3);
          }
          return Array.isArray(e3) || 1 === t2 ? s2 : s2[0];
        }
      }
      class m extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { ignore_labels: t2 = ["O"] } = {}) {
          const n2 = Array.isArray(e3), r2 = this.tokenizer(n2 ? e3 : [e3], { padding: true, truncation: true }), o2 = (await this.model(r2)).logits, i2 = this.model.config.id2label, s2 = [];
          for (let e4 = 0; e4 < o2.dims[0]; ++e4) {
            const n3 = r2.input_ids[e4], l2 = o2[e4], c2 = [];
            for (let e5 = 0; e5 < l2.dims[0]; ++e5) {
              const r3 = l2[e5], o3 = (0, a.max)(r3.data)[1], s3 = i2 ? i2[o3] : `LABEL_${o3}`;
              if (t2.includes(s3)) continue;
              const u2 = this.tokenizer.decode([n3[e5].item()], { skip_special_tokens: true });
              if ("" === u2) continue;
              const p2 = (0, a.softmax)(r3.data);
              c2.push({ entity: s3, score: p2[o3], index: e5, word: u2, start: null, end: null });
            }
            s2.push(c2);
          }
          return n2 ? s2 : s2[0];
        }
      }
      class g extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2, { topk: n2 = 1 } = {}) {
          const r2 = this.tokenizer(e3, { text_pair: t2, padding: true, truncation: true }), o2 = await this.model(r2), i2 = [];
          for (let e4 = 0; e4 < o2.start_logits.dims[0]; ++e4) {
            const t3 = r2.input_ids[e4], l2 = t3.indexOf(this.tokenizer.sep_token_id), c2 = Array.from((0, a.softmax)(o2.start_logits[e4].data)).map(((e5, t4) => [e5, t4])).filter(((e5) => e5[1] > l2)), u2 = Array.from((0, a.softmax)(o2.end_logits[e4].data)).map(((e5, t4) => [e5, t4])).filter(((e5) => e5[1] > l2)), p2 = (0, s.product)(c2, u2).filter(((e5) => e5[0][1] <= e5[1][1])).map(((e5) => [e5[0][1], e5[1][1], e5[0][0] * e5[1][0]])).sort(((e5, t4) => t4[2] - e5[2]));
            for (let e5 = 0; e5 < Math.min(p2.length, n2); ++e5) {
              const [n3, r3, o3] = p2[e5], s2 = [...t3].slice(n3, r3 + 1), a2 = this.tokenizer.decode(s2, { skip_special_tokens: true });
              i2.push({ answer: a2, score: o3 });
            }
          }
          return 1 === n2 ? i2[0] : i2;
        }
      }
      class b extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { topk: t2 = 5 } = {}) {
          const n2 = this.tokenizer(e3, { padding: true, truncation: true }), r2 = await this.model(n2), o2 = [];
          for (let e4 = 0; e4 < n2.input_ids.dims[0]; ++e4) {
            const i2 = n2.input_ids[e4], s2 = i2.indexOf(this.tokenizer.mask_token_id);
            if (-1 === s2) throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);
            const l2 = r2.logits[e4][s2], c2 = (0, a.getTopItems)((0, a.softmax)(l2.data), t2);
            o2.push(c2.map(((e5) => {
              const t3 = [...i2];
              return t3[s2] = e5[0], { score: e5[1], token: e5[0], token_str: this.tokenizer.model.vocab[e5[0]], sequence: this.tokenizer.decode(t3, { skip_special_tokens: true }) };
            })));
          }
          return Array.isArray(e3) ? o2 : o2[0];
        }
      }
      class w extends h {
        _key = "generated_text";
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2 = {}) {
          Array.isArray(e3) || (e3 = [e3]), this.model.config.prefix && (e3 = e3.map(((e4) => this.model.config.prefix + e4)));
          const n2 = this.model.config.task_specific_params;
          n2 && n2[this.task] && n2[this.task].prefix && (e3 = e3.map(((e4) => n2[this.task].prefix + e4)));
          const r2 = this.tokenizer, o2 = { padding: true, truncation: true };
          let i2;
          i2 = this instanceof y && "_build_translation_inputs" in r2 ? r2._build_translation_inputs(e3, o2, t2).input_ids : r2(e3, o2).input_ids;
          const s2 = await this.model.generate(i2, t2);
          return r2.batch_decode(s2, { skip_special_tokens: true }).map(((e4) => ({ [this._key]: e4 })));
        }
      }
      class x extends w {
        _key = "summary_text";
        constructor(e3) {
          super(e3);
        }
      }
      class y extends w {
        _key = "translation_text";
        constructor(e3) {
          super(e3);
        }
      }
      function T(e3) {
        return Array.isArray(e3) && e3.every(((e4) => "role" in e4 && "content" in e4));
      }
      class v extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2 = {}) {
          let n2, r2 = false, o2 = false;
          if ("string" == typeof e3) n2 = e3 = [e3];
          else if (Array.isArray(e3) && e3.every(((e4) => "string" == typeof e4))) r2 = true, n2 = e3;
          else {
            if (T(e3)) e3 = [e3];
            else {
              if (!Array.isArray(e3) || !e3.every(T)) throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");
              r2 = true;
            }
            o2 = true, n2 = e3.map(((e4) => this.tokenizer.apply_chat_template(e4, { tokenize: false, add_generation_prompt: true })));
          }
          const i2 = t2.add_special_tokens ?? false, s2 = !o2 && (t2.return_full_text ?? true);
          this.tokenizer.padding_side = "left";
          const { input_ids: a2, attention_mask: l2 } = this.tokenizer(n2, { add_special_tokens: i2, padding: true, truncation: true }), c2 = await this.model.generate(a2, t2, null, { inputs_attention_mask: l2 });
          let u2, p2 = this.tokenizer.batch_decode(c2, { skip_special_tokens: true });
          !s2 && a2.dims.at(-1) > 0 && (u2 = this.tokenizer.batch_decode(a2, { skip_special_tokens: true }).map(((e4) => e4.length)));
          const d2 = Array.from({ length: e3.length }, ((e4) => []));
          for (let t3 = 0; t3 < p2.length; ++t3) {
            const n3 = Math.floor(t3 / c2.length * e3.length);
            u2 && (p2[t3] = p2[t3].slice(u2[n3])), d2[n3].push({ generated_text: o2 ? [...e3[n3], { role: "assistant", content: p2[t3] }] : p2[t3] });
          }
          return r2 || 1 !== d2.length ? d2 : d2[0];
        }
      }
      class k extends h {
        constructor(e3) {
          super(e3), this.label2id = Object.fromEntries(Object.entries(this.model.config.label2id).map((([e4, t2]) => [e4.toLowerCase(), t2]))), this.entailment_id = this.label2id.entailment, void 0 === this.entailment_id && (console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."), this.entailment_id = 2), this.contradiction_id = this.label2id.contradiction ?? this.label2id.not_entailment, void 0 === this.contradiction_id && (console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."), this.contradiction_id = 0);
        }
        async _call(e3, t2, { hypothesis_template: n2 = "This example is {}.", multi_label: r2 = false } = {}) {
          const o2 = Array.isArray(e3);
          o2 || (e3 = [e3]), Array.isArray(t2) || (t2 = [t2]);
          const i2 = t2.map(((e4) => n2.replace("{}", e4))), s2 = r2 || 1 === t2.length, l2 = [];
          for (const n3 of e3) {
            const e4 = [];
            for (const t3 of i2) {
              const r4 = this.tokenizer(n3, { text_pair: t3, padding: true, truncation: true }), o3 = await this.model(r4);
              s2 ? e4.push([o3.logits.data[this.contradiction_id], o3.logits.data[this.entailment_id]]) : e4.push(o3.logits.data[this.entailment_id]);
            }
            const r3 = (s2 ? e4.map(((e5) => (0, a.softmax)(e5)[1])) : (0, a.softmax)(e4)).map(((e5, t3) => [e5, t3])).sort(((e5, t3) => t3[0] - e5[0]));
            l2.push({ sequence: n3, labels: r3.map(((e5) => t2[e5[1]])), scores: r3.map(((e5) => e5[0])) });
          }
          return o2 ? l2 : l2[0];
        }
      }
      class M extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { pooling: t2 = "none", normalize: n2 = false, quantize: r2 = false, precision: o2 = "binary" } = {}) {
          const i2 = this.tokenizer(e3, { padding: true, truncation: true }), s2 = await this.model(i2);
          let a2 = s2.last_hidden_state ?? s2.logits;
          if ("none" === t2) ;
          else if ("mean" === t2) a2 = (0, c.mean_pooling)(a2, i2.attention_mask);
          else {
            if ("cls" !== t2) throw Error(`Pooling method '${t2}' not supported.`);
            a2 = a2.slice(null, 0);
          }
          return n2 && (a2 = a2.normalize(2, -1)), r2 && (a2 = (0, c.quantize_embeddings)(a2, o2)), a2;
        }
      }
      class S extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { pool: t2 = null } = {}) {
          const n2 = await p(e3), { pixel_values: r2 } = await this.processor(n2), o2 = await this.model({ pixel_values: r2 });
          let i2;
          if (t2) {
            if (!("pooler_output" in o2)) throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");
            i2 = o2.pooler_output;
          } else i2 = o2.last_hidden_state ?? o2.logits ?? o2.image_embeds;
          return i2;
        }
      }
      class P extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { topk: t2 = null } = {}) {
          const n2 = !Array.isArray(e3), r2 = this.processor.feature_extractor.config.sampling_rate, o2 = await d(e3, r2), i2 = this.model.config.id2label, s2 = [];
          for (const e4 of o2) {
            const n3 = await this.processor(e4), r3 = (await this.model(n3)).logits[0], o3 = (0, a.getTopItems)((0, a.softmax)(r3.data), t2).map(((e5) => ({ label: i2[e5[0]], score: e5[1] })));
            1 === t2 ? s2.push(...o3) : s2.push(o3);
          }
          return n2 && 1 !== t2 ? s2[0] : s2;
        }
      }
      class A extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2, { hypothesis_template: n2 = "This is a sound of {}." } = {}) {
          const r2 = !Array.isArray(e3);
          r2 && (e3 = [e3]);
          const o2 = t2.map(((e4) => n2.replace("{}", e4))), i2 = this.tokenizer(o2, { padding: true, truncation: true }), s2 = this.processor.feature_extractor.config.sampling_rate, l2 = await d(e3, s2), c2 = [];
          for (const e4 of l2) {
            const n3 = await this.processor(e4), r3 = await this.model({ ...i2, ...n3 }), o3 = (0, a.softmax)(r3.logits_per_audio.data);
            c2.push([...o3].map(((e5, n4) => ({ score: e5, label: t2[n4] }))));
          }
          return r2 ? c2[0] : c2;
        }
      }
      class F extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2 = {}) {
          switch (this.model.config.model_type) {
            case "whisper":
              return this._call_whisper(e3, t2);
            case "wav2vec2":
            case "wav2vec2-bert":
            case "unispeech":
            case "unispeech-sat":
            case "hubert":
              return this._call_wav2vec2(e3, t2);
            default:
              throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`);
          }
        }
        async _call_wav2vec2(e3, t2 = {}) {
          t2.language && console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'), t2.task && console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');
          const n2 = !Array.isArray(e3);
          n2 && (e3 = [e3]);
          const r2 = this.processor.feature_extractor.config.sampling_rate, o2 = await d(e3, r2), i2 = [];
          for (const e4 of o2) {
            const t3 = await this.processor(e4), n3 = (await this.model(t3)).logits[0], r3 = [];
            for (const e5 of n3) r3.push((0, a.max)(e5.data)[1]);
            const o3 = this.tokenizer.decode(r3);
            i2.push({ text: o3 });
          }
          return n2 ? i2[0] : i2;
        }
        async _call_whisper(e3, t2 = {}) {
          const n2 = t2.return_timestamps ?? false, r2 = t2.chunk_length_s ?? 0, o2 = t2.chunk_callback ?? null, i2 = t2.force_full_sequences ?? false;
          let l2 = t2.stride_length_s ?? null;
          "word" === n2 && (t2.return_token_timestamps = true);
          const c2 = (0, s.pop)(t2, "language", null), u2 = (0, s.pop)(t2, "task", null);
          if (c2 || u2 || n2) {
            if (t2.forced_decoder_ids) throw new Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.");
            const e4 = this.tokenizer.get_decoder_prompt_ids({ language: c2, task: u2, no_timestamps: !n2 });
            e4.length > 0 && (t2.forced_decoder_ids = e4);
          }
          const p2 = !Array.isArray(e3);
          p2 && (e3 = [e3]);
          const _2 = this.processor.feature_extractor.config.chunk_length / this.model.config.max_source_positions, h2 = this.processor.feature_extractor.config.hop_length, f2 = this.processor.feature_extractor.config.sampling_rate, m2 = await d(e3, f2), g2 = [];
          for (const e4 of m2) {
            let s2 = [];
            if (r2 > 0) {
              if (null === l2) l2 = r2 / 6;
              else if (r2 <= l2) throw Error("`chunk_length_s` must be larger than `stride_length_s`.");
              const t3 = f2 * r2, n3 = f2 * l2, o3 = t3 - 2 * n3;
              let i3 = 0;
              for (; i3 < e4.length; ) {
                const r3 = e4.subarray(i3, i3 + t3), a2 = await this.processor(r3), l3 = 0 === i3, c4 = i3 + o3 >= e4.length;
                s2.push({ stride: [r3.length, l3 ? 0 : n3, c4 ? 0 : n3], input_features: a2.input_features, is_last: c4 }), i3 += o3;
              }
            } else s2 = [{ stride: [e4.length, 0, 0], input_features: (await this.processor(e4)).input_features, is_last: true }];
            for (const e5 of s2) {
              t2.num_frames = Math.floor(e5.stride[0] / h2);
              const r3 = await this.model.generate(e5.input_features, t2);
              "word" === n2 ? (e5.tokens = r3.sequences[0], e5.token_timestamps = r3.token_timestamps.tolist()[0].map(((e6) => (0, a.round)(e6, 2)))) : e5.tokens = r3[0], e5.stride = e5.stride.map(((e6) => e6 / f2)), null !== o2 && o2(e5);
            }
            const [c3, u3] = this.tokenizer._decode_asr(s2, { time_precision: _2, return_timestamps: n2, force_full_sequences: i2 });
            g2.push({ text: c3, ...u3 });
          }
          return p2 ? g2[0] : g2;
        }
      }
      class C extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2 = {}) {
          const n2 = Array.isArray(e3), r2 = await p(e3), { pixel_values: o2 } = await this.processor(r2), i2 = [];
          for (const e4 of o2) {
            e4.dims = [1, ...e4.dims];
            const n3 = await this.model.generate(e4, t2), r3 = this.tokenizer.batch_decode(n3, { skip_special_tokens: true }).map(((e5) => ({ generated_text: e5.trim() })));
            i2.push(r3);
          }
          return n2 ? i2 : i2[0];
        }
      }
      class E extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { topk: t2 = 1 } = {}) {
          const n2 = Array.isArray(e3), r2 = await p(e3), { pixel_values: o2 } = await this.processor(r2), i2 = await this.model({ pixel_values: o2 }), s2 = this.model.config.id2label, l2 = [];
          for (const e4 of i2.logits) {
            const n3 = (0, a.getTopItems)((0, a.softmax)(e4.data), t2).map(((e5) => ({ label: s2[e5[0]], score: e5[1] })));
            1 === t2 ? l2.push(...n3) : l2.push(n3);
          }
          return n2 || 1 === t2 ? l2 : l2[0];
        }
      }
      class O extends h {
        constructor(e3) {
          super(e3), this.subtasks_mapping = { panoptic: "post_process_panoptic_segmentation", instance: "post_process_instance_segmentation", semantic: "post_process_semantic_segmentation" };
        }
        async _call(e3, { threshold: t2 = 0.5, mask_threshold: n2 = 0.5, overlap_mask_area_threshold: r2 = 0.8, label_ids_to_fuse: o2 = null, target_sizes: i2 = null, subtask: s2 = null } = {}) {
          if (Array.isArray(e3) && 1 !== e3.length) throw Error("Image segmentation pipeline currently only supports a batch size of 1.");
          const a2 = await p(e3), l2 = a2.map(((e4) => [e4.height, e4.width])), { pixel_values: c2, pixel_mask: d2 } = await this.processor(a2), _2 = await this.model({ pixel_values: c2, pixel_mask: d2 });
          let h2 = null;
          if (null !== s2) h2 = this.subtasks_mapping[s2];
          else for (let [e4, t3] of Object.entries(this.subtasks_mapping)) if (t3 in this.processor.feature_extractor) {
            h2 = this.processor.feature_extractor[t3].bind(this.processor.feature_extractor), s2 = e4;
            break;
          }
          const f2 = this.model.config.id2label, m2 = [];
          if ("panoptic" === s2 || "instance" === s2) {
            const e4 = h2(_2, t2, n2, r2, o2, i2 ?? l2)[0], s3 = e4.segmentation;
            for (const t3 of e4.segments_info) {
              const e5 = new Uint8ClampedArray(s3.data.length);
              for (let n4 = 0; n4 < s3.data.length; ++n4) s3.data[n4] === t3.id && (e5[n4] = 255);
              const n3 = new u.RawImage(e5, s3.dims[1], s3.dims[0], 1);
              m2.push({ score: t3.score, label: f2[t3.label_id], mask: n3 });
            }
          } else {
            if ("semantic" !== s2) throw Error(`Subtask ${s2} not supported.`);
            {
              const { segmentation: e4, labels: t3 } = h2(_2, i2 ?? l2)[0];
              for (const n3 of t3) {
                const t4 = new Uint8ClampedArray(e4.data.length);
                for (let r4 = 0; r4 < e4.data.length; ++r4) e4.data[r4] === n3 && (t4[r4] = 255);
                const r3 = new u.RawImage(t4, e4.dims[1], e4.dims[0], 1);
                m2.push({ score: null, label: f2[n3], mask: r3 });
              }
            }
          }
          return m2;
        }
      }
      class I extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2, { hypothesis_template: n2 = "This is a photo of {}" } = {}) {
          const r2 = Array.isArray(e3), o2 = await p(e3), i2 = t2.map(((e4) => n2.replace("{}", e4))), s2 = this.tokenizer(i2, { padding: "siglip" !== this.model.config.model_type || "max_length", truncation: true }), { pixel_values: l2 } = await this.processor(o2), c2 = await this.model({ ...s2, pixel_values: l2 }), u2 = "siglip" === this.model.config.model_type ? (e4) => e4.sigmoid().data : (e4) => (0, a.softmax)(e4.data), d2 = [];
          for (const e4 of c2.logits_per_image) {
            const n3 = [...u2(e4)].map(((e5, n4) => ({ score: e5, label: t2[n4] })));
            n3.sort(((e5, t3) => t3.score - e5.score)), d2.push(n3);
          }
          return r2 ? d2 : d2[0];
        }
      }
      class D extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, { threshold: t2 = 0.9, percentage: n2 = false } = {}) {
          const r2 = Array.isArray(e3);
          if (r2 && 1 !== e3.length) throw Error("Object detection pipeline currently only supports a batch size of 1.");
          const o2 = await p(e3), i2 = n2 ? null : o2.map(((e4) => [e4.height, e4.width])), { pixel_values: s2, pixel_mask: a2 } = await this.processor(o2), l2 = await this.model({ pixel_values: s2, pixel_mask: a2 }), c2 = this.processor.feature_extractor.post_process_object_detection(l2, t2, i2), u2 = this.model.config.id2label, d2 = c2.map(((e4) => e4.boxes.map(((t3, r3) => ({ score: e4.scores[r3], label: u2[e4.classes[r3]], box: _(t3, !n2) })))));
          return r2 ? d2 : d2[0];
        }
      }
      class L extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2, { threshold: n2 = 0.1, topk: r2 = null, percentage: o2 = false } = {}) {
          const i2 = Array.isArray(e3), s2 = await p(e3), a2 = this.tokenizer(t2, { padding: true, truncation: true }), l2 = await this.processor(s2), c2 = [];
          for (let e4 = 0; e4 < s2.length; ++e4) {
            const i3 = s2[e4], u2 = o2 ? null : [[i3.height, i3.width]], p2 = l2.pixel_values[e4].unsqueeze_(0), d2 = await this.model({ ...a2, pixel_values: p2 }), h2 = this.processor.feature_extractor.post_process_object_detection(d2, n2, u2, true)[0];
            let f2 = h2.boxes.map(((e5, n3) => ({ score: h2.scores[n3], label: t2[h2.classes[n3]], box: _(e5, !o2) }))).sort(((e5, t3) => t3.score - e5.score));
            null !== r2 && (f2 = f2.slice(0, r2)), c2.push(f2);
          }
          return i2 ? c2 : c2[0];
        }
      }
      class $ extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3, t2, n2 = {}) {
          const r2 = (await p(e3))[0], { pixel_values: o2 } = await this.processor(r2), i2 = `<s_docvqa><s_question>${t2}</s_question><s_answer>`, s2 = this.tokenizer(i2, { add_special_tokens: false, padding: true, truncation: true }).input_ids, a2 = await this.model.generate(o2, { ...n2, decoder_input_ids: s2, max_length: this.model.config.decoder.max_position_embeddings }), l2 = this.tokenizer.batch_decode(a2)[0].match(/<s_answer>(.*?)<\/s_answer>/);
          let c2 = null;
          return l2 && l2.length >= 2 && (c2 = l2[1].trim()), [{ answer: c2 }];
        }
      }
      class N extends h {
        DEFAULT_VOCODER_ID = "Xenova/speecht5_hifigan";
        constructor(e3) {
          super(e3), this.vocoder = e3.vocoder ?? null;
        }
        async _call(e3, { speaker_embeddings: t2 = null } = {}) {
          return this.processor ? this._call_text_to_spectrogram(e3, { speaker_embeddings: t2 }) : this._call_text_to_waveform(e3);
        }
        async _call_text_to_waveform(e3) {
          const t2 = this.tokenizer(e3, { padding: true, truncation: true }), { waveform: n2 } = await this.model(t2), r2 = this.model.config.sampling_rate;
          return { audio: n2.data, sampling_rate: r2 };
        }
        async _call_text_to_spectrogram(e3, { speaker_embeddings: t2 }) {
          if (this.vocoder || (console.log("No vocoder specified, using default HifiGan vocoder."), this.vocoder = await o.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID, { quantized: false })), ("string" == typeof t2 || t2 instanceof URL) && (t2 = new Float32Array(await (await fetch(t2)).arrayBuffer())), t2 instanceof Float32Array) t2 = new c.Tensor("float32", t2, [1, t2.length]);
          else if (!(t2 instanceof c.Tensor)) throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");
          const { input_ids: n2 } = this.tokenizer(e3, { padding: true, truncation: true }), { waveform: r2 } = await this.model.generate_speech(n2, t2, { vocoder: this.vocoder }), i2 = this.processor.feature_extractor.config.sampling_rate;
          return { audio: r2.data, sampling_rate: i2 };
        }
      }
      class B extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3) {
          const t2 = await p(e3), n2 = await this.processor(t2), r2 = await this.model(n2), o2 = [];
          for (const e4 of r2.reconstruction) {
            const t3 = e4.squeeze().clamp_(0, 1).mul_(255).round_().to("uint8");
            o2.push(u.RawImage.fromTensor(t3));
          }
          return o2.length > 1 ? o2 : o2[0];
        }
      }
      class z extends h {
        constructor(e3) {
          super(e3);
        }
        async _call(e3) {
          const t2 = await p(e3), n2 = await this.processor(t2), { predicted_depth: r2 } = await this.model(n2), o2 = [];
          for (let e4 = 0; e4 < t2.length; ++e4) {
            const n3 = (0, c.interpolate)(r2[e4], t2[e4].size.reverse(), "bilinear", false), i2 = n3.mul_(255 / (0, a.max)(n3.data)[0]).to("uint8");
            o2.push({ predicted_depth: r2[e4], depth: u.RawImage.fromTensor(i2) });
          }
          return o2.length > 1 ? o2 : o2[0];
        }
      }
      const R = Object.freeze({ "text-classification": { tokenizer: r.AutoTokenizer, pipeline: f, model: o.AutoModelForSequenceClassification, default: { model: "Xenova/distilbert-base-uncased-finetuned-sst-2-english" }, type: "text" }, "token-classification": { tokenizer: r.AutoTokenizer, pipeline: m, model: o.AutoModelForTokenClassification, default: { model: "Xenova/bert-base-multilingual-cased-ner-hrl" }, type: "text" }, "question-answering": { tokenizer: r.AutoTokenizer, pipeline: g, model: o.AutoModelForQuestionAnswering, default: { model: "Xenova/distilbert-base-cased-distilled-squad" }, type: "text" }, "fill-mask": { tokenizer: r.AutoTokenizer, pipeline: b, model: o.AutoModelForMaskedLM, default: { model: "Xenova/bert-base-uncased" }, type: "text" }, summarization: { tokenizer: r.AutoTokenizer, pipeline: x, model: o.AutoModelForSeq2SeqLM, default: { model: "Xenova/distilbart-cnn-6-6" }, type: "text" }, translation: { tokenizer: r.AutoTokenizer, pipeline: y, model: o.AutoModelForSeq2SeqLM, default: { model: "Xenova/t5-small" }, type: "text" }, "text2text-generation": { tokenizer: r.AutoTokenizer, pipeline: w, model: o.AutoModelForSeq2SeqLM, default: { model: "Xenova/flan-t5-small" }, type: "text" }, "text-generation": { tokenizer: r.AutoTokenizer, pipeline: v, model: o.AutoModelForCausalLM, default: { model: "Xenova/gpt2" }, type: "text" }, "zero-shot-classification": { tokenizer: r.AutoTokenizer, pipeline: k, model: o.AutoModelForSequenceClassification, default: { model: "Xenova/distilbert-base-uncased-mnli" }, type: "text" }, "audio-classification": { pipeline: P, model: o.AutoModelForAudioClassification, processor: i.AutoProcessor, default: { model: "Xenova/wav2vec2-base-superb-ks" }, type: "audio" }, "zero-shot-audio-classification": { tokenizer: r.AutoTokenizer, pipeline: A, model: o.AutoModel, processor: i.AutoProcessor, default: { model: "Xenova/clap-htsat-unfused" }, type: "multimodal" }, "automatic-speech-recognition": { tokenizer: r.AutoTokenizer, pipeline: F, model: [o.AutoModelForSpeechSeq2Seq, o.AutoModelForCTC], processor: i.AutoProcessor, default: { model: "Xenova/whisper-tiny.en" }, type: "multimodal" }, "text-to-audio": { tokenizer: r.AutoTokenizer, pipeline: N, model: [o.AutoModelForTextToWaveform, o.AutoModelForTextToSpectrogram], processor: [i.AutoProcessor, null], default: { model: "Xenova/speecht5_tts" }, type: "text" }, "image-to-text": { tokenizer: r.AutoTokenizer, pipeline: C, model: o.AutoModelForVision2Seq, processor: i.AutoProcessor, default: { model: "Xenova/vit-gpt2-image-captioning" }, type: "multimodal" }, "image-classification": { pipeline: E, model: o.AutoModelForImageClassification, processor: i.AutoProcessor, default: { model: "Xenova/vit-base-patch16-224" }, type: "multimodal" }, "image-segmentation": { pipeline: O, model: [o.AutoModelForImageSegmentation, o.AutoModelForSemanticSegmentation], processor: i.AutoProcessor, default: { model: "Xenova/detr-resnet-50-panoptic" }, type: "multimodal" }, "zero-shot-image-classification": { tokenizer: r.AutoTokenizer, pipeline: I, model: o.AutoModel, processor: i.AutoProcessor, default: { model: "Xenova/clip-vit-base-patch32" }, type: "multimodal" }, "object-detection": { pipeline: D, model: o.AutoModelForObjectDetection, processor: i.AutoProcessor, default: { model: "Xenova/detr-resnet-50" }, type: "multimodal" }, "zero-shot-object-detection": { tokenizer: r.AutoTokenizer, pipeline: L, model: o.AutoModelForZeroShotObjectDetection, processor: i.AutoProcessor, default: { model: "Xenova/owlvit-base-patch32" }, type: "multimodal" }, "document-question-answering": { tokenizer: r.AutoTokenizer, pipeline: $, model: o.AutoModelForDocumentQuestionAnswering, processor: i.AutoProcessor, default: { model: "Xenova/donut-base-finetuned-docvqa" }, type: "multimodal" }, "image-to-image": { pipeline: B, model: o.AutoModelForImageToImage, processor: i.AutoProcessor, default: { model: "Xenova/swin2SR-classical-sr-x2-64" }, type: "image" }, "depth-estimation": { pipeline: z, model: o.AutoModelForDepthEstimation, processor: i.AutoProcessor, default: { model: "Xenova/dpt-large" }, type: "image" }, "feature-extraction": { tokenizer: r.AutoTokenizer, pipeline: M, model: o.AutoModel, default: { model: "Xenova/all-MiniLM-L6-v2" }, type: "text" }, "image-feature-extraction": { processor: i.AutoProcessor, pipeline: S, model: [o.AutoModelForImageFeatureExtraction, o.AutoModel], default: { model: "Xenova/vit-base-patch16-224-in21k" }, type: "image" } }), j = Object.freeze({ "sentiment-analysis": "text-classification", ner: "token-classification", asr: "automatic-speech-recognition", "text-to-speech": "text-to-audio", embeddings: "feature-extraction" });
      async function V(e3, t2 = null, { quantized: n2 = true, progress_callback: r2 = null, config: o2 = null, cache_dir: i2 = null, local_files_only: a2 = false, revision: l2 = "main" } = {}) {
        e3 = j[e3] ?? e3;
        const c2 = R[e3.split("_", 1)[0]];
        if (!c2) throw Error(`Unsupported pipeline: ${e3}. Must be one of [${Object.keys(R)}]`);
        t2 || (t2 = c2.default.model, console.log(`No model specified. Using default model: "${t2}".`));
        const u2 = { quantized: n2, progress_callback: r2, config: o2, cache_dir: i2, local_files_only: a2, revision: l2 }, p2 = /* @__PURE__ */ new Map([["tokenizer", c2.tokenizer], ["model", c2.model], ["processor", c2.processor]]), d2 = await (async function(e4, t3, n3) {
          const r3 = /* @__PURE__ */ Object.create(null), o3 = [];
          for (let [i3, s2] of e4.entries()) {
            if (!s2) continue;
            let e5;
            e5 = Array.isArray(s2) ? new Promise((async (e6, r4) => {
              let o4;
              for (let r5 of s2) {
                if (null === r5) return void e6(null);
                try {
                  return void e6(await r5.from_pretrained(t3, n3));
                } catch (e7) {
                  o4 = e7;
                }
              }
              r4(o4);
            })) : s2.from_pretrained(t3, n3), r3[i3] = e5, o3.push(e5);
          }
          await Promise.all(o3);
          for (let [e5, t4] of Object.entries(r3)) r3[e5] = await t4;
          return r3;
        })(p2, t2, u2);
        d2.task = e3, (0, s.dispatchCallback)(r2, { status: "ready", task: e3, model: t2 });
        return new (0, c2.pipeline)(d2);
      }
    }
  ), "./src/processors.js": (
    /*!***************************!*\
      !*** ./src/processors.js ***!
      \***************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { ASTFeatureExtractor: () => U, AutoProcessor: () => Z, BeitFeatureExtractor: () => O, BitImageProcessor: () => b, CLIPFeatureExtractor: () => x, ChineseCLIPFeatureExtractor: () => y, ClapFeatureExtractor: () => G, ConvNextFeatureExtractor: () => v, ConvNextImageProcessor: () => k, DPTFeatureExtractor: () => m, DPTImageProcessor: () => g, DeiTFeatureExtractor: () => E, DetrFeatureExtractor: () => L, DonutFeatureExtractor: () => I, EfficientNetImageProcessor: () => P, FeatureExtractor: () => _, GLPNFeatureExtractor: () => w, ImageFeatureExtractor: () => h, MobileViTFeatureExtractor: () => A, NougatImageProcessor: () => D, OwlViTFeatureExtractor: () => F, OwlViTProcessor: () => K, Owlv2ImageProcessor: () => C, Processor: () => W, SamImageProcessor: () => N, SamProcessor: () => H, SeamlessM4TFeatureExtractor: () => V, SegformerFeatureExtractor: () => f, SiglipImageProcessor: () => T, SpeechT5FeatureExtractor: () => q, SpeechT5Processor: () => Y, Swin2SRImageProcessor: () => B, ViTFeatureExtractor: () => M, ViTImageProcessor: () => S, VitMatteImageProcessor: () => z, Wav2Vec2FeatureExtractor: () => j, Wav2Vec2ProcessorWithLM: () => Q, WhisperFeatureExtractor: () => R, WhisperProcessor: () => X, YolosFeatureExtractor: () => $ });
      var r = n(
        /*! ./utils/core.js */
        "./src/utils/core.js"
      ), o = n(
        /*! ./utils/hub.js */
        "./src/utils/hub.js"
      ), i = n(
        /*! ./utils/maths.js */
        "./src/utils/maths.js"
      ), s = n(
        /*! ./utils/tensor.js */
        "./src/utils/tensor.js"
      ), a = (n(
        /*! ./utils/image.js */
        "./src/utils/image.js"
      ), n(
        /*! ./utils/audio.js */
        "./src/utils/audio.js"
      ));
      function l([e3, t2, n2, r2]) {
        return [e3 - n2 / 2, t2 - r2 / 2, e3 + n2 / 2, t2 + r2 / 2];
      }
      function c(e3, t2 = 0.5, n2 = null, r2 = false) {
        const o2 = e3.logits, s2 = e3.pred_boxes, [a2, c2, u2] = o2.dims;
        if (null !== n2 && n2.length !== a2) throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
        let p2 = [];
        for (let e4 = 0; e4 < a2; ++e4) {
          let a3 = null !== n2 ? n2[e4] : null, d2 = { boxes: [], classes: [], scores: [] }, _2 = o2[e4], h2 = s2[e4];
          for (let e5 = 0; e5 < c2; ++e5) {
            let n3, o3 = _2[e5], s3 = [];
            if (r2) {
              n3 = o3.sigmoid().data;
              for (let e6 = 0; e6 < n3.length; ++e6) n3[e6] > t2 && s3.push(e6);
            } else {
              let e6 = (0, i.max)(o3.data)[1];
              if (e6 === u2 - 1) continue;
              s3.push(e6), n3 = (0, i.softmax)(o3.data);
            }
            for (const t3 of s3) {
              let r3 = h2[e5].data;
              r3 = l(r3), null !== a3 && (r3 = r3.map(((e6, t4) => e6 * a3[(t4 + 1) % 2]))), d2.boxes.push(r3), d2.classes.push(t3), d2.scores.push(n3[t3]);
            }
          }
          p2.push(d2);
        }
        return p2;
      }
      function u(e3, t2) {
        if (!(e3 instanceof Float32Array || e3 instanceof Float64Array)) throw new Error(`${t2} expects input to be a Float32Array or a Float64Array, but got ${e3?.constructor?.name ?? typeof e3} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`);
      }
      function p(e3, t2, n2 = 0, r2 = null) {
        const o2 = e3 / t2;
        let s2 = (0, i.bankers_round)(o2) * t2;
        return null !== r2 && s2 > r2 && (s2 = Math.floor(o2) * t2), s2 < n2 && (s2 = Math.ceil(o2) * t2), s2;
      }
      function d([e3, t2], n2) {
        return [Math.max(Math.floor(e3 / n2), 1) * n2, Math.max(Math.floor(t2 / n2), 1) * n2];
      }
      class _ extends r.Callable {
        constructor(e3) {
          super(), this.config = e3;
        }
      }
      class h extends _ {
        constructor(e3) {
          super(e3), this.image_mean = this.config.image_mean ?? this.config.mean, this.image_std = this.config.image_std ?? this.config.std, this.resample = this.config.resample ?? 2, this.do_rescale = this.config.do_rescale ?? true, this.rescale_factor = this.config.rescale_factor ?? 1 / 255, this.do_normalize = this.config.do_normalize, this.do_resize = this.config.do_resize, this.do_thumbnail = this.config.do_thumbnail, this.size = this.config.size, this.size_divisibility = this.config.size_divisibility ?? this.config.size_divisor, this.do_center_crop = this.config.do_center_crop, this.crop_size = this.config.crop_size, this.do_convert_rgb = this.config.do_convert_rgb ?? true, this.do_crop_margin = this.config.do_crop_margin, this.pad_size = this.config.pad_size, this.do_pad = this.config.do_pad, this.do_pad && !this.pad_size && this.size && void 0 !== this.size.width && void 0 !== this.size.height && (this.pad_size = this.size);
        }
        async thumbnail(e3, t2, n2 = 2) {
          const r2 = e3.height, o2 = e3.width, i2 = t2.height, s2 = t2.width;
          let a2 = Math.min(r2, i2), l2 = Math.min(o2, s2);
          return a2 === r2 && l2 === o2 ? e3 : (r2 > o2 ? l2 = Math.floor(o2 * a2 / r2) : o2 > r2 && (a2 = Math.floor(r2 * l2 / o2)), await e3.resize(l2, a2, { resample: n2 }));
        }
        async crop_margin(e3, t2 = 200) {
          const n2 = e3.clone().grayscale(), r2 = (0, i.min)(n2.data)[0], o2 = (0, i.max)(n2.data)[0] - r2;
          if (0 === o2) return e3;
          const s2 = t2 / 255;
          let a2 = n2.width, l2 = n2.height, c2 = 0, u2 = 0;
          for (let e4 = 0; e4 < n2.height; ++e4) {
            const t3 = e4 * n2.width;
            for (let i2 = 0; i2 < n2.width; ++i2) (n2.data[t3 + i2] - r2) / o2 < s2 && (a2 = Math.min(a2, i2), l2 = Math.min(l2, e4), c2 = Math.max(c2, i2), u2 = Math.max(u2, e4));
          }
          return e3 = await e3.crop([a2, l2, c2, u2]);
        }
        pad_image(e3, t2, n2, { mode: o2 = "constant", center: i2 = false, constant_values: s2 = 0 } = {}) {
          const [a2, l2, c2] = t2;
          let u2, p2;
          if ("number" == typeof n2 ? (u2 = n2, p2 = n2) : (u2 = n2.width, p2 = n2.height), u2 !== l2 || p2 !== a2) {
            const n3 = new Float32Array(u2 * p2 * c2);
            if (Array.isArray(s2)) for (let e4 = 0; e4 < n3.length; ++e4) n3[e4] = s2[e4 % c2];
            else 0 !== s2 && n3.fill(s2);
            const [d2, _2] = i2 ? [Math.floor((u2 - l2) / 2), Math.floor((p2 - a2) / 2)] : [0, 0];
            for (let t3 = 0; t3 < a2; ++t3) {
              const r2 = (t3 + _2) * u2, o3 = t3 * l2;
              for (let t4 = 0; t4 < l2; ++t4) {
                const i3 = (r2 + t4 + d2) * c2, s3 = (o3 + t4) * c2;
                for (let t5 = 0; t5 < c2; ++t5) n3[i3 + t5] = e3[s3 + t5];
              }
            }
            if ("symmetric" === o2) {
              if (i2) throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");
              const t3 = a2 - 1, o3 = l2 - 1;
              for (let i3 = 0; i3 < p2; ++i3) {
                const s3 = i3 * u2, p3 = (0, r.calculateReflectOffset)(i3, t3) * l2;
                for (let t4 = 0; t4 < u2; ++t4) {
                  if (i3 < a2 && t4 < l2) continue;
                  const u3 = (s3 + t4) * c2, d3 = (p3 + (0, r.calculateReflectOffset)(t4, o3)) * c2;
                  for (let t5 = 0; t5 < c2; ++t5) n3[u3 + t5] = e3[d3 + t5];
                }
              }
            }
            e3 = n3, t2 = [p2, u2, c2];
          }
          return [e3, t2];
        }
        rescale(e3) {
          for (let t2 = 0; t2 < e3.length; ++t2) e3[t2] = this.rescale_factor * e3[t2];
        }
        get_resize_output_image_size(e3, t2) {
          const [n2, r2] = e3.size;
          let o2, i2;
          if (this.do_thumbnail) {
            const { height: e4, width: n3 } = t2;
            o2 = Math.min(e4, n3);
          } else Number.isInteger(t2) ? (o2 = t2, i2 = this.config.max_size ?? o2) : void 0 !== t2 && (o2 = t2.shortest_edge, i2 = t2.longest_edge);
          if (void 0 !== o2 || void 0 !== i2) {
            const e4 = void 0 === o2 ? 1 : Math.max(o2 / n2, o2 / r2), t3 = n2 * e4, s2 = r2 * e4, a2 = void 0 === i2 ? 1 : Math.min(i2 / t3, i2 / s2);
            let l2 = Math.floor(Number((t3 * a2).toFixed(2))), c2 = Math.floor(Number((s2 * a2).toFixed(2)));
            return void 0 !== this.size_divisibility && ([l2, c2] = d([l2, c2], this.size_divisibility)), [l2, c2];
          }
          if (void 0 !== t2 && void 0 !== t2.width && void 0 !== t2.height) {
            let e4 = t2.width, o3 = t2.height;
            if (this.config.keep_aspect_ratio && this.config.ensure_multiple_of) {
              let t3 = o3 / r2, i3 = e4 / n2;
              Math.abs(1 - i3) < Math.abs(1 - t3) ? t3 = i3 : i3 = t3, o3 = p(t3 * r2, this.config.ensure_multiple_of), e4 = p(i3 * n2, this.config.ensure_multiple_of);
            }
            return [e4, o3];
          }
          if (void 0 !== this.size_divisibility) return d([n2, r2], this.size_divisibility);
          throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(t2)}`);
        }
        async resize(e3) {
          const [t2, n2] = this.get_resize_output_image_size(e3, this.size);
          return await e3.resize(t2, n2, { resample: this.resample });
        }
        async preprocess(e3, { do_normalize: t2 = null, do_pad: n2 = null, do_convert_rgb: r2 = null, do_convert_grayscale: o2 = null } = {}) {
          this.do_crop_margin && (e3 = await this.crop_margin(e3));
          const [i2, a2] = e3.size;
          if (r2 ?? this.do_convert_rgb ? e3 = e3.rgb() : o2 && (e3 = e3.grayscale()), this.do_resize && (e3 = await this.resize(e3)), this.do_thumbnail && (e3 = await this.thumbnail(e3, this.size, this.resample)), this.do_center_crop) {
            let t3, n3;
            Number.isInteger(this.crop_size) ? (t3 = this.crop_size, n3 = this.crop_size) : (t3 = this.crop_size.width, n3 = this.crop_size.height), e3 = await e3.center_crop(t3, n3);
          }
          const l2 = [e3.height, e3.width];
          let c2 = Float32Array.from(e3.data), u2 = [e3.height, e3.width, e3.channels];
          if (this.do_rescale && this.rescale(c2), t2 ?? this.do_normalize) {
            let t3 = this.image_mean;
            Array.isArray(this.image_mean) || (t3 = new Array(e3.channels).fill(t3));
            let n3 = this.image_std;
            if (Array.isArray(this.image_std) || (n3 = new Array(e3.channels).fill(t3)), t3.length !== e3.channels || n3.length !== e3.channels) throw new Error(`When set to arrays, the length of \`image_mean\` (${t3.length}) and \`image_std\` (${n3.length}) must match the number of channels in the image (${e3.channels}).`);
            for (let r3 = 0; r3 < c2.length; r3 += e3.channels) for (let o3 = 0; o3 < e3.channels; ++o3) c2[r3 + o3] = (c2[r3 + o3] - t3[o3]) / n3[o3];
          }
          if (n2 ?? this.do_pad) {
            if (this.pad_size) {
              const t3 = this.pad_image(c2, [e3.height, e3.width, e3.channels], this.pad_size);
              [c2, u2] = t3;
            } else if (this.size_divisibility) {
              const [e4, t3] = d([u2[1], u2[0]], this.size_divisibility);
              [c2, u2] = this.pad_image(c2, u2, { width: e4, height: t3 });
            }
          }
          return { original_size: [a2, i2], reshaped_input_size: l2, pixel_values: new s.Tensor("float32", c2, u2).permute(2, 0, 1) };
        }
        async _call(e3, ...t2) {
          Array.isArray(e3) || (e3 = [e3]);
          const n2 = await Promise.all(e3.map(((e4) => this.preprocess(e4))));
          return { pixel_values: (0, s.stack)(n2.map(((e4) => e4.pixel_values)), 0), original_sizes: n2.map(((e4) => e4.original_size)), reshaped_input_sizes: n2.map(((e4) => e4.reshaped_input_size)) };
        }
      }
      class f extends h {
        post_process_semantic_segmentation(e3, t2 = null) {
          const n2 = e3.logits, r2 = n2.dims[0];
          if (null !== t2 && t2.length !== r2) throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
          const o2 = [];
          for (let e4 = 0; e4 < r2; ++e4) {
            const r3 = null !== t2 ? t2[e4] : null;
            let i2 = n2[e4];
            null !== r3 && (i2 = (0, s.interpolate)(i2, r3, "bilinear", false));
            const [a2, l2] = r3 ?? i2.dims.slice(-2), c2 = new s.Tensor("int32", new Int32Array(a2 * l2), [a2, l2]), u2 = i2[0].data;
            for (let e5 = 1; e5 < i2.dims[0]; ++e5) {
              const t3 = i2[e5].data;
              for (let n3 = 0; n3 < t3.length; ++n3) t3[n3] > u2[n3] && (u2[n3] = t3[n3], c2.data[n3] = e5);
            }
            const p2 = new Array(i2.dims[0]), d2 = c2.data;
            for (let e5 = 0; e5 < d2.length; ++e5) {
              const t3 = d2[e5];
              p2[t3] = t3;
            }
            const _2 = p2.filter(((e5) => void 0 !== e5));
            o2.push({ segmentation: c2, labels: _2 });
          }
          return o2;
        }
      }
      class m extends h {
      }
      class g extends m {
      }
      class b extends h {
      }
      class w extends h {
      }
      class x extends h {
      }
      class y extends h {
      }
      class T extends h {
      }
      class v extends h {
        constructor(e3) {
          super(e3), this.crop_pct = this.config.crop_pct ?? 0.875;
        }
        async resize(e3) {
          const t2 = this.size?.shortest_edge;
          if (void 0 === t2) throw new Error("Size dictionary must contain 'shortest_edge' key.");
          if (t2 < 384) {
            const n2 = Math.floor(t2 / this.crop_pct), [r2, o2] = this.get_resize_output_image_size(e3, { shortest_edge: n2 });
            e3 = await e3.resize(r2, o2, { resample: this.resample }), e3 = await e3.center_crop(t2, t2);
          } else e3 = await e3.resize(t2, t2, { resample: this.resample });
          return e3;
        }
      }
      class k extends v {
      }
      class M extends h {
      }
      class S extends h {
      }
      class P extends h {
        constructor(e3) {
          super(e3), this.include_top = this.config.include_top ?? true, this.include_top && (this.image_std = this.image_std.map(((e4) => e4 * e4)));
        }
      }
      class A extends h {
      }
      class F extends h {
        post_process_object_detection(...e3) {
          return c(...e3);
        }
      }
      class C extends F {
      }
      class E extends h {
      }
      class O extends h {
      }
      class I extends h {
        pad_image(e3, t2, n2, r2 = {}) {
          const [o2, i2, s2] = t2;
          let a2 = this.image_mean;
          Array.isArray(this.image_mean) || (a2 = new Array(s2).fill(a2));
          let l2 = this.image_std;
          Array.isArray(l2) || (l2 = new Array(s2).fill(a2));
          const c2 = a2.map(((e4, t3) => -e4 / l2[t3]));
          return super.pad_image(e3, t2, n2, { center: true, constant_values: c2, ...r2 });
        }
      }
      class D extends I {
      }
      class L extends h {
        async _call(e3) {
          const t2 = await super._call(e3), n2 = [t2.pixel_values.dims[0], 64, 64], r2 = new s.Tensor("int64", new BigInt64Array(n2.reduce(((e4, t3) => e4 * t3))).fill(1n), n2);
          return { ...t2, pixel_mask: r2 };
        }
        post_process_object_detection(...e3) {
          return c(...e3);
        }
        remove_low_and_no_objects(e3, t2, n2, r2) {
          let o2 = [], s2 = [], a2 = [];
          for (let l2 = 0; l2 < e3.dims[0]; ++l2) {
            let c2 = e3[l2], u2 = t2[l2], p2 = (0, i.max)(c2.data)[1];
            if (p2 === r2) continue;
            let d2 = (0, i.softmax)(c2.data)[p2];
            d2 > n2 && (o2.push(u2), s2.push(d2), a2.push(p2));
          }
          return [o2, s2, a2];
        }
        check_segment_validity(e3, t2, n2, r2 = 0.5, o2 = 0.8) {
          let i2 = [], s2 = 0, a2 = 0;
          for (let o3 = 0; o3 < e3.length; ++o3) e3[o3] === n2 && (i2.push(o3), ++s2), t2[n2].data[o3] >= r2 && ++a2;
          let l2 = s2 > 0 && a2 > 0;
          if (l2) {
            l2 = s2 / a2 > o2;
          }
          return [l2, i2];
        }
        compute_segments(e3, t2, n2, r2, o2, i2 = null, a2 = null) {
          let [l2, c2] = a2 ?? e3[0].dims, u2 = new s.Tensor("int32", new Int32Array(l2 * c2), [l2, c2]), p2 = [];
          if (null !== a2) for (let t3 = 0; t3 < e3.length; ++t3) e3[t3] = (0, s.interpolate)(e3[t3], a2, "bilinear", false);
          let d2 = new Int32Array(e3[0].data.length), _2 = new Float32Array(e3[0].data.length);
          for (let n3 = 0; n3 < e3.length; ++n3) {
            let r3 = t2[n3];
            for (let t3 = 0; t3 < e3[n3].data.length; ++t3) e3[n3].data[t3] *= r3, e3[n3].data[t3] > _2[t3] && (d2[t3] = n3, _2[t3] = e3[n3].data[t3]);
          }
          let h2 = 0;
          for (let i3 = 0; i3 < n2.length; ++i3) {
            let s2 = n2[i3], [a3, l3] = this.check_segment_validity(d2, e3, i3, r2, o2);
            if (a3) {
              ++h2;
              for (let e4 of l3) u2.data[e4] = h2;
              p2.push({ id: h2, label_id: s2, score: t2[i3] });
            }
          }
          return [u2, p2];
        }
        post_process_panoptic_segmentation(e3, t2 = 0.5, n2 = 0.5, r2 = 0.8, o2 = null, i2 = null) {
          null === o2 && (console.warn("`label_ids_to_fuse` unset. No instance will be fused."), o2 = /* @__PURE__ */ new Set());
          const a2 = e3.logits, l2 = e3.pred_masks.sigmoid();
          let [c2, u2, p2] = a2.dims;
          if (p2 -= 1, null !== i2 && i2.length !== c2) throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
          let d2 = [];
          for (let e4 = 0; e4 < c2; ++e4) {
            let c3 = null !== i2 ? i2[e4] : null, u3 = a2[e4], _2 = l2[e4], [h2, f2, m2] = this.remove_low_and_no_objects(u3, _2, t2, p2);
            if (0 === m2.length) {
              let [e5, t3] = c3 ?? _2.dims.slice(-2), n3 = new s.Tensor("int32", new Int32Array(e5 * t3).fill(-1), [e5, t3]);
              d2.push({ segmentation: n3, segments_info: [] });
              continue;
            }
            let [g2, b2] = this.compute_segments(h2, f2, m2, n2, r2, o2, c3);
            d2.push({ segmentation: g2, segments_info: b2 });
          }
          return d2;
        }
        post_process_instance_segmentation() {
          throw Error("Not implemented yet");
        }
      }
      class $ extends h {
        post_process_object_detection(...e3) {
          return c(...e3);
        }
      }
      class N extends h {
        reshape_input_points(e3, t2, n2) {
          e3 = structuredClone(e3);
          let o2 = (0, r.calculateDimensions)(e3);
          if (3 === o2.length) o2 = [1, ...o2], e3 = [e3];
          else if (4 !== o2.length) throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");
          for (let r2 = 0; r2 < e3.length; ++r2) {
            let o3 = t2[r2], i2 = n2[r2], s2 = [i2[0] / o3[0], i2[1] / o3[1]];
            for (let t3 = 0; t3 < e3[r2].length; ++t3) for (let n3 = 0; n3 < e3[r2][t3].length; ++n3) for (let o4 = 0; o4 < e3[r2][t3][n3].length; ++o4) e3[r2][t3][n3][o4] *= s2[o4];
          }
          return new s.Tensor("float32", Float32Array.from(e3.flat(1 / 0)), o2);
        }
        add_input_labels(e3, t2) {
          let n2 = (0, r.calculateDimensions)(e3);
          if (2 === n2.length) n2 = [1, ...n2], e3 = [e3];
          else if (3 !== n2.length) throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");
          if (n2.some(((e4, n3) => e4 !== t2.dims[n3]))) throw Error(`The first ${n2.length} dimensions of 'input_points' and 'input_labels' must be the same.`);
          return new s.Tensor("int64", e3.flat(1 / 0).map(BigInt), n2);
        }
        async _call(e3, t2 = null, n2 = null) {
          const r2 = await super._call(e3);
          if (t2 && (r2.input_points = this.reshape_input_points(t2, r2.original_sizes, r2.reshaped_input_sizes)), n2) {
            if (!r2.input_points) throw Error("`input_points` must be provided if `input_labels` are provided.");
            r2.input_labels = this.add_input_labels(n2, r2.input_points);
          }
          return r2;
        }
        post_process_masks(e3, t2, n2, { mask_threshold: r2 = 0, binarize: o2 = true, pad_size: i2 = null } = {}) {
          const a2 = [], l2 = [(i2 = i2 ?? this.pad_size).height, i2.width];
          for (let i3 = 0; i3 < t2.length; ++i3) {
            const c2 = t2[i3], u2 = n2[i3], p2 = e3[i3], d2 = [];
            for (let e4 = 0; e4 < p2.dims[0]; ++e4) {
              const t3 = p2[e4];
              let n3 = (0, s.interpolate)(t3, l2, "bilinear", false);
              if (n3 = n3.slice(null, [0, u2[0]], [0, u2[1]]), n3 = (0, s.interpolate)(n3, c2, "bilinear", false), o2) {
                const e5 = new Uint8Array(n3.data.length);
                for (let t4 = 0; t4 < n3.data.length; ++t4) n3.data[t4] > r2 && (e5[t4] = 1);
                n3 = new s.Tensor("bool", e5, n3.dims);
              }
              d2.push(n3);
            }
            a2.push((0, s.stack)(d2));
          }
          return a2;
        }
      }
      class B extends h {
        pad_image(e3, t2, n2, r2 = {}) {
          const [o2, i2, s2] = t2;
          return super.pad_image(e3, t2, { width: i2 + (n2 - i2 % n2) % n2, height: o2 + (n2 - o2 % n2) % n2 }, { mode: "symmetric", center: false, constant_values: -1, ...r2 });
        }
      }
      class z extends h {
        async _call(e3, t2) {
          Array.isArray(e3) || (e3 = [e3]), Array.isArray(t2) || (t2 = [t2]);
          const n2 = await Promise.all(e3.map(((e4) => this.preprocess(e4)))), r2 = await Promise.all(t2.map(((e4) => this.preprocess(e4, { do_normalize: false, do_convert_rgb: false, do_convert_grayscale: true }))));
          return { pixel_values: (0, s.stack)(n2.map(((e4, t3) => (0, s.cat)([e4.pixel_values, r2[t3].pixel_values], 0))), 0), original_sizes: n2.map(((e4) => e4.original_size)), reshaped_input_sizes: n2.map(((e4) => e4.reshaped_input_size)) };
        }
      }
      class R extends _ {
        constructor(e3) {
          super(e3), this.config.mel_filters ??= (0, a.mel_filter_bank)(Math.floor(1 + this.config.n_fft / 2), this.config.feature_size, 0, 8e3, this.config.sampling_rate, "slaney", "slaney"), this.window = (0, a.window_function)(this.config.n_fft, "hann");
        }
        _extract_fbank_features(e3) {
          const { data: t2, dims: n2 } = (0, a.spectrogram)(e3, this.window, this.config.n_fft, this.config.hop_length, { power: 2, mel_filters: this.config.mel_filters, log_mel: "log10", max_num_frames: this.config.nb_max_frames }), r2 = (0, i.max)(t2)[0];
          for (let e4 = 0; e4 < t2.length; ++e4) t2[e4] = (Math.max(t2[e4], r2 - 8) + 4) / 4;
          return { data: t2, dims: n2 };
        }
        async _call(e3) {
          let t2;
          u(e3, "WhisperFeatureExtractor"), e3.length > this.config.n_samples ? (console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."), t2 = e3.slice(0, this.config.n_samples)) : (t2 = new Float32Array(this.config.n_samples), t2.set(e3));
          const { data: n2, dims: r2 } = this._extract_fbank_features(t2);
          return { input_features: new s.Tensor("float32", n2, [1, ...r2]) };
        }
      }
      class j extends _ {
        _zero_mean_unit_var_norm(e3) {
          const t2 = e3.reduce(((e4, t3) => e4 + t3), 0) / e3.length, n2 = e3.reduce(((e4, n3) => e4 + (n3 - t2) ** 2), 0) / e3.length;
          return e3.map(((e4) => (e4 - t2) / Math.sqrt(n2 + 1e-7)));
        }
        async _call(e3) {
          u(e3, "Wav2Vec2FeatureExtractor"), e3 instanceof Float64Array && (e3 = new Float32Array(e3));
          let t2 = e3;
          this.config.do_normalize && (t2 = this._zero_mean_unit_var_norm(t2));
          const n2 = [1, t2.length];
          return { input_values: new s.Tensor("float32", t2, n2), attention_mask: new s.Tensor("int64", new BigInt64Array(t2.length).fill(1n), n2) };
        }
      }
      class V extends _ {
        constructor(e3) {
          super(e3);
          const t2 = this.config.sampling_rate, n2 = (0, a.mel_filter_bank)(256, this.config.num_mel_bins, 20, Math.floor(t2 / 2), t2, null, "kaldi", true);
          for (let e4 = 0; e4 < n2.length; ++e4) n2[e4].push(0);
          this.mel_filters = n2, this.window = (0, a.window_function)(400, "povey", { periodic: false });
        }
        _extract_fbank_features(e3, t2) {
          return e3 = e3.map(((e4) => 32768 * e4)), (0, a.spectrogram)(e3, this.window, 400, 160, { fft_length: 512, power: 2, center: false, preemphasis: 0.97, mel_filters: this.mel_filters, log_mel: "log", mel_floor: 1192092955078125e-22, remove_dc_offset: true, max_num_frames: t2, transpose: true });
        }
        async _call(e3, { padding: t2 = true, pad_to_multiple_of: n2 = 2, do_normalize_per_mel_bins: r2 = true, return_attention_mask: o2 = true } = {}) {
          u(e3, "SeamlessM4TFeatureExtractor");
          let i2, a2 = this._extract_fbank_features(e3, this.config.max_length);
          if (r2) {
            const [e4, t3] = a2.dims;
            for (let n3 = 0; n3 < t3; ++n3) {
              let r3 = 0;
              for (let o4 = 0; o4 < e4; ++o4) r3 += a2.data[o4 * t3 + n3];
              const o3 = r3 / e4;
              let i3 = 0;
              for (let r4 = 0; r4 < e4; ++r4) i3 += (a2.data[r4 * t3 + n3] - o3) ** 2;
              i3 /= e4 - 1;
              const s2 = Math.sqrt(i3 + 1e-7);
              for (let r4 = 0; r4 < e4; ++r4) {
                const e5 = r4 * t3 + n3;
                a2.data[e5] = (a2.data[e5] - o3) / s2;
              }
            }
          }
          if (t2) {
            const [e4, t3] = a2.dims, r3 = e4 % n2;
            if (r3 > 0) {
              const n3 = new Float32Array(t3 * (e4 + r3));
              n3.set(a2.data), n3.fill(this.config.padding_value, a2.data.length);
              const l3 = e4 + r3;
              a2 = { data: n3, dims: [l3, t3] }, o2 && (i2 = new s.Tensor("int64", new BigInt64Array(l3), [1, l3]), i2.data.fill(1n, 0, e4));
            }
          }
          const [l2, c2] = a2.dims, p2 = this.config.stride;
          if (0 !== l2 % p2) throw new Error(`The number of frames (${l2}) must be a multiple of the stride (${p2}).`);
          const d2 = new s.Tensor("float32", a2.data, a2.dims).view(1, Math.floor(l2 / p2), c2 * p2), _2 = { input_features: d2 };
          if (o2) {
            const e4 = d2.dims[1], t3 = new s.Tensor("int64", new BigInt64Array(e4), [1, e4]);
            if (i2) for (let e5 = 1, n3 = 0; e5 < l2; e5 += p2, ++n3) t3.data[n3] = i2.data[e5];
            else t3.data.fill(1n);
            _2.attention_mask = t3;
          }
          return _2;
        }
      }
      class U extends _ {
        constructor(e3) {
          super(e3);
          const t2 = this.config.sampling_rate, n2 = (0, a.mel_filter_bank)(256, this.config.num_mel_bins, 20, Math.floor(t2 / 2), t2, null, "kaldi", true);
          for (let e4 = 0; e4 < n2.length; ++e4) n2[e4].push(0);
          this.mel_filters = n2, this.window = (0, a.window_function)(400, "hann", { periodic: false }), this.mean = this.config.mean, this.std = this.config.std;
        }
        _extract_fbank_features(e3, t2) {
          return (0, a.spectrogram)(e3, this.window, 400, 160, { fft_length: 512, power: 2, center: false, preemphasis: 0.97, mel_filters: this.mel_filters, log_mel: "log", mel_floor: 1192092955078125e-22, remove_dc_offset: true, max_num_frames: t2, transpose: true });
        }
        async _call(e3) {
          u(e3, "ASTFeatureExtractor");
          const t2 = this._extract_fbank_features(e3, this.config.max_length);
          if (this.config.do_normalize) {
            const e4 = 2 * this.std;
            for (let n2 = 0; n2 < t2.data.length; ++n2) t2.data[n2] = (t2.data[n2] - this.mean) / e4;
          }
          return { input_values: new s.Tensor("float32", t2.data, [1, ...t2.dims]) };
        }
      }
      class G extends _ {
        constructor(e3) {
          super(e3), this.mel_filters = (0, a.mel_filter_bank)(this.config.nb_frequency_bins, this.config.feature_size, this.config.frequency_min, this.config.frequency_max, this.config.sampling_rate, null, "htk"), this.mel_filters_slaney = (0, a.mel_filter_bank)(this.config.nb_frequency_bins, this.config.feature_size, this.config.frequency_min, this.config.frequency_max, this.config.sampling_rate, "slaney", "slaney"), this.window = (0, a.window_function)(this.config.fft_window_size, "hann");
        }
        _get_input_mel(e3, t2, n2, r2) {
          let o2, i2 = false;
          const s2 = e3.length - t2;
          if (s2 > 0) {
            if ("rand_trunc" !== n2) throw new Error(`Truncation strategy "${n2}" not implemented`);
            {
              i2 = true;
              const n3 = Math.floor(Math.random() * (s2 + 1));
              e3 = e3.subarray(n3, n3 + t2), o2 = this._extract_fbank_features(e3, this.mel_filters_slaney, this.config.nb_max_samples), o2.dims = [1, ...o2.dims];
            }
          } else {
            if (s2 < 0) {
              let n3 = new Float64Array(t2);
              if (n3.set(e3), "repeat" === r2) for (let r3 = e3.length; r3 < t2; r3 += e3.length) n3.set(e3.subarray(0, Math.min(e3.length, t2 - r3)), r3);
              else if ("repeatpad" === r2) for (let t3 = e3.length; t3 < -s2; t3 += e3.length) n3.set(e3, t3);
              e3 = n3;
            }
            if ("fusion" === n2) throw new Error(`Truncation strategy "${n2}" not implemented`);
            o2 = this._extract_fbank_features(e3, this.mel_filters_slaney, this.config.nb_max_samples), o2.dims = [1, ...o2.dims];
          }
          return { ...o2, longer: i2 };
        }
        _extract_fbank_features(e3, t2, n2 = null) {
          return (0, a.spectrogram)(e3, this.window, this.config.fft_window_size, this.config.hop_length, { power: 2, mel_filters: t2, log_mel: "dB", max_num_frames: n2, do_pad: false, transpose: true });
        }
        async _call(e3, { max_length: t2 = null } = {}) {
          u(e3, "ClapFeatureExtractor");
          const n2 = this._get_input_mel(e3, t2 ?? this.config.nb_max_samples, this.config.truncation, this.config.padding);
          return { input_features: new s.Tensor("float32", n2.data, [1, ...n2.dims]) };
        }
      }
      class q extends _ {
      }
      class W extends r.Callable {
        constructor(e3) {
          super(), this.feature_extractor = e3;
        }
        async _call(e3, ...t2) {
          return await this.feature_extractor(e3, ...t2);
        }
      }
      class H extends W {
        async _call(...e3) {
          return await this.feature_extractor(...e3);
        }
        post_process_masks(...e3) {
          return this.feature_extractor.post_process_masks(...e3);
        }
        reshape_input_points(...e3) {
          return this.feature_extractor.reshape_input_points(...e3);
        }
      }
      class X extends W {
        async _call(e3) {
          return await this.feature_extractor(e3);
        }
      }
      class Q extends W {
        async _call(e3) {
          return await this.feature_extractor(e3);
        }
      }
      class Y extends W {
        async _call(e3) {
          return await this.feature_extractor(e3);
        }
      }
      class K extends W {
      }
      class Z {
        static FEATURE_EXTRACTOR_CLASS_MAPPING = { ImageFeatureExtractor: h, WhisperFeatureExtractor: R, ViTFeatureExtractor: M, MobileViTFeatureExtractor: A, OwlViTFeatureExtractor: F, Owlv2ImageProcessor: C, CLIPFeatureExtractor: x, ChineseCLIPFeatureExtractor: y, SiglipImageProcessor: T, ConvNextFeatureExtractor: v, ConvNextImageProcessor: k, SegformerFeatureExtractor: f, BitImageProcessor: b, DPTImageProcessor: g, DPTFeatureExtractor: m, GLPNFeatureExtractor: w, BeitFeatureExtractor: O, DeiTFeatureExtractor: E, DetrFeatureExtractor: L, YolosFeatureExtractor: $, DonutFeatureExtractor: I, NougatImageProcessor: D, EfficientNetImageProcessor: P, ViTImageProcessor: S, VitMatteImageProcessor: z, SamImageProcessor: N, Swin2SRImageProcessor: B, Wav2Vec2FeatureExtractor: j, SeamlessM4TFeatureExtractor: V, SpeechT5FeatureExtractor: q, ASTFeatureExtractor: U, ClapFeatureExtractor: G };
        static PROCESSOR_CLASS_MAPPING = { WhisperProcessor: X, Wav2Vec2ProcessorWithLM: Q, SamProcessor: H, SpeechT5Processor: Y, OwlViTProcessor: K };
        static async from_pretrained(e3, { progress_callback: t2 = null, config: n2 = null, cache_dir: r2 = null, local_files_only: i2 = false, revision: s2 = "main" } = {}) {
          let a2 = n2 ?? await (0, o.getModelJSON)(e3, "preprocessor_config.json", true, { progress_callback: t2, config: n2, cache_dir: r2, local_files_only: i2, revision: s2 }), l2 = a2.feature_extractor_type ?? a2.image_processor_type, c2 = this.FEATURE_EXTRACTOR_CLASS_MAPPING[l2];
          if (!c2) {
            if (void 0 === a2.size) throw new Error(`Unknown Feature Extractor type: ${l2}`);
            console.warn(`Feature extractor type "${l2}" not found, assuming ImageFeatureExtractor due to size parameter in config.`), c2 = h;
          }
          return new (this.PROCESSOR_CLASS_MAPPING[a2.processor_class] ?? W)(new c2(a2));
        }
      }
    }
  ), "./src/tokenizers.js": (
    /*!***************************!*\
      !*** ./src/tokenizers.js ***!
      \***************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { AlbertTokenizer: () => me, AutoTokenizer: () => ut, BartTokenizer: () => Ce, BertTokenizer: () => fe, BlenderbotSmallTokenizer: () => it, BlenderbotTokenizer: () => ot, BloomTokenizer: () => De, CLIPTokenizer: () => et, CamembertTokenizer: () => Me, CodeGenTokenizer: () => Je, CodeLlamaTokenizer: () => Ne, CohereTokenizer: () => ct, ConvBertTokenizer: () => Te, DebertaTokenizer: () => we, DebertaV2Tokenizer: () => xe, DistilBertTokenizer: () => ke, ElectraTokenizer: () => Pe, EsmTokenizer: () => Ve, FalconTokenizer: () => Re, GPT2Tokenizer: () => Fe, GPTNeoXTokenizer: () => je, GemmaTokenizer: () => Ge, Grok1Tokenizer: () => qe, HerbertTokenizer: () => ye, LlamaTokenizer: () => $e, M2M100Tokenizer: () => Xe, MBart50Tokenizer: () => Oe, MBartTokenizer: () => Ee, MPNetTokenizer: () => ze, MarianTokenizer: () => nt, MobileBertTokenizer: () => ge, NllbTokenizer: () => He, NougatTokenizer: () => at, PreTrainedTokenizer: () => he, Qwen2Tokenizer: () => Ue, RoFormerTokenizer: () => ve, RobertaTokenizer: () => Ie, SiglipTokenizer: () => tt, SpeechT5Tokenizer: () => st, SqueezeBertTokenizer: () => be, T5Tokenizer: () => Ae, TokenizerModel: () => b, VitsTokenizer: () => lt, Wav2Vec2CTCTokenizer: () => rt, WhisperTokenizer: () => Ze, XLMRobertaTokenizer: () => Be, XLMTokenizer: () => Se });
      var r = n(
        /*! ./utils/core.js */
        "./src/utils/core.js"
      ), o = n(
        /*! ./utils/hub.js */
        "./src/utils/hub.js"
      ), i = n(
        /*! ./utils/maths.js */
        "./src/utils/maths.js"
      ), s = n(
        /*! ./utils/tensor.js */
        "./src/utils/tensor.js"
      ), a = n(
        /*! ./utils/data-structures.js */
        "./src/utils/data-structures.js"
      ), l = n(
        /*! @huggingface/jinja */
        "./node_modules/@huggingface/jinja/dist/index.js"
      );
      async function c(e3, t2) {
        const n2 = await Promise.all([(0, o.getModelJSON)(e3, "tokenizer.json", true, t2), (0, o.getModelJSON)(e3, "tokenizer_config.json", true, t2)]);
        return null !== t2.legacy && (n2[1].legacy = t2.legacy), n2;
      }
      function u(e3, t2 = true) {
        if (void 0 !== e3.Regex) {
          let t3 = e3.Regex.replace(/\\([#&~])/g, "$1");
          for (const [e4, n2] of m) t3 = t3.replaceAll(e4, n2);
          return new RegExp(t3, "gu");
        }
        if (void 0 !== e3.String) {
          const n2 = (0, r.escapeRegExp)(e3.String);
          return new RegExp(t2 ? n2 : `(${n2})`, "gu");
        }
        return console.warn("Unknown pattern type:", e3), null;
      }
      function p(e3) {
        return new Map(Object.entries(e3));
      }
      function d(e3) {
        const t2 = e3.dims;
        switch (t2.length) {
          case 1:
            return e3.tolist();
          case 2:
            if (1 !== t2[0]) throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");
            return e3.tolist()[0];
          default:
            throw new Error(`Expected tensor to have 1-2 dimensions, got ${t2.length}.`);
        }
      }
      function _(e3) {
        return e3.replace(/ \./g, ".").replace(/ \?/g, "?").replace(/ \!/g, "!").replace(/ ,/g, ",").replace(/ \' /g, "'").replace(/ n\'t/g, "n't").replace(/ \'m/g, "'m").replace(/ \'s/g, "'s").replace(/ \'ve/g, "'ve").replace(/ \'re/g, "'re");
      }
      function h(e3) {
        return e3.replace(/[\u0300-\u036f]/g, "");
      }
      const f = "\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E", m = /* @__PURE__ */ new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)", "(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);
      class g {
        constructor(e3) {
          this.content = e3.content, this.id = e3.id, this.single_word = e3.single_word ?? false, this.lstrip = e3.lstrip ?? false, this.rstrip = e3.rstrip ?? false, this.special = e3.special ?? false, this.normalized = e3.normalized ?? null;
        }
      }
      class b extends r.Callable {
        constructor(e3) {
          super(), this.config = e3, this.vocab = [], this.tokens_to_ids = /* @__PURE__ */ new Map(), this.unk_token_id = void 0, this.unk_token = void 0, this.end_of_word_suffix = void 0, this.fuse_unk = this.config.fuse_unk ?? false;
        }
        static fromConfig(e3, ...t2) {
          switch (e3.type) {
            case "WordPiece":
              return new w(e3);
            case "Unigram":
              return new x(e3, ...t2);
            case "BPE":
              return new v(e3);
            default:
              if (e3.vocab) return new k(e3, ...t2);
              throw new Error(`Unknown TokenizerModel type: ${e3.type}`);
          }
        }
        _call(e3) {
          let t2 = this.encode(e3);
          return this.fuse_unk && (t2 = (function(e4, t3, n2) {
            const r2 = [];
            let o2 = 0;
            for (; o2 < e4.length; ) if (r2.push(e4[o2]), (n2.get(e4[o2]) ?? t3) === t3) for (; o2 < e4.length && (n2.get(e4[o2]) ?? t3) === t3; ) ++o2;
            else ++o2;
            return r2;
          })(t2, this.unk_token_id, this.tokens_to_ids)), t2;
        }
        encode(e3) {
          throw Error("encode should be implemented in subclass.");
        }
        convert_tokens_to_ids(e3) {
          return e3.map(((e4) => this.tokens_to_ids.get(e4) ?? this.unk_token_id));
        }
        convert_ids_to_tokens(e3) {
          return e3.map(((e4) => this.vocab[e4] ?? this.unk_token));
        }
      }
      class w extends b {
        constructor(e3) {
          super(e3), this.tokens_to_ids = p(e3.vocab), this.unk_token_id = this.tokens_to_ids.get(e3.unk_token), this.unk_token = e3.unk_token, this.max_input_chars_per_word = e3.max_input_chars_per_word ?? 100, this.vocab = new Array(this.tokens_to_ids.size);
          for (const [e4, t2] of this.tokens_to_ids) this.vocab[t2] = e4;
        }
        encode(e3) {
          const t2 = [];
          for (const n2 of e3) {
            const e4 = [...n2];
            if (e4.length > this.max_input_chars_per_word) {
              t2.push(this.unk_token);
              continue;
            }
            let r2 = false, o2 = 0;
            const i2 = [];
            for (; o2 < e4.length; ) {
              let t3 = e4.length, n3 = null;
              for (; o2 < t3; ) {
                let r3 = e4.slice(o2, t3).join("");
                if (o2 > 0 && (r3 = this.config.continuing_subword_prefix + r3), this.tokens_to_ids.has(r3)) {
                  n3 = r3;
                  break;
                }
                --t3;
              }
              if (null === n3) {
                r2 = true;
                break;
              }
              i2.push(n3), o2 = t3;
            }
            r2 ? t2.push(this.unk_token) : t2.push(...i2);
          }
          return t2;
        }
      }
      class x extends b {
        constructor(e3, t2) {
          super(e3);
          const n2 = e3.vocab.length;
          this.vocab = new Array(n2), this.scores = new Array(n2);
          for (let t3 = 0; t3 < n2; ++t3) {
            const n3 = e3.vocab[t3];
            this.vocab[t3] = n3[0], this.scores[t3] = n3[1];
          }
          this.unk_token_id = e3.unk_id, this.unk_token = this.vocab[e3.unk_id], this.tokens_to_ids = new Map(this.vocab.map(((e4, t3) => [e4, t3]))), this.bosToken = " ", this.bosTokenId = this.tokens_to_ids.get(this.bosToken), this.eosToken = t2.eos_token, this.eosTokenId = this.tokens_to_ids.get(this.eosToken), this.unkToken = this.vocab[this.unk_token_id], this.minScore = (0, i.min)(this.scores)[0], this.unkScore = this.minScore - 10, this.scores[this.unk_token_id] = this.unkScore, this.trie = new a.CharTrie(), this.trie.extend(this.vocab), this.fuse_unk = true;
        }
        populateNodes(e3) {
          const t2 = e3.sentence, n2 = t2.length;
          let r2 = 0;
          for (; r2 < n2; ) {
            const n3 = 1;
            let o2 = false;
            const i2 = [];
            for (let s2 of this.trie.commonPrefixSearch(t2.slice(r2))) {
              i2.push(s2);
              const t3 = this.tokens_to_ids.get(s2), a2 = this.scores[t3], l2 = s2.length;
              e3.insert(r2, l2, a2, t3), o2 || l2 !== n3 || (o2 = true);
            }
            o2 || e3.insert(r2, n3, this.unkScore, this.unk_token_id), r2 += n3;
          }
        }
        tokenize(e3) {
          const t2 = new a.TokenLattice(e3, this.bosTokenId, this.eosTokenId);
          return this.populateNodes(t2), t2.tokens();
        }
        encode(e3) {
          const t2 = [];
          for (const n2 of e3) {
            const e4 = this.tokenize(n2);
            t2.push(...e4);
          }
          return t2;
        }
      }
      const y = (() => {
        const e3 = [...Array.from({ length: "~".charCodeAt(0) - "!".charCodeAt(0) + 1 }, ((e4, t3) => t3 + "!".charCodeAt(0))), ...Array.from({ length: "\xAC".charCodeAt(0) - "\xA1".charCodeAt(0) + 1 }, ((e4, t3) => t3 + "\xA1".charCodeAt(0))), ...Array.from({ length: "\xFF".charCodeAt(0) - "\xAE".charCodeAt(0) + 1 }, ((e4, t3) => t3 + "\xAE".charCodeAt(0)))], t2 = e3.slice();
        let n2 = 0;
        for (let r3 = 0; r3 < 256; ++r3) e3.includes(r3) || (e3.push(r3), t2.push(256 + n2), n2 += 1);
        const r2 = t2.map(((e4) => String.fromCharCode(e4)));
        return Object.fromEntries(e3.map(((e4, t3) => [e4, r2[t3]])));
      })(), T = (0, r.reverseDictionary)(y);
      class v extends b {
        constructor(e3) {
          super(e3), this.BPE_SPLIT_TOKEN = " ", this.tokens_to_ids = p(e3.vocab), this.unk_token_id = this.tokens_to_ids.get(e3.unk_token), this.unk_token = e3.unk_token, this.vocab = new Array(this.tokens_to_ids.size);
          for (const [e4, t2] of this.tokens_to_ids) this.vocab[t2] = e4;
          this.bpe_ranks = new Map(e3.merges.map(((e4, t2) => [e4, t2]))), this.merges = e3.merges.map(((e4) => e4.split(this.BPE_SPLIT_TOKEN))), this.end_of_word_suffix = e3.end_of_word_suffix, this.continuing_subword_suffix = e3.continuing_subword_suffix ?? null, this.byte_fallback = this.config.byte_fallback ?? false, this.byte_fallback && (this.text_encoder = new TextEncoder()), this.ignore_merges = this.config.ignore_merges ?? false, this.cache = /* @__PURE__ */ new Map();
        }
        bpe(e3) {
          if (0 === e3.length) return [];
          const t2 = this.cache.get(e3);
          if (void 0 !== t2) return t2;
          const n2 = Array.from(e3);
          this.end_of_word_suffix && (n2[n2.length - 1] += this.end_of_word_suffix);
          let r2 = [];
          if (n2.length > 1) {
            const e4 = new a.PriorityQueue(((e5, t4) => e5.score < t4.score));
            let t3 = { token: n2[0], bias: 0, prev: null, next: null }, o2 = t3;
            for (let t4 = 1; t4 < n2.length; ++t4) {
              const r3 = { bias: t4 / n2.length, token: n2[t4], prev: o2, next: null };
              o2.next = r3, this._add_node(e4, o2), o2 = r3;
            }
            for (; !e4.isEmpty(); ) {
              const n3 = e4.pop();
              if (n3.deleted || !n3.next || n3.next.deleted) continue;
              if (n3.deleted = true, n3.next.deleted = true, n3.prev) {
                const e5 = { ...n3.prev };
                n3.prev.deleted = true, n3.prev = e5, e5.prev ? e5.prev.next = e5 : t3 = e5;
              }
              const r3 = { token: n3.token + n3.next.token, bias: n3.bias, prev: n3.prev, next: n3.next.next };
              r3.prev ? (r3.prev.next = r3, this._add_node(e4, r3.prev)) : t3 = r3, r3.next && (r3.next.prev = r3, this._add_node(e4, r3));
            }
            for (let e5 = t3; null !== e5; e5 = e5.next) r2.push(e5.token);
          } else r2 = n2;
          if (this.continuing_subword_suffix) for (let e4 = 0; e4 < r2.length - 1; ++e4) r2[e4] += this.continuing_subword_suffix;
          return this.cache.set(e3, r2), r2;
        }
        _add_node(e3, t2) {
          const n2 = this.bpe_ranks.get(t2.token + this.BPE_SPLIT_TOKEN + t2.next.token);
          void 0 !== n2 && (t2.score = n2 + t2.bias, e3.push(t2));
        }
        encode(e3) {
          const t2 = [];
          for (const n2 of e3) {
            if (this.ignore_merges && this.tokens_to_ids.has(n2)) {
              t2.push(n2);
              continue;
            }
            const e4 = this.bpe(n2);
            for (const n3 of e4) this.tokens_to_ids.has(n3) ? t2.push(n3) : this.byte_fallback ? t2.push(...Array.from(this.text_encoder.encode(n3)).map(((e5) => `<0x${e5.toString(16).toUpperCase().padStart(2, "0")}>`))) : t2.push(this.unk_token);
          }
          return t2;
        }
      }
      class k extends b {
        constructor(e3, t2) {
          super(e3), this.tokens_to_ids = p(t2.target_lang ? e3.vocab[t2.target_lang] : e3.vocab), this.bos_token = t2.bos_token, this.bos_token_id = this.tokens_to_ids.get(this.bos_token), this.eos_token = t2.eos_token, this.eos_token_id = this.tokens_to_ids.get(this.eos_token), this.pad_token = t2.pad_token, this.pad_token_id = this.tokens_to_ids.get(this.pad_token), this.unk_token = t2.unk_token, this.unk_token_id = this.tokens_to_ids.get(this.unk_token), this.vocab = new Array(this.tokens_to_ids.size);
          for (const [e4, t3] of this.tokens_to_ids) this.vocab[t3] = e4;
        }
        encode(e3) {
          return e3;
        }
      }
      class M extends r.Callable {
        constructor(e3) {
          super(), this.config = e3;
        }
        static fromConfig(e3) {
          if (null === e3) return null;
          switch (e3.type) {
            case "BertNormalizer":
              return new L(e3);
            case "Precompiled":
              return new se(e3);
            case "Sequence":
              return new D(e3);
            case "Replace":
              return new S(e3);
            case "NFC":
              return new P(e3);
            case "NFKC":
              return new A(e3);
            case "NFKD":
              return new F(e3);
            case "Strip":
              return new C(e3);
            case "StripAccents":
              return new E(e3);
            case "Lowercase":
              return new O(e3);
            case "Prepend":
              return new I(e3);
            default:
              throw new Error(`Unknown Normalizer type: ${e3.type}`);
          }
        }
        normalize(e3) {
          throw Error("normalize should be implemented in subclass.");
        }
        _call(e3) {
          return this.normalize(e3);
        }
      }
      class S extends M {
        normalize(e3) {
          const t2 = u(this.config.pattern);
          return null === t2 ? e3 : e3.replaceAll(t2, this.config.content);
        }
      }
      class P extends M {
        normalize(e3) {
          return e3 = e3.normalize("NFC");
        }
      }
      class A extends M {
        normalize(e3) {
          return e3 = e3.normalize("NFKC");
        }
      }
      class F extends M {
        normalize(e3) {
          return e3 = e3.normalize("NFKD");
        }
      }
      class C extends M {
        normalize(e3) {
          return this.config.strip_left && this.config.strip_right ? e3 = e3.trim() : (this.config.strip_left && (e3 = e3.trimStart()), this.config.strip_right && (e3 = e3.trimEnd())), e3;
        }
      }
      class E extends M {
        normalize(e3) {
          return e3 = h(e3);
        }
      }
      class O extends M {
        normalize(e3) {
          return e3 = e3.toLowerCase();
        }
      }
      class I extends M {
        normalize(e3) {
          return e3 = this.config.prepend + e3;
        }
      }
      class D extends M {
        constructor(e3) {
          super(e3), this.normalizers = e3.normalizers.map(((e4) => M.fromConfig(e4)));
        }
        normalize(e3) {
          return this.normalizers.reduce(((e4, t2) => t2.normalize(e4)), e3);
        }
      }
      class L extends M {
        _tokenize_chinese_chars(e3) {
          const t2 = [];
          for (let n2 = 0; n2 < e3.length; ++n2) {
            const r2 = e3[n2], o2 = r2.charCodeAt(0);
            this._is_chinese_char(o2) ? (t2.push(" "), t2.push(r2), t2.push(" ")) : t2.push(r2);
          }
          return t2.join("");
        }
        _is_chinese_char(e3) {
          return e3 >= 19968 && e3 <= 40959 || e3 >= 13312 && e3 <= 19903 || e3 >= 131072 && e3 <= 173791 || e3 >= 173824 && e3 <= 177983 || e3 >= 177984 && e3 <= 178207 || e3 >= 178208 && e3 <= 183983 || e3 >= 63744 && e3 <= 64255 || e3 >= 194560 && e3 <= 195103;
        }
        stripAccents(e3) {
          return e3.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }
        _is_control(e3) {
          switch (e3) {
            case "	":
            case "\n":
            case "\r":
              return false;
            default:
              return /^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(e3);
          }
        }
        _clean_text(e3) {
          const t2 = [];
          for (const n2 of e3) {
            const e4 = n2.charCodeAt(0);
            0 === e4 || 65533 === e4 || this._is_control(n2) || (/^\s$/.test(n2) ? t2.push(" ") : t2.push(n2));
          }
          return t2.join("");
        }
        normalize(e3) {
          return this.config.clean_text && (e3 = this._clean_text(e3)), this.config.handle_chinese_chars && (e3 = this._tokenize_chinese_chars(e3)), this.config.lowercase ? (e3 = e3.toLowerCase(), false !== this.config.strip_accents && (e3 = this.stripAccents(e3))) : this.config.strip_accents && (e3 = this.stripAccents(e3)), e3;
        }
      }
      class $ extends r.Callable {
        static fromConfig(e3) {
          if (null === e3) return null;
          switch (e3.type) {
            case "BertPreTokenizer":
              return new N(e3);
            case "Sequence":
              return new ae(e3);
            case "Whitespace":
              return new le(e3);
            case "WhitespaceSplit":
              return new ce(e3);
            case "Metaspace":
              return new oe(e3);
            case "ByteLevel":
              return new B(e3);
            case "Split":
              return new z(e3);
            case "Punctuation":
              return new R(e3);
            case "Digits":
              return new j(e3);
            case "Replace":
              return new ue(e3);
            default:
              throw new Error(`Unknown PreTokenizer type: ${e3.type}`);
          }
        }
        pre_tokenize_text(e3, t2) {
          throw Error("pre_tokenize_text should be implemented in subclass.");
        }
        pre_tokenize(e3, t2) {
          return (Array.isArray(e3) ? e3.map(((e4) => this.pre_tokenize_text(e4, t2))) : this.pre_tokenize_text(e3, t2)).flat();
        }
        _call(e3, t2) {
          return this.pre_tokenize(e3, t2);
        }
      }
      class N extends $ {
        constructor(e3) {
          super(), this.pattern = new RegExp(`[^\\s${f}]+|[${f}]`, "gu");
        }
        pre_tokenize_text(e3, t2) {
          return e3.trim().match(this.pattern) || [];
        }
      }
      class B extends $ {
        constructor(e3) {
          super(), this.config = e3, this.add_prefix_space = this.config.add_prefix_space, this.trim_offsets = this.config.trim_offsets, this.use_regex = this.config.use_regex ?? true, this.pattern = /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu, this.byte_encoder = y, this.text_encoder = new TextEncoder();
        }
        pre_tokenize_text(e3, t2) {
          this.add_prefix_space && !e3.startsWith(" ") && (e3 = " " + e3);
          return (this.use_regex ? e3.match(this.pattern) || [] : [e3]).map(((e4) => Array.from(this.text_encoder.encode(e4), ((e5) => this.byte_encoder[e5])).join("")));
        }
      }
      class z extends $ {
        constructor(e3) {
          super(), this.config = e3, this.pattern = u(this.config.pattern, this.config.invert);
        }
        pre_tokenize_text(e3, t2) {
          return null === this.pattern ? [] : this.config.invert ? e3.match(this.pattern) || [] : (function(e4, t3) {
            const n2 = [];
            let r2 = 0;
            for (const o2 of e4.matchAll(t3)) {
              const t4 = o2[0];
              r2 < o2.index && n2.push(e4.slice(r2, o2.index)), t4.length > 0 && n2.push(t4), r2 = o2.index + t4.length;
            }
            return r2 < e4.length && n2.push(e4.slice(r2)), n2;
          })(e3, this.pattern);
        }
      }
      class R extends $ {
        constructor(e3) {
          super(), this.config = e3, this.pattern = new RegExp(`[^${f}]+|[${f}]+`, "gu");
        }
        pre_tokenize_text(e3, t2) {
          return e3.match(this.pattern) || [];
        }
      }
      class j extends $ {
        constructor(e3) {
          super(), this.config = e3;
          const t2 = "[^\\d]+|\\d" + (this.config.individual_digits ? "" : "+");
          this.pattern = new RegExp(t2, "gu");
        }
        pre_tokenize_text(e3, t2) {
          return e3.match(this.pattern) || [];
        }
      }
      class V extends r.Callable {
        constructor(e3) {
          super(), this.config = e3;
        }
        static fromConfig(e3) {
          if (null === e3) return null;
          switch (e3.type) {
            case "TemplateProcessing":
              return new q(e3);
            case "ByteLevel":
              return new W(e3);
            case "RobertaProcessing":
              return new G(e3);
            case "BertProcessing":
              return new U(e3);
            default:
              throw new Error(`Unknown PostProcessor type: ${e3.type}`);
          }
        }
        post_process(e3, ...t2) {
          throw Error("post_process should be implemented in subclass.");
        }
        _call(e3, ...t2) {
          return this.post_process(e3, ...t2);
        }
      }
      class U extends V {
        constructor(e3) {
          super(e3), this.cls = e3.cls[0], this.sep = e3.sep[0];
        }
        post_process(e3, t2 = null, { add_special_tokens: n2 = true } = {}) {
          n2 && (e3 = (0, r.mergeArrays)([this.cls], e3, [this.sep]));
          let o2 = new Array(e3.length).fill(0);
          if (null !== t2) {
            const i2 = n2 && this instanceof G ? [this.sep] : [], s2 = n2 ? [this.sep] : [];
            e3 = (0, r.mergeArrays)(e3, i2, t2, s2), o2 = (0, r.mergeArrays)(o2, new Array(t2.length + i2.length + s2.length).fill(1));
          }
          return { tokens: e3, token_type_ids: o2 };
        }
      }
      class G extends U {
      }
      class q extends V {
        constructor(e3) {
          super(e3), this.single = e3.single, this.pair = e3.pair;
        }
        post_process(e3, t2 = null, { add_special_tokens: n2 = true } = {}) {
          const o2 = null === t2 ? this.single : this.pair;
          let i2 = [], s2 = [];
          for (const a2 of o2) "SpecialToken" in a2 ? n2 && (i2.push(a2.SpecialToken.id), s2.push(a2.SpecialToken.type_id)) : "Sequence" in a2 && ("A" === a2.Sequence.id ? (i2 = (0, r.mergeArrays)(i2, e3), s2 = (0, r.mergeArrays)(s2, new Array(e3.length).fill(a2.Sequence.type_id))) : "B" === a2.Sequence.id && (i2 = (0, r.mergeArrays)(i2, t2), s2 = (0, r.mergeArrays)(s2, new Array(t2.length).fill(a2.Sequence.type_id))));
          return { tokens: i2, token_type_ids: s2 };
        }
      }
      class W extends V {
        post_process(e3, t2 = null) {
          return t2 && (e3 = (0, r.mergeArrays)(e3, t2)), { tokens: e3 };
        }
      }
      class H extends r.Callable {
        constructor(e3) {
          super(), this.config = e3, this.added_tokens = [], this.end_of_word_suffix = null, this.trim_offsets = e3.trim_offsets;
        }
        static fromConfig(e3) {
          if (null === e3) return null;
          switch (e3.type) {
            case "WordPiece":
              return new Z(e3);
            case "Metaspace":
              return new ie(e3);
            case "ByteLevel":
              return new J(e3);
            case "Replace":
              return new X(e3);
            case "ByteFallback":
              return new Q(e3);
            case "Fuse":
              return new Y(e3);
            case "Strip":
              return new K(e3);
            case "Sequence":
              return new te(e3);
            case "CTC":
              return new ee(e3);
            case "BPEDecoder":
              return new ne(e3);
            default:
              throw new Error(`Unknown Decoder type: ${e3.type}`);
          }
        }
        _call(e3) {
          return this.decode(e3);
        }
        decode(e3) {
          return this.decode_chain(e3).join("");
        }
        decode_chain(e3) {
          throw Error("`decode_chain` should be implemented in subclass.");
        }
      }
      class X extends H {
        decode_chain(e3) {
          const t2 = u(this.config.pattern);
          return null === t2 ? e3 : e3.map(((e4) => e4.replaceAll(t2, this.config.content)));
        }
      }
      class Q extends H {
        constructor(e3) {
          super(e3), this.text_decoder = new TextDecoder();
        }
        decode_chain(e3) {
          const t2 = [];
          let n2 = [];
          for (const r2 of e3) {
            let e4 = null;
            if (6 === r2.length && r2.startsWith("<0x") && r2.endsWith(">")) {
              const t3 = parseInt(r2.slice(3, 5), 16);
              isNaN(t3) || (e4 = t3);
            }
            if (null !== e4) n2.push(e4);
            else {
              if (n2.length > 0) {
                const e5 = this.text_decoder.decode(Uint8Array.from(n2));
                t2.push(e5), n2 = [];
              }
              t2.push(r2);
            }
          }
          if (n2.length > 0) {
            const e4 = this.text_decoder.decode(Uint8Array.from(n2));
            t2.push(e4), n2 = [];
          }
          return t2;
        }
      }
      class Y extends H {
        decode_chain(e3) {
          return [e3.join("")];
        }
      }
      class K extends H {
        constructor(e3) {
          super(e3), this.content = this.config.content, this.start = this.config.start, this.stop = this.config.stop;
        }
        decode_chain(e3) {
          return e3.map(((e4) => {
            let t2 = 0;
            for (let n3 = 0; n3 < this.start && e4[n3] === this.content; ++n3) t2 = n3 + 1;
            let n2 = e4.length;
            for (let t3 = 0; t3 < this.stop; ++t3) {
              const r2 = e4.length - t3 - 1;
              if (e4[r2] !== this.content) break;
              n2 = r2;
            }
            return e4.slice(t2, n2);
          }));
        }
      }
      class Z extends H {
        constructor(e3) {
          super(e3), this.cleanup = e3.cleanup;
        }
        decode_chain(e3) {
          return e3.map(((e4, t2) => (0 !== t2 && (e4 = e4.startsWith(this.config.prefix) ? e4.replace(this.config.prefix, "") : " " + e4), this.cleanup && (e4 = _(e4)), e4)));
        }
      }
      class J extends H {
        constructor(e3) {
          super(e3), this.byte_decoder = T, this.text_decoder = new TextDecoder("utf-8", { fatal: false, ignoreBOM: true }), this.end_of_word_suffix = null;
        }
        convert_tokens_to_string(e3) {
          const t2 = e3.join(""), n2 = new Uint8Array([...t2].map(((e4) => this.byte_decoder[e4])));
          return this.text_decoder.decode(n2);
        }
        decode_chain(e3) {
          const t2 = [];
          let n2 = [];
          for (const r2 of e3) void 0 !== this.added_tokens.find(((e4) => e4.content === r2)) ? (n2.length > 0 && (t2.push(this.convert_tokens_to_string(n2)), n2 = []), t2.push(r2)) : n2.push(r2);
          return n2.length > 0 && t2.push(this.convert_tokens_to_string(n2)), t2;
        }
      }
      class ee extends H {
        constructor(e3) {
          super(e3), this.pad_token = this.config.pad_token, this.word_delimiter_token = this.config.word_delimiter_token, this.cleanup = this.config.cleanup;
        }
        convert_tokens_to_string(e3) {
          if (0 === e3.length) return "";
          const t2 = [e3[0]];
          for (let n3 = 1; n3 < e3.length; ++n3) e3[n3] !== t2.at(-1) && t2.push(e3[n3]);
          let n2 = t2.filter(((e4) => e4 !== this.pad_token)).join("");
          return this.cleanup && (n2 = _(n2).replaceAll(this.word_delimiter_token, " ").trim()), n2;
        }
        decode_chain(e3) {
          return [this.convert_tokens_to_string(e3)];
        }
      }
      class te extends H {
        constructor(e3) {
          super(e3), this.decoders = e3.decoders.map(((e4) => H.fromConfig(e4)));
        }
        decode_chain(e3) {
          return this.decoders.reduce(((e4, t2) => t2.decode_chain(e4)), e3);
        }
      }
      class ne extends H {
        constructor(e3) {
          super(e3), this.suffix = this.config.suffix;
        }
        decode_chain(e3) {
          return e3.map(((t2, n2) => t2.replaceAll(this.suffix, n2 === e3.length - 1 ? "" : " ")));
        }
      }
      class re extends H {
        decode_chain(e3) {
          let t2 = "";
          for (let n2 = 1; n2 < e3.length; n2 += 2) t2 += e3[n2];
          return [t2];
        }
      }
      class oe extends $ {
        constructor(e3) {
          super(), this.addPrefixSpace = e3.add_prefix_space, this.replacement = e3.replacement, this.strRep = e3.str_rep || this.replacement, this.prepend_scheme = e3.prepend_scheme ?? "always";
        }
        pre_tokenize_text(e3, { section_index: t2 } = {}) {
          let n2 = e3.replaceAll(" ", this.strRep);
          return this.addPrefixSpace && !n2.startsWith(this.replacement) && ("always" === this.prepend_scheme || "first" === this.prepend_scheme && 0 === t2) && (n2 = this.strRep + n2), [n2];
        }
      }
      class ie extends H {
        constructor(e3) {
          super(e3), this.addPrefixSpace = e3.add_prefix_space, this.replacement = e3.replacement;
        }
        decode_chain(e3) {
          const t2 = [];
          for (let n2 = 0; n2 < e3.length; ++n2) {
            let r2 = e3[n2].replaceAll(this.replacement, " ");
            this.addPrefixSpace && 0 == n2 && r2.startsWith(" ") && (r2 = r2.substring(1)), t2.push(r2);
          }
          return t2;
        }
      }
      class se extends M {
        constructor(e3) {
          super(e3), this.charsmap = e3.precompiled_charsmap;
        }
        normalize(e3) {
          if ((e3 = (e3 = e3.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm, "")).replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm, " ")).includes("\uFF5E")) {
            const t2 = e3.split("\uFF5E");
            e3 = t2.map(((e4) => e4.normalize("NFKC"))).join("\uFF5E");
          } else e3 = e3.normalize("NFKC");
          return e3;
        }
      }
      class ae extends $ {
        constructor(e3) {
          super(), this.tokenizers = e3.pretokenizers.map(((e4) => $.fromConfig(e4)));
        }
        pre_tokenize_text(e3, t2) {
          return this.tokenizers.reduce(((e4, n2) => n2.pre_tokenize(e4, t2)), [e3]);
        }
      }
      class le extends $ {
        constructor(e3) {
          super();
        }
        pre_tokenize_text(e3, t2) {
          return e3.match(/\w+|[^\w\s]+/g) || [];
        }
      }
      class ce extends $ {
        constructor(e3) {
          super();
        }
        pre_tokenize_text(e3, t2) {
          return (function(e4) {
            return e4.match(/\S+/g) || [];
          })(e3);
        }
      }
      class ue extends $ {
        constructor(e3) {
          super(), this.config = e3, this.pattern = u(this.config.pattern), this.content = this.config.content;
        }
        pre_tokenize_text(e3, t2) {
          return null === this.pattern ? [e3] : [e3.replaceAll(this.pattern, this.config.content)];
        }
      }
      const pe = ["bos_token", "eos_token", "unk_token", "sep_token", "pad_token", "cls_token", "mask_token"];
      function de(e3, t2, n2, o2) {
        for (const i2 of Object.keys(e3)) {
          const s2 = t2 - e3[i2].length, a2 = n2(i2), l2 = new Array(s2).fill(a2);
          e3[i2] = "right" === o2 ? (0, r.mergeArrays)(e3[i2], l2) : (0, r.mergeArrays)(l2, e3[i2]);
        }
      }
      function _e(e3, t2) {
        for (const n2 of Object.keys(e3)) e3[n2].length = t2;
      }
      class he extends r.Callable {
        return_token_type_ids = false;
        _default_chat_template = "{% for message in messages %}{{'<|im_start|>' + message['role'] + '\n' + message['content'] + '<|im_end|>' + '\n'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant\n' }}{% endif %}";
        constructor(e3, t2) {
          super(), this._tokenizer_config = t2, this.normalizer = M.fromConfig(e3.normalizer), this.pre_tokenizer = $.fromConfig(e3.pre_tokenizer), this.model = b.fromConfig(e3.model, t2), this.post_processor = V.fromConfig(e3.post_processor), this.decoder = H.fromConfig(e3.decoder), this.special_tokens = [], this.all_special_ids = [], this.added_tokens = [];
          for (const t3 of e3.added_tokens) {
            const e4 = new g(t3);
            this.added_tokens.push(e4), this.model.tokens_to_ids.set(e4.content, e4.id), this.model.vocab[e4.id] = e4.content, e4.special && (this.special_tokens.push(e4.content), this.all_special_ids.push(e4.id));
          }
          if (this.additional_special_tokens = t2.additional_special_tokens ?? [], this.special_tokens.push(...this.additional_special_tokens), this.special_tokens = [...new Set(this.special_tokens)], this.decoder && (this.decoder.added_tokens = this.added_tokens, this.decoder.end_of_word_suffix = this.model.end_of_word_suffix), this.added_tokens_regex = this.added_tokens.length > 0 ? new RegExp(this.added_tokens.map(((e4) => `${e4.lstrip ? "\\s*" : ""}(${(0, r.escapeRegExp)(e4.content)})${e4.rstrip ? "\\s*" : ""}`)).join("|")) : null, this.mask_token = this.getToken("mask_token"), this.mask_token_id = this.model.tokens_to_ids.get(this.mask_token), this.pad_token = this.getToken("pad_token", "eos_token"), this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token), this.sep_token = this.getToken("sep_token"), this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token), this.unk_token = this.getToken("unk_token"), this.unk_token_id = this.model.tokens_to_ids.get(this.unk_token), this.model_max_length = t2.model_max_length, this.remove_space = t2.remove_space, this.clean_up_tokenization_spaces = t2.clean_up_tokenization_spaces ?? true, this.do_lowercase_and_remove_accent = t2.do_lowercase_and_remove_accent ?? false, this.padding_side = "right", this.legacy = false, this.chat_template = t2.chat_template ?? null, Array.isArray(this.chat_template)) {
            const e4 = /* @__PURE__ */ Object.create(null);
            for (const { name: t3, template: n2 } of this.chat_template) {
              if ("string" != typeof t3 || "string" != typeof n2) throw new Error('Chat template must be a list of objects with "name" and "template" properties');
              e4[t3] = n2;
            }
            this.chat_template = e4;
          }
          this._compiled_template_cache = /* @__PURE__ */ new Map();
        }
        getToken(...e3) {
          for (const t2 of e3) {
            const e4 = this._tokenizer_config[t2];
            if (e4) {
              if ("object" == typeof e4) {
                if ("AddedToken" === e4.__type) return e4.content;
                throw Error(`Unknown token: ${e4}`);
              }
              return e4;
            }
          }
          return null;
        }
        static async from_pretrained(e3, { progress_callback: t2 = null, config: n2 = null, cache_dir: r2 = null, local_files_only: o2 = false, revision: i2 = "main", legacy: s2 = null } = {}) {
          return new this(...await c(e3, { progress_callback: t2, config: n2, cache_dir: r2, local_files_only: o2, revision: i2, legacy: s2 }));
        }
        _call(e3, { text_pair: t2 = null, add_special_tokens: n2 = true, padding: r2 = false, truncation: o2 = null, max_length: a2 = null, return_tensor: l2 = true } = {}) {
          const c2 = Array.isArray(e3);
          let u2;
          if (c2) {
            if (0 === e3.length) throw Error("text array must be non-empty");
            if (null !== t2) {
              if (!Array.isArray(t2)) throw Error("text_pair must also be an array");
              if (e3.length !== t2.length) throw Error("text and text_pair must have the same length");
              u2 = e3.map(((e4, r3) => this._encode_plus(e4, t2[r3], { add_special_tokens: n2 })));
            } else u2 = e3.map(((e4) => this._encode_plus(e4, null, { add_special_tokens: n2 })));
          } else {
            if (null == e3) throw Error("text may not be null or undefined");
            if (Array.isArray(t2)) throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");
            u2 = [this._encode_plus(e3, t2, { add_special_tokens: n2 })];
          }
          if (null === a2 ? a2 = "max_length" === r2 ? this.model_max_length : (0, i.max)(u2.map(((e4) => e4.input_ids.length)))[0] : o2 || console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."), a2 = Math.min(a2, this.model_max_length), r2 || o2) for (let e4 = 0; e4 < u2.length; ++e4) u2[e4].input_ids.length !== a2 && (u2[e4].input_ids.length > a2 ? o2 && _e(u2[e4], a2) : r2 && de(u2[e4], a2, ((e5) => "input_ids" === e5 ? this.pad_token_id : 0), this.padding_side));
          const p2 = {};
          if (l2) {
            if ((!r2 || !o2) && u2.some(((e5) => {
              for (const t3 of Object.keys(e5)) if (e5[t3].length !== u2[0][t3]?.length) return true;
              return false;
            }))) throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");
            const e4 = [u2.length, u2[0].input_ids.length];
            for (const t3 of Object.keys(u2[0])) p2[t3] = new s.Tensor("int64", BigInt64Array.from(u2.flatMap(((e5) => e5[t3])).map(BigInt)), e4);
          } else {
            for (const e4 of Object.keys(u2[0])) p2[e4] = u2.map(((t3) => t3[e4]));
            if (!c2) for (const e4 of Object.keys(p2)) p2[e4] = p2[e4][0];
          }
          return p2;
        }
        _encode_text(e3) {
          if (null === e3) return null;
          const t2 = (this.added_tokens_regex ? e3.split(this.added_tokens_regex).filter(((e4) => e4)) : [e3]).map(((e4, t3) => {
            if (void 0 !== this.added_tokens.find(((t4) => t4.content === e4))) return e4;
            {
              if (true === this.remove_space && (e4 = e4.trim().split(/\s+/).join(" ")), this.do_lowercase_and_remove_accent && (e4 = (function(e5) {
                return h(e5.toLowerCase());
              })(e4)), null !== this.normalizer && (e4 = this.normalizer(e4)), 0 === e4.length) return [];
              const n2 = null !== this.pre_tokenizer ? this.pre_tokenizer(e4, { section_index: t3 }) : [e4];
              return this.model(n2);
            }
          })).flat();
          return t2;
        }
        _encode_plus(e3, t2 = null, { add_special_tokens: n2 = true } = {}) {
          const o2 = this._encode_text(e3), i2 = this._encode_text(t2), s2 = this.post_processor ? this.post_processor(o2, i2, { add_special_tokens: n2 }) : { tokens: (0, r.mergeArrays)(o2 ?? [], i2 ?? []) }, a2 = this.model.convert_tokens_to_ids(s2.tokens), l2 = { input_ids: a2, attention_mask: new Array(a2.length).fill(1) };
          return this.return_token_type_ids && s2.token_type_ids && (l2.token_type_ids = s2.token_type_ids), l2;
        }
        encode(e3, t2 = null, { add_special_tokens: n2 = true } = {}) {
          const { input_ids: r2 } = this._encode_plus(e3, t2, { add_special_tokens: n2 });
          return r2;
        }
        batch_decode(e3, t2 = {}) {
          return e3 instanceof s.Tensor && (e3 = e3.tolist()), e3.map(((e4) => this.decode(e4, t2)));
        }
        decode(e3, t2 = {}) {
          if (e3 instanceof s.Tensor && (e3 = d(e3)), !Array.isArray(e3) || 0 === e3.length || !(0, r.isIntegralNumber)(e3[0])) throw Error("token_ids must be a non-empty array of integers.");
          return this.decode_single(e3, t2);
        }
        decode_single(e3, { skip_special_tokens: t2 = false, clean_up_tokenization_spaces: n2 = null }) {
          let r2 = this.model.convert_ids_to_tokens(e3);
          t2 && (r2 = r2.filter(((e4) => !this.special_tokens.includes(e4))));
          let o2 = this.decoder ? this.decoder(r2) : r2.join(" ");
          return this.decoder && this.decoder.end_of_word_suffix && (o2 = o2.replaceAll(this.decoder.end_of_word_suffix, " "), t2 && (o2 = o2.trim())), (n2 ?? this.clean_up_tokenization_spaces) && (o2 = _(o2)), o2;
        }
        get default_chat_template() {
          return this._warned_about_chat_template || (console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."), this._warned_about_chat_template = true), this._default_chat_template;
        }
        apply_chat_template(e3, { chat_template: t2 = null, add_generation_prompt: n2 = false, tokenize: r2 = true, padding: o2 = false, truncation: i2 = false, max_length: s2 = null, return_tensor: a2 = true, tokenizer_kwargs: c2 = {}, ...u2 } = {}) {
          if (this.chat_template && "object" == typeof this.chat_template || null === this.chat_template && this.default_chat_template && "object" == typeof this.default_chat_template) {
            const e4 = this.chat_template ?? this.default_chat_template;
            if (null !== t2 && Object.hasOwn(e4, t2)) t2 = e4[t2];
            else if (null === t2 && "default" in e4) t2 = e4.default;
            else if (null === t2) throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(e4).sort()}.`);
          } else t2 ??= this.chat_template ?? this.default_chat_template;
          if ("string" != typeof t2) throw Error("chat_template must be a string, but got " + typeof t2);
          let p2 = this._compiled_template_cache.get(t2);
          void 0 === p2 && (p2 = new l.Template(t2), this._compiled_template_cache.set(t2, p2));
          const d2 = /* @__PURE__ */ Object.create(null);
          for (const e4 of pe) {
            const t3 = this.getToken(e4);
            t3 && (d2[e4] = t3);
          }
          const _2 = p2.render({ messages: e3, add_generation_prompt: n2, ...d2, ...u2 });
          return r2 ? this._call(_2, { add_special_tokens: false, padding: o2, truncation: i2, max_length: s2, return_tensor: a2, ...c2 }).input_ids : _2;
        }
      }
      class fe extends he {
        return_token_type_ids = true;
      }
      class me extends he {
        return_token_type_ids = true;
      }
      class ge extends he {
        return_token_type_ids = true;
      }
      class be extends he {
        return_token_type_ids = true;
      }
      class we extends he {
        return_token_type_ids = true;
      }
      class xe extends he {
        return_token_type_ids = true;
      }
      class ye extends he {
        return_token_type_ids = true;
      }
      class Te extends he {
        return_token_type_ids = true;
      }
      class ve extends he {
        return_token_type_ids = true;
      }
      class ke extends he {
      }
      class Me extends he {
      }
      class Se extends he {
        return_token_type_ids = true;
        constructor(e3, t2) {
          super(e3, t2), console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.');
        }
      }
      class Pe extends he {
        return_token_type_ids = true;
      }
      class Ae extends he {
      }
      class Fe extends he {
        _default_chat_template = '{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';
      }
      class Ce extends he {
      }
      class Ee extends he {
        constructor(e3, t2) {
          super(e3, t2), this.languageRegex = /^[a-z]{2}_[A-Z]{2}$/, this.language_codes = this.special_tokens.filter(((e4) => this.languageRegex.test(e4))), this.lang_to_token = (e4) => e4;
        }
        _build_translation_inputs(e3, t2, n2) {
          return We(this, e3, t2, n2);
        }
      }
      class Oe extends Ee {
      }
      class Ie extends he {
      }
      class De extends Fe {
        constructor(e3, t2) {
          const n2 = ".,!?\u2026\u3002\uFF0C\u3001\u0964\u06D4\u060C", r2 = e3.pre_tokenizer?.pretokenizers[0]?.pattern;
          r2 && r2.Regex === ` ?[^(\\s|[${n2}])]+` && (r2.Regex = ` ?[^\\s${n2}]+`), super(e3, t2);
        }
      }
      const Le = "\u2581";
      class $e extends he {
        _default_chat_template = "{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>\n' + system_message + '\n<</SYS>>\n\n' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>\n' + content.strip() + '\n<</SYS>>\n\n' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}";
        DEFAULT_SYSTEM_PROMPT = "You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.\n\nIf a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.";
        constructor(e3, t2) {
          super(e3, t2), this.use_default_system_prompt = t2.use_default_system_prompt ?? false, this.legacy = t2.legacy ?? true, this.legacy || (this.normalizer = null, this.pre_tokenizer = new oe({ replacement: Le, add_prefix_space: true, prepend_scheme: "first" }));
        }
        _encode_text(e3) {
          if (null === e3) return null;
          if (this.legacy || 0 === e3.length) return super._encode_text(e3);
          let t2 = super._encode_text(Le + e3.replaceAll(Le, " "));
          return t2.length > 1 && t2[0] === Le && this.special_tokens.includes(t2[1]) && (t2 = t2.slice(1)), t2;
        }
        get default_chat_template() {
          return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT", this.use_default_system_prompt ? "true" : "false").replaceAll("DEFAULT_SYSTEM_MESSAGE", this.DEFAULT_SYSTEM_PROMPT.replaceAll("\n", "\\n").replaceAll("'", "\\'"));
        }
      }
      class Ne extends $e {
      }
      class Be extends he {
      }
      class ze extends he {
      }
      class Re extends he {
      }
      class je extends he {
      }
      class Ve extends he {
      }
      class Ue extends he {
      }
      class Ge extends he {
        _default_chat_template = "{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '\n' + message['content'] | trim + '<end_of_turn>\n' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model\n'}}{% endif %}";
      }
      class qe extends he {
      }
      function We(e3, t2, n2, r2) {
        if (!("language_codes" in e3) || !Array.isArray(e3.language_codes)) throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");
        if (!("languageRegex" in e3 && e3.languageRegex instanceof RegExp)) throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");
        if (!("lang_to_token" in e3) || "function" != typeof e3.lang_to_token) throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");
        const o2 = r2.src_lang, i2 = r2.tgt_lang;
        if (!e3.language_codes.includes(i2)) throw new Error(`Target language code "${i2}" is not valid. Must be one of: {${e3.language_codes.join(", ")}}`);
        if (void 0 !== o2) {
          if (!e3.language_codes.includes(o2)) throw new Error(`Source language code "${o2}" is not valid. Must be one of: {${e3.language_codes.join(", ")}}`);
          for (const t3 of e3.post_processor.config.single) if ("SpecialToken" in t3 && e3.languageRegex.test(t3.SpecialToken.id)) {
            t3.SpecialToken.id = e3.lang_to_token(o2);
            break;
          }
        }
        return r2.forced_bos_token_id = e3.model.convert_tokens_to_ids([e3.lang_to_token(i2)])[0], e3._call(t2, n2);
      }
      class He extends he {
        constructor(e3, t2) {
          super(e3, t2), this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/, this.language_codes = this.special_tokens.filter(((e4) => this.languageRegex.test(e4))), this.lang_to_token = (e4) => e4;
        }
        _build_translation_inputs(e3, t2, n2) {
          return We(this, e3, t2, n2);
        }
      }
      class Xe extends he {
        constructor(e3, t2) {
          super(e3, t2), this.languageRegex = /^__[a-z]{2,3}__$/, this.language_codes = this.special_tokens.filter(((e4) => this.languageRegex.test(e4))).map(((e4) => e4.slice(2, -2))), this.lang_to_token = (e4) => `__${e4}__`;
        }
        _build_translation_inputs(e3, t2, n2) {
          return We(this, e3, t2, n2);
        }
      }
      const Qe = [["en", "english"], ["zh", "chinese"], ["de", "german"], ["es", "spanish"], ["ru", "russian"], ["ko", "korean"], ["fr", "french"], ["ja", "japanese"], ["pt", "portuguese"], ["tr", "turkish"], ["pl", "polish"], ["ca", "catalan"], ["nl", "dutch"], ["ar", "arabic"], ["sv", "swedish"], ["it", "italian"], ["id", "indonesian"], ["hi", "hindi"], ["fi", "finnish"], ["vi", "vietnamese"], ["he", "hebrew"], ["uk", "ukrainian"], ["el", "greek"], ["ms", "malay"], ["cs", "czech"], ["ro", "romanian"], ["da", "danish"], ["hu", "hungarian"], ["ta", "tamil"], ["no", "norwegian"], ["th", "thai"], ["ur", "urdu"], ["hr", "croatian"], ["bg", "bulgarian"], ["lt", "lithuanian"], ["la", "latin"], ["mi", "maori"], ["ml", "malayalam"], ["cy", "welsh"], ["sk", "slovak"], ["te", "telugu"], ["fa", "persian"], ["lv", "latvian"], ["bn", "bengali"], ["sr", "serbian"], ["az", "azerbaijani"], ["sl", "slovenian"], ["kn", "kannada"], ["et", "estonian"], ["mk", "macedonian"], ["br", "breton"], ["eu", "basque"], ["is", "icelandic"], ["hy", "armenian"], ["ne", "nepali"], ["mn", "mongolian"], ["bs", "bosnian"], ["kk", "kazakh"], ["sq", "albanian"], ["sw", "swahili"], ["gl", "galician"], ["mr", "marathi"], ["pa", "punjabi"], ["si", "sinhala"], ["km", "khmer"], ["sn", "shona"], ["yo", "yoruba"], ["so", "somali"], ["af", "afrikaans"], ["oc", "occitan"], ["ka", "georgian"], ["be", "belarusian"], ["tg", "tajik"], ["sd", "sindhi"], ["gu", "gujarati"], ["am", "amharic"], ["yi", "yiddish"], ["lo", "lao"], ["uz", "uzbek"], ["fo", "faroese"], ["ht", "haitian creole"], ["ps", "pashto"], ["tk", "turkmen"], ["nn", "nynorsk"], ["mt", "maltese"], ["sa", "sanskrit"], ["lb", "luxembourgish"], ["my", "myanmar"], ["bo", "tibetan"], ["tl", "tagalog"], ["mg", "malagasy"], ["as", "assamese"], ["tt", "tatar"], ["haw", "hawaiian"], ["ln", "lingala"], ["ha", "hausa"], ["ba", "bashkir"], ["jw", "javanese"], ["su", "sundanese"]], Ye = new Map(Qe), Ke = new Map([...Qe.map((([e3, t2]) => [t2, e3])), ["burmese", "my"], ["valencian", "ca"], ["flemish", "nl"], ["haitian", "ht"], ["letzeburgesch", "lb"], ["pushto", "ps"], ["panjabi", "pa"], ["moldavian", "ro"], ["moldovan", "ro"], ["sinhalese", "si"], ["castilian", "es"]]);
      class Ze extends he {
        _default_chat_template = '{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';
        _decode_asr(e3, { return_timestamps: t2 = false, return_language: n2 = false, time_precision: r2 = null, force_full_sequences: o2 = true } = {}) {
          if (null === r2) throw Error("Must specify time_precision");
          let s2 = null;
          const a2 = "word" === t2;
          function l2() {
            return { language: s2, timestamp: [null, null], text: "" };
          }
          const c2 = [];
          let u2 = l2(), p2 = 0;
          const d2 = this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0] + 1;
          let _2 = [], h2 = [], f2 = false, m2 = null;
          const g2 = new Set(this.all_special_ids);
          for (const n3 of e3) {
            const e4 = n3.tokens, o3 = a2 ? n3.token_timestamps : null;
            let b3 = null, w3 = d2;
            if ("stride" in n3) {
              const [t3, o4, i2] = n3.stride;
              if (p2 -= o4, m2 = t3 - i2, o4 && (w3 = o4 / r2 + d2), i2) for (let t4 = e4.length - 1; t4 >= 0; --t4) {
                const n4 = e4[t4];
                if (n4 >= d2) {
                  if (null !== b3 && (n4 - d2) * r2 < m2) break;
                  b3 = n4;
                }
              }
            }
            let x2 = [], y2 = [];
            for (let n4 = 0; n4 < e4.length; ++n4) {
              const m3 = e4[n4];
              if (g2.has(m3)) {
                const e5 = this.decode([m3]), n5 = Ye.get(e5.slice(2, -2));
                if (void 0 !== n5) {
                  if (null !== s2 && n5 !== s2 && !t2) {
                    _2.push(x2);
                    const e6 = this.findLongestCommonSequence(_2)[0], t3 = this.decode(e6);
                    u2.text = t3, c2.push(u2), _2 = [], x2 = [], u2 = l2();
                  }
                  s2 = u2.language = n5;
                }
              } else if (m3 >= d2) {
                const e5 = (m3 - d2) * r2 + p2, t3 = (0, i.round)(e5, 2);
                if (null !== b3 && m3 >= b3) f2 = true;
                else if (f2 || _2.length > 0 && m3 < w3) f2 = false;
                else if (null === u2.timestamp[0]) u2.timestamp[0] = t3;
                else if (t3 === u2.timestamp[0]) ;
                else {
                  u2.timestamp[1] = t3, _2.push(x2), a2 && h2.push(y2);
                  const [e6, n5] = this.findLongestCommonSequence(_2, h2), r3 = this.decode(e6);
                  u2.text = r3, a2 && (u2.words = this.collateWordTimestamps(e6, n5, s2)), c2.push(u2), _2 = [], x2 = [], h2 = [], y2 = [], u2 = l2();
                }
              } else if (x2.push(m3), a2) {
                let e5, t3 = (0, i.round)(o3[n4] + p2, 2);
                e5 = n4 + 1 < o3.length ? (0, i.round)(o3[n4 + 1] + p2, 2) : null, y2.push([t3, e5]);
              }
            }
            if ("stride" in n3) {
              const [e5, t3, r3] = n3.stride;
              p2 += e5 - r3;
            }
            x2.length > 0 ? (_2.push(x2), a2 && h2.push(y2)) : _2.every(((e5) => 0 === e5.length)) && (u2 = l2(), _2 = [], x2 = [], h2 = [], y2 = []);
          }
          if (_2.length > 0) {
            if (o2 && t2) throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");
            const [e4, n3] = this.findLongestCommonSequence(_2, h2), r3 = this.decode(e4);
            u2.text = r3, a2 && (u2.words = this.collateWordTimestamps(e4, n3, s2)), c2.push(u2);
          }
          let b2 = /* @__PURE__ */ Object.create(null);
          const w2 = c2.map(((e4) => e4.text)).join("");
          if (t2 || n2) {
            for (let e4 = 0; e4 < c2.length; ++e4) {
              const r3 = c2[e4];
              t2 || delete r3.timestamp, n2 || delete r3.language;
            }
            if (a2) {
              const e4 = [];
              for (const t3 of c2) for (const n3 of t3.words) e4.push(n3);
              b2 = { chunks: e4 };
            } else b2 = { chunks: c2 };
          }
          return [w2, b2];
        }
        findLongestCommonSequence(e3, t2 = null) {
          let n2 = e3[0], r2 = n2.length, o2 = [];
          const i2 = Array.isArray(t2) && t2.length > 0;
          let s2 = i2 ? [] : null, a2 = i2 ? t2[0] : null;
          for (let l2 = 1; l2 < e3.length; ++l2) {
            const c2 = e3[l2];
            let u2 = 0, p2 = [r2, r2, 0, 0];
            const d2 = c2.length;
            for (let e4 = 1; e4 < r2 + d2; ++e4) {
              const t3 = e4 / 1e4, o3 = Math.max(0, r2 - e4), i3 = Math.min(r2, r2 + d2 - e4), s3 = n2.slice(o3, i3), a3 = Math.max(0, e4 - r2), l3 = Math.min(d2, e4), _3 = c2.slice(a3, l3);
              if (s3.length !== _3.length) throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");
              const h3 = s3.filter(((e5, t4) => e5 === _3[t4])).length, f3 = h3 / e4 + t3;
              h3 > 1 && f3 > u2 && (u2 = f3, p2 = [o3, i3, a3, l3]);
            }
            const [_2, h2, f2, m2] = p2, g2 = Math.floor((h2 + _2) / 2), b2 = Math.floor((m2 + f2) / 2);
            o2.push(...n2.slice(0, g2)), n2 = c2.slice(b2), r2 = n2.length, i2 && (s2.push(...a2.slice(0, g2)), a2 = t2[l2].slice(b2));
          }
          return o2.push(...n2), i2 ? (s2.push(...a2), [o2, s2]) : [o2, []];
        }
        collateWordTimestamps(e3, t2, n2) {
          const [r2, o2, i2] = this.combineTokensIntoWords(e3, n2), s2 = [];
          for (let e4 = 0; e4 < r2.length; ++e4) {
            const n3 = i2[e4];
            s2.push({ text: r2[e4], timestamp: [t2[n3.at(0)][0], t2[n3.at(-1)][1]] });
          }
          return s2;
        }
        combineTokensIntoWords(e3, t2, n2 = `"'\u201C\xA1\xBF([{-`, r2 = `"'.\u3002,\uFF0C!\uFF01?\uFF1F:\uFF1A\u201D)]}\u3001`) {
          let o2, i2, s2;
          return ["chinese", "japanese", "thai", "lao", "myanmar"].includes(t2 = t2 ?? "english") ? [o2, i2, s2] = this.splitTokensOnUnicode(e3) : [o2, i2, s2] = this.splitTokensOnSpaces(e3), this.mergePunctuations(o2, i2, s2, n2, r2);
        }
        decode(e3, t2) {
          let n2;
          return t2 && t2.decode_with_timestamps ? (e3 instanceof s.Tensor && (e3 = d(e3)), n2 = this.decodeWithTimestamps(e3, t2)) : n2 = super.decode(e3, t2), n2;
        }
        decodeWithTimestamps(e3, t2) {
          const n2 = t2?.time_precision ?? 0.02, r2 = Array.from(this.all_special_ids).at(-1) + 1;
          let o2 = [[]];
          for (const t3 of e3) if (t3 >= r2) {
            const e4 = (0, i.round)((t3 - r2) * n2, 2);
            o2.push(`<|${e4}|>`), o2.push([]);
          } else o2[o2.length - 1].push(t3);
          return o2 = o2.map(((e4) => "string" == typeof e4 ? e4 : super.decode(e4, t2))), o2.join("");
        }
        splitTokensOnUnicode(e3) {
          const t2 = this.decode(e3, { decode_with_timestamps: true }), n2 = [], r2 = [], o2 = [];
          let i2 = [], s2 = [], a2 = 0;
          for (let l2 = 0; l2 < e3.length; ++l2) {
            const c2 = e3[l2];
            i2.push(c2), s2.push(l2);
            const u2 = this.decode(i2, { decode_with_timestamps: true });
            u2.includes("\uFFFD") && "\uFFFD" !== t2[a2 + u2.indexOf("\uFFFD")] || (n2.push(u2), r2.push(i2), o2.push(s2), i2 = [], s2 = [], a2 += u2.length);
          }
          return [n2, r2, o2];
        }
        splitTokensOnSpaces(e3) {
          const [t2, n2, r2] = this.splitTokensOnUnicode(e3), o2 = [], i2 = [], s2 = [], a2 = new RegExp(`^[${f}]$`, "gu");
          for (let e4 = 0; e4 < t2.length; ++e4) {
            const l2 = t2[e4], c2 = n2[e4], u2 = r2[e4], p2 = c2[0] >= this.model.tokens_to_ids.get("<|endoftext|>"), d2 = l2.startsWith(" "), _2 = l2.trim(), h2 = a2.test(_2);
            if (p2 || d2 || h2 || 0 === o2.length) o2.push(l2), i2.push(c2), s2.push(u2);
            else {
              const e5 = o2.length - 1;
              o2[e5] += l2, i2[e5].push(...c2), s2[e5].push(...u2);
            }
          }
          return [o2, i2, s2];
        }
        mergePunctuations(e3, t2, n2, o2, i2) {
          const s2 = structuredClone(e3), a2 = structuredClone(t2), l2 = structuredClone(n2);
          let c2 = s2.length - 2, u2 = s2.length - 1;
          for (; c2 >= 0; ) s2[c2].startsWith(" ") && o2.includes(s2[c2].trim()) ? (s2[u2] = s2[c2] + s2[u2], a2[u2] = (0, r.mergeArrays)(a2[c2], a2[u2]), l2[u2] = (0, r.mergeArrays)(l2[c2], l2[u2]), s2[c2] = "", a2[c2] = [], l2[c2] = []) : u2 = c2, --c2;
          for (c2 = 0, u2 = 1; u2 < s2.length; ) !s2[c2].endsWith(" ") && i2.includes(s2[u2]) ? (s2[c2] += s2[u2], a2[c2] = (0, r.mergeArrays)(a2[c2], a2[u2]), l2[c2] = (0, r.mergeArrays)(l2[c2], l2[u2]), s2[u2] = "", a2[u2] = [], l2[u2] = []) : c2 = u2, ++u2;
          return [s2.filter(((e4) => e4)), a2.filter(((e4) => e4.length > 0)), l2.filter(((e4) => e4.length > 0))];
        }
        get_decoder_prompt_ids({ language: e3 = null, task: t2 = null, no_timestamps: n2 = true } = {}) {
          const r2 = [];
          if (e3) {
            e3 = e3.toLowerCase();
            let t3 = Ke.get(e3);
            if (void 0 === t3) {
              if (!Ye.has(e3)) {
                const t4 = 2 === e3.length ? Ye.keys() : Ye.values();
                throw new Error(`Language "${e3}" is not supported. Must be one of: ${JSON.stringify(t4)}`);
              }
              t3 = e3;
            }
            const n3 = this.model.tokens_to_ids.get(`<|${t3}|>`);
            if (void 0 === n3) throw new Error(`Unable to find language "${t3}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);
            r2.push(n3);
          } else r2.push(null);
          if (t2) {
            if ("transcribe" !== (t2 = t2.toLowerCase()) && "translate" !== t2) throw new Error(`Task "${t2}" is not supported. Must be one of: ["transcribe", "translate"]`);
            const e4 = this.model.tokens_to_ids.get(`<|${t2}|>`);
            if (void 0 === e4) throw new Error(`Unable to find task "${t2}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);
            r2.push(e4);
          } else r2.push(null);
          if (n2) {
            const e4 = this.model.tokens_to_ids.get("<|notimestamps|>");
            if (void 0 === e4) throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');
            r2.push(e4);
          }
          return r2.map(((e4, t3) => [t3 + 1, e4])).filter(((e4) => null !== e4[1]));
        }
      }
      class Je extends he {
      }
      class et extends he {
      }
      class tt extends he {
      }
      class nt extends he {
        constructor(e3, t2) {
          super(e3, t2), this.languageRegex = /^(>>\w+<<)\s*/g, this.supported_language_codes = this.model.vocab.filter(((e4) => this.languageRegex.test(e4))), console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.');
        }
        _encode_text(e3) {
          if (null === e3) return null;
          const [t2, ...n2] = e3.trim().split(this.languageRegex);
          if (0 === n2.length) return super._encode_text(t2);
          if (2 === n2.length) {
            const [e4, t3] = n2;
            return this.supported_language_codes.includes(e4) || console.warn(`Unsupported language code "${e4}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`), (0, r.mergeArrays)([e4], super._encode_text(t3));
          }
        }
      }
      class rt extends he {
      }
      class ot extends he {
        _default_chat_template = "{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}";
      }
      class it extends ot {
      }
      class st extends he {
      }
      class at extends he {
      }
      class lt extends he {
        constructor(e3, t2) {
          super(e3, t2), this.decoder = new re({});
        }
      }
      class ct extends he {
      }
      class ut {
        static TOKENIZER_CLASS_MAPPING = { T5Tokenizer: Ae, DistilBertTokenizer: ke, CamembertTokenizer: Me, DebertaTokenizer: we, DebertaV2Tokenizer: xe, BertTokenizer: fe, HerbertTokenizer: ye, ConvBertTokenizer: Te, RoFormerTokenizer: ve, XLMTokenizer: Se, ElectraTokenizer: Pe, MobileBertTokenizer: ge, SqueezeBertTokenizer: be, AlbertTokenizer: me, GPT2Tokenizer: Fe, BartTokenizer: Ce, MBartTokenizer: Ee, MBart50Tokenizer: Oe, RobertaTokenizer: Ie, WhisperTokenizer: Ze, CodeGenTokenizer: Je, CLIPTokenizer: et, SiglipTokenizer: tt, MarianTokenizer: nt, BloomTokenizer: De, NllbTokenizer: He, M2M100Tokenizer: Xe, LlamaTokenizer: $e, CodeLlamaTokenizer: Ne, XLMRobertaTokenizer: Be, MPNetTokenizer: ze, FalconTokenizer: Re, GPTNeoXTokenizer: je, EsmTokenizer: Ve, Wav2Vec2CTCTokenizer: rt, BlenderbotTokenizer: ot, BlenderbotSmallTokenizer: it, SpeechT5Tokenizer: st, NougatTokenizer: at, VitsTokenizer: lt, Qwen2Tokenizer: Ue, GemmaTokenizer: Ge, Grok1Tokenizer: qe, CohereTokenizer: ct, PreTrainedTokenizer: he };
        static async from_pretrained(e3, { quantized: t2 = true, progress_callback: n2 = null, config: r2 = null, cache_dir: o2 = null, local_files_only: i2 = false, revision: s2 = "main", legacy: a2 = null } = {}) {
          const [l2, u2] = await c(e3, { quantized: t2, progress_callback: n2, config: r2, cache_dir: o2, local_files_only: i2, revision: s2, legacy: a2 }), p2 = u2.tokenizer_class?.replace(/Fast$/, "") ?? "PreTrainedTokenizer";
          let d2 = this.TOKENIZER_CLASS_MAPPING[p2];
          return d2 || (console.warn(`Unknown tokenizer class "${p2}", attempting to construct from base class.`), d2 = he), new d2(l2, u2);
        }
      }
    }
  ), "./src/transformers.js": (
    /*!*****************************!*\
      !*** ./src/transformers.js ***!
      \*****************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { ASTFeatureExtractor: () => a.ASTFeatureExtractor, ASTForAudioClassification: () => i.ASTForAudioClassification, ASTModel: () => i.ASTModel, ASTPreTrainedModel: () => i.ASTPreTrainedModel, AlbertForMaskedLM: () => i.AlbertForMaskedLM, AlbertForQuestionAnswering: () => i.AlbertForQuestionAnswering, AlbertForSequenceClassification: () => i.AlbertForSequenceClassification, AlbertModel: () => i.AlbertModel, AlbertPreTrainedModel: () => i.AlbertPreTrainedModel, AlbertTokenizer: () => s.AlbertTokenizer, AudioClassificationPipeline: () => r.AudioClassificationPipeline, AutoConfig: () => l.AutoConfig, AutoModel: () => i.AutoModel, AutoModelForAudioClassification: () => i.AutoModelForAudioClassification, AutoModelForAudioFrameClassification: () => i.AutoModelForAudioFrameClassification, AutoModelForCTC: () => i.AutoModelForCTC, AutoModelForCausalLM: () => i.AutoModelForCausalLM, AutoModelForDepthEstimation: () => i.AutoModelForDepthEstimation, AutoModelForDocumentQuestionAnswering: () => i.AutoModelForDocumentQuestionAnswering, AutoModelForImageClassification: () => i.AutoModelForImageClassification, AutoModelForImageFeatureExtraction: () => i.AutoModelForImageFeatureExtraction, AutoModelForImageMatting: () => i.AutoModelForImageMatting, AutoModelForImageSegmentation: () => i.AutoModelForImageSegmentation, AutoModelForImageToImage: () => i.AutoModelForImageToImage, AutoModelForMaskGeneration: () => i.AutoModelForMaskGeneration, AutoModelForMaskedLM: () => i.AutoModelForMaskedLM, AutoModelForObjectDetection: () => i.AutoModelForObjectDetection, AutoModelForQuestionAnswering: () => i.AutoModelForQuestionAnswering, AutoModelForSemanticSegmentation: () => i.AutoModelForSemanticSegmentation, AutoModelForSeq2SeqLM: () => i.AutoModelForSeq2SeqLM, AutoModelForSequenceClassification: () => i.AutoModelForSequenceClassification, AutoModelForSpeechSeq2Seq: () => i.AutoModelForSpeechSeq2Seq, AutoModelForTextToSpectrogram: () => i.AutoModelForTextToSpectrogram, AutoModelForTextToWaveform: () => i.AutoModelForTextToWaveform, AutoModelForTokenClassification: () => i.AutoModelForTokenClassification, AutoModelForVision2Seq: () => i.AutoModelForVision2Seq, AutoModelForXVector: () => i.AutoModelForXVector, AutoModelForZeroShotObjectDetection: () => i.AutoModelForZeroShotObjectDetection, AutoProcessor: () => a.AutoProcessor, AutoTokenizer: () => s.AutoTokenizer, AutomaticSpeechRecognitionPipeline: () => r.AutomaticSpeechRecognitionPipeline, BartForConditionalGeneration: () => i.BartForConditionalGeneration, BartForSequenceClassification: () => i.BartForSequenceClassification, BartModel: () => i.BartModel, BartPretrainedModel: () => i.BartPretrainedModel, BartTokenizer: () => s.BartTokenizer, BaseModelOutput: () => i.BaseModelOutput, BeitFeatureExtractor: () => a.BeitFeatureExtractor, BeitForImageClassification: () => i.BeitForImageClassification, BeitModel: () => i.BeitModel, BeitPreTrainedModel: () => i.BeitPreTrainedModel, BertForMaskedLM: () => i.BertForMaskedLM, BertForQuestionAnswering: () => i.BertForQuestionAnswering, BertForSequenceClassification: () => i.BertForSequenceClassification, BertForTokenClassification: () => i.BertForTokenClassification, BertModel: () => i.BertModel, BertPreTrainedModel: () => i.BertPreTrainedModel, BertTokenizer: () => s.BertTokenizer, BitImageProcessor: () => a.BitImageProcessor, BlenderbotForConditionalGeneration: () => i.BlenderbotForConditionalGeneration, BlenderbotModel: () => i.BlenderbotModel, BlenderbotPreTrainedModel: () => i.BlenderbotPreTrainedModel, BlenderbotSmallForConditionalGeneration: () => i.BlenderbotSmallForConditionalGeneration, BlenderbotSmallModel: () => i.BlenderbotSmallModel, BlenderbotSmallPreTrainedModel: () => i.BlenderbotSmallPreTrainedModel, BlenderbotSmallTokenizer: () => s.BlenderbotSmallTokenizer, BlenderbotTokenizer: () => s.BlenderbotTokenizer, BloomForCausalLM: () => i.BloomForCausalLM, BloomModel: () => i.BloomModel, BloomPreTrainedModel: () => i.BloomPreTrainedModel, BloomTokenizer: () => s.BloomTokenizer, CLIPFeatureExtractor: () => a.CLIPFeatureExtractor, CLIPModel: () => i.CLIPModel, CLIPPreTrainedModel: () => i.CLIPPreTrainedModel, CLIPSegForImageSegmentation: () => i.CLIPSegForImageSegmentation, CLIPSegModel: () => i.CLIPSegModel, CLIPSegPreTrainedModel: () => i.CLIPSegPreTrainedModel, CLIPTextModelWithProjection: () => i.CLIPTextModelWithProjection, CLIPTokenizer: () => s.CLIPTokenizer, CLIPVisionModelWithProjection: () => i.CLIPVisionModelWithProjection, CamembertForMaskedLM: () => i.CamembertForMaskedLM, CamembertForQuestionAnswering: () => i.CamembertForQuestionAnswering, CamembertForSequenceClassification: () => i.CamembertForSequenceClassification, CamembertForTokenClassification: () => i.CamembertForTokenClassification, CamembertModel: () => i.CamembertModel, CamembertPreTrainedModel: () => i.CamembertPreTrainedModel, CamembertTokenizer: () => s.CamembertTokenizer, CausalLMOutput: () => i.CausalLMOutput, CausalLMOutputWithPast: () => i.CausalLMOutputWithPast, ChineseCLIPFeatureExtractor: () => a.ChineseCLIPFeatureExtractor, ChineseCLIPModel: () => i.ChineseCLIPModel, ChineseCLIPPreTrainedModel: () => i.ChineseCLIPPreTrainedModel, ClapAudioModelWithProjection: () => i.ClapAudioModelWithProjection, ClapFeatureExtractor: () => a.ClapFeatureExtractor, ClapModel: () => i.ClapModel, ClapPreTrainedModel: () => i.ClapPreTrainedModel, ClapTextModelWithProjection: () => i.ClapTextModelWithProjection, CodeGenForCausalLM: () => i.CodeGenForCausalLM, CodeGenModel: () => i.CodeGenModel, CodeGenPreTrainedModel: () => i.CodeGenPreTrainedModel, CodeGenTokenizer: () => s.CodeGenTokenizer, CodeLlamaTokenizer: () => s.CodeLlamaTokenizer, CohereTokenizer: () => s.CohereTokenizer, ConvBertForMaskedLM: () => i.ConvBertForMaskedLM, ConvBertForQuestionAnswering: () => i.ConvBertForQuestionAnswering, ConvBertForSequenceClassification: () => i.ConvBertForSequenceClassification, ConvBertForTokenClassification: () => i.ConvBertForTokenClassification, ConvBertModel: () => i.ConvBertModel, ConvBertPreTrainedModel: () => i.ConvBertPreTrainedModel, ConvBertTokenizer: () => s.ConvBertTokenizer, ConvNextFeatureExtractor: () => a.ConvNextFeatureExtractor, ConvNextForImageClassification: () => i.ConvNextForImageClassification, ConvNextImageProcessor: () => a.ConvNextImageProcessor, ConvNextModel: () => i.ConvNextModel, ConvNextPreTrainedModel: () => i.ConvNextPreTrainedModel, ConvNextV2ForImageClassification: () => i.ConvNextV2ForImageClassification, ConvNextV2Model: () => i.ConvNextV2Model, ConvNextV2PreTrainedModel: () => i.ConvNextV2PreTrainedModel, DPTFeatureExtractor: () => a.DPTFeatureExtractor, DPTForDepthEstimation: () => i.DPTForDepthEstimation, DPTImageProcessor: () => a.DPTImageProcessor, DPTModel: () => i.DPTModel, DPTPreTrainedModel: () => i.DPTPreTrainedModel, DebertaForMaskedLM: () => i.DebertaForMaskedLM, DebertaForQuestionAnswering: () => i.DebertaForQuestionAnswering, DebertaForSequenceClassification: () => i.DebertaForSequenceClassification, DebertaForTokenClassification: () => i.DebertaForTokenClassification, DebertaModel: () => i.DebertaModel, DebertaPreTrainedModel: () => i.DebertaPreTrainedModel, DebertaTokenizer: () => s.DebertaTokenizer, DebertaV2ForMaskedLM: () => i.DebertaV2ForMaskedLM, DebertaV2ForQuestionAnswering: () => i.DebertaV2ForQuestionAnswering, DebertaV2ForSequenceClassification: () => i.DebertaV2ForSequenceClassification, DebertaV2ForTokenClassification: () => i.DebertaV2ForTokenClassification, DebertaV2Model: () => i.DebertaV2Model, DebertaV2PreTrainedModel: () => i.DebertaV2PreTrainedModel, DebertaV2Tokenizer: () => s.DebertaV2Tokenizer, DeiTFeatureExtractor: () => a.DeiTFeatureExtractor, DeiTForImageClassification: () => i.DeiTForImageClassification, DeiTModel: () => i.DeiTModel, DeiTPreTrainedModel: () => i.DeiTPreTrainedModel, DepthAnythingForDepthEstimation: () => i.DepthAnythingForDepthEstimation, DepthAnythingPreTrainedModel: () => i.DepthAnythingPreTrainedModel, DepthEstimationPipeline: () => r.DepthEstimationPipeline, DetrFeatureExtractor: () => a.DetrFeatureExtractor, DetrForObjectDetection: () => i.DetrForObjectDetection, DetrForSegmentation: () => i.DetrForSegmentation, DetrModel: () => i.DetrModel, DetrObjectDetectionOutput: () => i.DetrObjectDetectionOutput, DetrPreTrainedModel: () => i.DetrPreTrainedModel, DetrSegmentationOutput: () => i.DetrSegmentationOutput, Dinov2ForImageClassification: () => i.Dinov2ForImageClassification, Dinov2Model: () => i.Dinov2Model, Dinov2PreTrainedModel: () => i.Dinov2PreTrainedModel, DistilBertForMaskedLM: () => i.DistilBertForMaskedLM, DistilBertForQuestionAnswering: () => i.DistilBertForQuestionAnswering, DistilBertForSequenceClassification: () => i.DistilBertForSequenceClassification, DistilBertForTokenClassification: () => i.DistilBertForTokenClassification, DistilBertModel: () => i.DistilBertModel, DistilBertPreTrainedModel: () => i.DistilBertPreTrainedModel, DistilBertTokenizer: () => s.DistilBertTokenizer, DocumentQuestionAnsweringPipeline: () => r.DocumentQuestionAnsweringPipeline, DonutFeatureExtractor: () => a.DonutFeatureExtractor, DonutSwinModel: () => i.DonutSwinModel, DonutSwinPreTrainedModel: () => i.DonutSwinPreTrainedModel, EfficientNetForImageClassification: () => i.EfficientNetForImageClassification, EfficientNetImageProcessor: () => a.EfficientNetImageProcessor, EfficientNetModel: () => i.EfficientNetModel, EfficientNetPreTrainedModel: () => i.EfficientNetPreTrainedModel, ElectraForMaskedLM: () => i.ElectraForMaskedLM, ElectraForQuestionAnswering: () => i.ElectraForQuestionAnswering, ElectraForSequenceClassification: () => i.ElectraForSequenceClassification, ElectraForTokenClassification: () => i.ElectraForTokenClassification, ElectraModel: () => i.ElectraModel, ElectraPreTrainedModel: () => i.ElectraPreTrainedModel, ElectraTokenizer: () => s.ElectraTokenizer, EsmForMaskedLM: () => i.EsmForMaskedLM, EsmForSequenceClassification: () => i.EsmForSequenceClassification, EsmForTokenClassification: () => i.EsmForTokenClassification, EsmModel: () => i.EsmModel, EsmPreTrainedModel: () => i.EsmPreTrainedModel, EsmTokenizer: () => s.EsmTokenizer, FFT: () => d.FFT, FalconForCausalLM: () => i.FalconForCausalLM, FalconModel: () => i.FalconModel, FalconPreTrainedModel: () => i.FalconPreTrainedModel, FalconTokenizer: () => s.FalconTokenizer, FeatureExtractionPipeline: () => r.FeatureExtractionPipeline, FeatureExtractor: () => a.FeatureExtractor, FillMaskPipeline: () => r.FillMaskPipeline, GLPNFeatureExtractor: () => a.GLPNFeatureExtractor, GLPNForDepthEstimation: () => i.GLPNForDepthEstimation, GLPNModel: () => i.GLPNModel, GLPNPreTrainedModel: () => i.GLPNPreTrainedModel, GPT2LMHeadModel: () => i.GPT2LMHeadModel, GPT2Model: () => i.GPT2Model, GPT2PreTrainedModel: () => i.GPT2PreTrainedModel, GPT2Tokenizer: () => s.GPT2Tokenizer, GPTBigCodeForCausalLM: () => i.GPTBigCodeForCausalLM, GPTBigCodeModel: () => i.GPTBigCodeModel, GPTBigCodePreTrainedModel: () => i.GPTBigCodePreTrainedModel, GPTJForCausalLM: () => i.GPTJForCausalLM, GPTJModel: () => i.GPTJModel, GPTJPreTrainedModel: () => i.GPTJPreTrainedModel, GPTNeoForCausalLM: () => i.GPTNeoForCausalLM, GPTNeoModel: () => i.GPTNeoModel, GPTNeoPreTrainedModel: () => i.GPTNeoPreTrainedModel, GPTNeoXForCausalLM: () => i.GPTNeoXForCausalLM, GPTNeoXModel: () => i.GPTNeoXModel, GPTNeoXPreTrainedModel: () => i.GPTNeoXPreTrainedModel, GPTNeoXTokenizer: () => s.GPTNeoXTokenizer, GemmaTokenizer: () => s.GemmaTokenizer, Grok1Tokenizer: () => s.Grok1Tokenizer, HerbertTokenizer: () => s.HerbertTokenizer, HubertForCTC: () => i.HubertForCTC, HubertForSequenceClassification: () => i.HubertForSequenceClassification, HubertModel: () => i.HubertModel, HubertPreTrainedModel: () => i.HubertPreTrainedModel, ImageClassificationPipeline: () => r.ImageClassificationPipeline, ImageFeatureExtractionPipeline: () => r.ImageFeatureExtractionPipeline, ImageFeatureExtractor: () => a.ImageFeatureExtractor, ImageMattingOutput: () => i.ImageMattingOutput, ImageSegmentationPipeline: () => r.ImageSegmentationPipeline, ImageToImagePipeline: () => r.ImageToImagePipeline, ImageToTextPipeline: () => r.ImageToTextPipeline, LlamaForCausalLM: () => i.LlamaForCausalLM, LlamaModel: () => i.LlamaModel, LlamaPreTrainedModel: () => i.LlamaPreTrainedModel, LlamaTokenizer: () => s.LlamaTokenizer, LongT5ForConditionalGeneration: () => i.LongT5ForConditionalGeneration, LongT5Model: () => i.LongT5Model, LongT5PreTrainedModel: () => i.LongT5PreTrainedModel, M2M100ForConditionalGeneration: () => i.M2M100ForConditionalGeneration, M2M100Model: () => i.M2M100Model, M2M100PreTrainedModel: () => i.M2M100PreTrainedModel, M2M100Tokenizer: () => s.M2M100Tokenizer, MBart50Tokenizer: () => s.MBart50Tokenizer, MBartForCausalLM: () => i.MBartForCausalLM, MBartForConditionalGeneration: () => i.MBartForConditionalGeneration, MBartForSequenceClassification: () => i.MBartForSequenceClassification, MBartModel: () => i.MBartModel, MBartPreTrainedModel: () => i.MBartPreTrainedModel, MBartTokenizer: () => s.MBartTokenizer, MPNetForMaskedLM: () => i.MPNetForMaskedLM, MPNetForQuestionAnswering: () => i.MPNetForQuestionAnswering, MPNetForSequenceClassification: () => i.MPNetForSequenceClassification, MPNetForTokenClassification: () => i.MPNetForTokenClassification, MPNetModel: () => i.MPNetModel, MPNetPreTrainedModel: () => i.MPNetPreTrainedModel, MPNetTokenizer: () => s.MPNetTokenizer, MT5ForConditionalGeneration: () => i.MT5ForConditionalGeneration, MT5Model: () => i.MT5Model, MT5PreTrainedModel: () => i.MT5PreTrainedModel, MarianMTModel: () => i.MarianMTModel, MarianModel: () => i.MarianModel, MarianPreTrainedModel: () => i.MarianPreTrainedModel, MarianTokenizer: () => s.MarianTokenizer, MaskedLMOutput: () => i.MaskedLMOutput, MistralForCausalLM: () => i.MistralForCausalLM, MistralModel: () => i.MistralModel, MistralPreTrainedModel: () => i.MistralPreTrainedModel, MobileBertForMaskedLM: () => i.MobileBertForMaskedLM, MobileBertForQuestionAnswering: () => i.MobileBertForQuestionAnswering, MobileBertForSequenceClassification: () => i.MobileBertForSequenceClassification, MobileBertModel: () => i.MobileBertModel, MobileBertPreTrainedModel: () => i.MobileBertPreTrainedModel, MobileBertTokenizer: () => s.MobileBertTokenizer, MobileViTFeatureExtractor: () => a.MobileViTFeatureExtractor, MobileViTForImageClassification: () => i.MobileViTForImageClassification, MobileViTModel: () => i.MobileViTModel, MobileViTPreTrainedModel: () => i.MobileViTPreTrainedModel, ModelOutput: () => i.ModelOutput, MptForCausalLM: () => i.MptForCausalLM, MptModel: () => i.MptModel, MptPreTrainedModel: () => i.MptPreTrainedModel, NllbTokenizer: () => s.NllbTokenizer, NomicBertModel: () => i.NomicBertModel, NomicBertPreTrainedModel: () => i.NomicBertPreTrainedModel, NougatImageProcessor: () => a.NougatImageProcessor, NougatTokenizer: () => s.NougatTokenizer, OPTForCausalLM: () => i.OPTForCausalLM, OPTModel: () => i.OPTModel, OPTPreTrainedModel: () => i.OPTPreTrainedModel, ObjectDetectionPipeline: () => r.ObjectDetectionPipeline, OwlViTFeatureExtractor: () => a.OwlViTFeatureExtractor, OwlViTForObjectDetection: () => i.OwlViTForObjectDetection, OwlViTModel: () => i.OwlViTModel, OwlViTPreTrainedModel: () => i.OwlViTPreTrainedModel, OwlViTProcessor: () => a.OwlViTProcessor, Owlv2ForObjectDetection: () => i.Owlv2ForObjectDetection, Owlv2ImageProcessor: () => a.Owlv2ImageProcessor, Owlv2Model: () => i.Owlv2Model, Owlv2PreTrainedModel: () => i.Owlv2PreTrainedModel, PhiForCausalLM: () => i.PhiForCausalLM, PhiModel: () => i.PhiModel, PhiPreTrainedModel: () => i.PhiPreTrainedModel, Pipeline: () => r.Pipeline, PreTrainedModel: () => i.PreTrainedModel, PreTrainedTokenizer: () => s.PreTrainedTokenizer, PretrainedConfig: () => l.PretrainedConfig, PretrainedMixin: () => i.PretrainedMixin, Processor: () => a.Processor, QuestionAnsweringModelOutput: () => i.QuestionAnsweringModelOutput, QuestionAnsweringPipeline: () => r.QuestionAnsweringPipeline, Qwen2ForCausalLM: () => i.Qwen2ForCausalLM, Qwen2Model: () => i.Qwen2Model, Qwen2PreTrainedModel: () => i.Qwen2PreTrainedModel, Qwen2Tokenizer: () => s.Qwen2Tokenizer, RawImage: () => u.RawImage, ResNetForImageClassification: () => i.ResNetForImageClassification, ResNetModel: () => i.ResNetModel, ResNetPreTrainedModel: () => i.ResNetPreTrainedModel, RoFormerForMaskedLM: () => i.RoFormerForMaskedLM, RoFormerForQuestionAnswering: () => i.RoFormerForQuestionAnswering, RoFormerForSequenceClassification: () => i.RoFormerForSequenceClassification, RoFormerForTokenClassification: () => i.RoFormerForTokenClassification, RoFormerModel: () => i.RoFormerModel, RoFormerPreTrainedModel: () => i.RoFormerPreTrainedModel, RoFormerTokenizer: () => s.RoFormerTokenizer, RobertaForMaskedLM: () => i.RobertaForMaskedLM, RobertaForQuestionAnswering: () => i.RobertaForQuestionAnswering, RobertaForSequenceClassification: () => i.RobertaForSequenceClassification, RobertaForTokenClassification: () => i.RobertaForTokenClassification, RobertaModel: () => i.RobertaModel, RobertaPreTrainedModel: () => i.RobertaPreTrainedModel, RobertaTokenizer: () => s.RobertaTokenizer, SamImageProcessor: () => a.SamImageProcessor, SamImageSegmentationOutput: () => i.SamImageSegmentationOutput, SamModel: () => i.SamModel, SamPreTrainedModel: () => i.SamPreTrainedModel, SamProcessor: () => a.SamProcessor, SeamlessM4TFeatureExtractor: () => a.SeamlessM4TFeatureExtractor, SegformerFeatureExtractor: () => a.SegformerFeatureExtractor, SegformerForImageClassification: () => i.SegformerForImageClassification, SegformerForSemanticSegmentation: () => i.SegformerForSemanticSegmentation, SegformerModel: () => i.SegformerModel, SegformerPreTrainedModel: () => i.SegformerPreTrainedModel, Seq2SeqLMOutput: () => i.Seq2SeqLMOutput, SequenceClassifierOutput: () => i.SequenceClassifierOutput, SiglipImageProcessor: () => a.SiglipImageProcessor, SiglipModel: () => i.SiglipModel, SiglipPreTrainedModel: () => i.SiglipPreTrainedModel, SiglipTextModel: () => i.SiglipTextModel, SiglipTokenizer: () => s.SiglipTokenizer, SiglipVisionModel: () => i.SiglipVisionModel, SpeechT5FeatureExtractor: () => a.SpeechT5FeatureExtractor, SpeechT5ForSpeechToText: () => i.SpeechT5ForSpeechToText, SpeechT5ForTextToSpeech: () => i.SpeechT5ForTextToSpeech, SpeechT5HifiGan: () => i.SpeechT5HifiGan, SpeechT5Model: () => i.SpeechT5Model, SpeechT5PreTrainedModel: () => i.SpeechT5PreTrainedModel, SpeechT5Processor: () => a.SpeechT5Processor, SpeechT5Tokenizer: () => s.SpeechT5Tokenizer, SqueezeBertForMaskedLM: () => i.SqueezeBertForMaskedLM, SqueezeBertForQuestionAnswering: () => i.SqueezeBertForQuestionAnswering, SqueezeBertForSequenceClassification: () => i.SqueezeBertForSequenceClassification, SqueezeBertModel: () => i.SqueezeBertModel, SqueezeBertPreTrainedModel: () => i.SqueezeBertPreTrainedModel, SqueezeBertTokenizer: () => s.SqueezeBertTokenizer, StableLmForCausalLM: () => i.StableLmForCausalLM, StableLmModel: () => i.StableLmModel, StableLmPreTrainedModel: () => i.StableLmPreTrainedModel, Starcoder2ForCausalLM: () => i.Starcoder2ForCausalLM, Starcoder2Model: () => i.Starcoder2Model, Starcoder2PreTrainedModel: () => i.Starcoder2PreTrainedModel, SummarizationPipeline: () => r.SummarizationPipeline, Swin2SRForImageSuperResolution: () => i.Swin2SRForImageSuperResolution, Swin2SRImageProcessor: () => a.Swin2SRImageProcessor, Swin2SRModel: () => i.Swin2SRModel, Swin2SRPreTrainedModel: () => i.Swin2SRPreTrainedModel, SwinForImageClassification: () => i.SwinForImageClassification, SwinModel: () => i.SwinModel, SwinPreTrainedModel: () => i.SwinPreTrainedModel, T5ForConditionalGeneration: () => i.T5ForConditionalGeneration, T5Model: () => i.T5Model, T5PreTrainedModel: () => i.T5PreTrainedModel, T5Tokenizer: () => s.T5Tokenizer, TableTransformerForObjectDetection: () => i.TableTransformerForObjectDetection, TableTransformerModel: () => i.TableTransformerModel, TableTransformerObjectDetectionOutput: () => i.TableTransformerObjectDetectionOutput, TableTransformerPreTrainedModel: () => i.TableTransformerPreTrainedModel, Tensor: () => p.Tensor, Text2TextGenerationPipeline: () => r.Text2TextGenerationPipeline, TextClassificationPipeline: () => r.TextClassificationPipeline, TextGenerationPipeline: () => r.TextGenerationPipeline, TextToAudioPipeline: () => r.TextToAudioPipeline, TokenClassificationPipeline: () => r.TokenClassificationPipeline, TokenClassifierOutput: () => i.TokenClassifierOutput, TokenizerModel: () => s.TokenizerModel, TrOCRForCausalLM: () => i.TrOCRForCausalLM, TrOCRPreTrainedModel: () => i.TrOCRPreTrainedModel, TranslationPipeline: () => r.TranslationPipeline, UniSpeechForCTC: () => i.UniSpeechForCTC, UniSpeechForSequenceClassification: () => i.UniSpeechForSequenceClassification, UniSpeechModel: () => i.UniSpeechModel, UniSpeechPreTrainedModel: () => i.UniSpeechPreTrainedModel, UniSpeechSatForAudioFrameClassification: () => i.UniSpeechSatForAudioFrameClassification, UniSpeechSatForCTC: () => i.UniSpeechSatForCTC, UniSpeechSatForSequenceClassification: () => i.UniSpeechSatForSequenceClassification, UniSpeechSatModel: () => i.UniSpeechSatModel, UniSpeechSatPreTrainedModel: () => i.UniSpeechSatPreTrainedModel, ViTFeatureExtractor: () => a.ViTFeatureExtractor, ViTForImageClassification: () => i.ViTForImageClassification, ViTImageProcessor: () => a.ViTImageProcessor, ViTModel: () => i.ViTModel, ViTPreTrainedModel: () => i.ViTPreTrainedModel, VisionEncoderDecoderModel: () => i.VisionEncoderDecoderModel, VitMatteForImageMatting: () => i.VitMatteForImageMatting, VitMatteImageProcessor: () => a.VitMatteImageProcessor, VitMattePreTrainedModel: () => i.VitMattePreTrainedModel, VitsModel: () => i.VitsModel, VitsModelOutput: () => i.VitsModelOutput, VitsPreTrainedModel: () => i.VitsPreTrainedModel, VitsTokenizer: () => s.VitsTokenizer, Wav2Vec2BertForCTC: () => i.Wav2Vec2BertForCTC, Wav2Vec2BertForSequenceClassification: () => i.Wav2Vec2BertForSequenceClassification, Wav2Vec2BertModel: () => i.Wav2Vec2BertModel, Wav2Vec2BertPreTrainedModel: () => i.Wav2Vec2BertPreTrainedModel, Wav2Vec2CTCTokenizer: () => s.Wav2Vec2CTCTokenizer, Wav2Vec2FeatureExtractor: () => a.Wav2Vec2FeatureExtractor, Wav2Vec2ForAudioFrameClassification: () => i.Wav2Vec2ForAudioFrameClassification, Wav2Vec2ForCTC: () => i.Wav2Vec2ForCTC, Wav2Vec2ForSequenceClassification: () => i.Wav2Vec2ForSequenceClassification, Wav2Vec2Model: () => i.Wav2Vec2Model, Wav2Vec2PreTrainedModel: () => i.Wav2Vec2PreTrainedModel, Wav2Vec2ProcessorWithLM: () => a.Wav2Vec2ProcessorWithLM, WavLMForAudioFrameClassification: () => i.WavLMForAudioFrameClassification, WavLMForCTC: () => i.WavLMForCTC, WavLMForSequenceClassification: () => i.WavLMForSequenceClassification, WavLMForXVector: () => i.WavLMForXVector, WavLMModel: () => i.WavLMModel, WavLMPreTrainedModel: () => i.WavLMPreTrainedModel, WhisperFeatureExtractor: () => a.WhisperFeatureExtractor, WhisperForConditionalGeneration: () => i.WhisperForConditionalGeneration, WhisperModel: () => i.WhisperModel, WhisperPreTrainedModel: () => i.WhisperPreTrainedModel, WhisperProcessor: () => a.WhisperProcessor, WhisperTokenizer: () => s.WhisperTokenizer, XLMForQuestionAnswering: () => i.XLMForQuestionAnswering, XLMForSequenceClassification: () => i.XLMForSequenceClassification, XLMForTokenClassification: () => i.XLMForTokenClassification, XLMModel: () => i.XLMModel, XLMPreTrainedModel: () => i.XLMPreTrainedModel, XLMRobertaForMaskedLM: () => i.XLMRobertaForMaskedLM, XLMRobertaForQuestionAnswering: () => i.XLMRobertaForQuestionAnswering, XLMRobertaForSequenceClassification: () => i.XLMRobertaForSequenceClassification, XLMRobertaForTokenClassification: () => i.XLMRobertaForTokenClassification, XLMRobertaModel: () => i.XLMRobertaModel, XLMRobertaPreTrainedModel: () => i.XLMRobertaPreTrainedModel, XLMRobertaTokenizer: () => s.XLMRobertaTokenizer, XLMTokenizer: () => s.XLMTokenizer, XLMWithLMHeadModel: () => i.XLMWithLMHeadModel, XVectorOutput: () => i.XVectorOutput, YolosFeatureExtractor: () => a.YolosFeatureExtractor, YolosForObjectDetection: () => i.YolosForObjectDetection, YolosModel: () => i.YolosModel, YolosObjectDetectionOutput: () => i.YolosObjectDetectionOutput, YolosPreTrainedModel: () => i.YolosPreTrainedModel, ZeroShotAudioClassificationPipeline: () => r.ZeroShotAudioClassificationPipeline, ZeroShotClassificationPipeline: () => r.ZeroShotClassificationPipeline, ZeroShotImageClassificationPipeline: () => r.ZeroShotImageClassificationPipeline, ZeroShotObjectDetectionPipeline: () => r.ZeroShotObjectDetectionPipeline, bankers_round: () => d.bankers_round, cat: () => p.cat, cos_sim: () => d.cos_sim, dot: () => d.dot, dynamicTimeWarping: () => p.dynamicTimeWarping, env: () => o.env, getTopItems: () => d.getTopItems, hanning: () => c.hanning, interpolate: () => p.interpolate, interpolate_data: () => d.interpolate_data, layer_norm: () => p.layer_norm, log_softmax: () => d.log_softmax, magnitude: () => d.magnitude, max: () => d.max, mean: () => p.mean, mean_pooling: () => p.mean_pooling, medianFilter: () => d.medianFilter, mel_filter_bank: () => c.mel_filter_bank, min: () => d.min, ones: () => p.ones, ones_like: () => p.ones_like, permute: () => p.permute, permute_data: () => d.permute_data, pipeline: () => r.pipeline, quantize_embeddings: () => p.quantize_embeddings, read_audio: () => c.read_audio, round: () => d.round, softmax: () => d.softmax, spectrogram: () => c.spectrogram, stack: () => p.stack, std_mean: () => p.std_mean, window_function: () => c.window_function });
      var r = n(
        /*! ./pipelines.js */
        "./src/pipelines.js"
      ), o = n(
        /*! ./env.js */
        "./src/env.js"
      ), i = n(
        /*! ./models.js */
        "./src/models.js"
      ), s = n(
        /*! ./tokenizers.js */
        "./src/tokenizers.js"
      ), a = n(
        /*! ./processors.js */
        "./src/processors.js"
      ), l = n(
        /*! ./configs.js */
        "./src/configs.js"
      ), c = n(
        /*! ./utils/audio.js */
        "./src/utils/audio.js"
      ), u = n(
        /*! ./utils/image.js */
        "./src/utils/image.js"
      ), p = n(
        /*! ./utils/tensor.js */
        "./src/utils/tensor.js"
      ), d = n(
        /*! ./utils/maths.js */
        "./src/utils/maths.js"
      );
    }
  ), "./src/utils/audio.js": (
    /*!****************************!*\
      !*** ./src/utils/audio.js ***!
      \****************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { hanning: () => a, mel_filter_bank: () => d, read_audio: () => s, spectrogram: () => h, window_function: () => f });
      var r = n(
        /*! ./hub.js */
        "./src/utils/hub.js"
      ), o = n(
        /*! ./maths.js */
        "./src/utils/maths.js"
      ), i = n(
        /*! ./core.js */
        "./src/utils/core.js"
      );
      async function s(e3, t2) {
        if ("undefined" == typeof AudioContext) throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");
        const n2 = await (await (0, r.getFile)(e3)).arrayBuffer(), o2 = new AudioContext({ sampleRate: t2 });
        void 0 === t2 && console.warn(`No sampling rate provided, using default of ${o2.sampleRate}Hz.`);
        const i2 = await o2.decodeAudioData(n2);
        let s2;
        if (2 === i2.numberOfChannels) {
          const e4 = Math.sqrt(2), t3 = i2.getChannelData(0), n3 = i2.getChannelData(1);
          s2 = new Float32Array(t3.length);
          for (let r2 = 0; r2 < i2.length; ++r2) s2[r2] = e4 * (t3[r2] + n3[r2]) / 2;
        } else s2 = i2.getChannelData(0);
        return s2;
      }
      function a(e3) {
        if (e3 < 1) return new Float64Array();
        if (1 === e3) return new Float64Array([1]);
        const t2 = e3 - 1, n2 = Math.PI / t2, r2 = new Float64Array(e3);
        for (let o2 = 0; o2 < e3; ++o2) {
          const e4 = 2 * o2 - t2;
          r2[o2] = 0.5 + 0.5 * Math.cos(n2 * e4);
        }
        return r2;
      }
      const l = { htk: (e3) => 2595 * Math.log10(1 + e3 / 700), kaldi: (e3) => 1127 * Math.log(1 + e3 / 700), slaney: (e3, t2 = 1e3, n2 = 15, r2 = 27 / Math.log(6.4)) => e3 >= t2 ? n2 + Math.log(e3 / t2) * r2 : 3 * e3 / 200 };
      function c(e3, t2 = "htk") {
        const n2 = l[t2];
        if (!n2) throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
        return "number" == typeof e3 ? n2(e3) : e3.map(((e4) => n2(e4)));
      }
      const u = { htk: (e3) => 700 * (10 ** (e3 / 2595) - 1), kaldi: (e3) => 700 * (Math.exp(e3 / 1127) - 1), slaney: (e3, t2 = 1e3, n2 = 15, r2 = Math.log(6.4) / 27) => e3 >= n2 ? t2 * Math.exp(r2 * (e3 - n2)) : 200 * e3 / 3 };
      function p(e3, t2, n2) {
        const r2 = (t2 - e3) / (n2 - 1);
        return Float64Array.from({ length: n2 }, ((t3, n3) => e3 + r2 * n3));
      }
      function d(e3, t2, n2, r2, o2, i2 = null, s2 = "htk", a2 = false) {
        if (null !== i2 && "slaney" !== i2) throw new Error('norm must be one of null or "slaney"');
        const l2 = p(c(n2, s2), c(r2, s2), t2 + 2);
        let d2, _2 = (function(e4, t3 = "htk") {
          const n3 = u[t3];
          if (!n3) throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
          return "number" == typeof e4 ? n3(e4) : e4.map(((e5) => n3(e5)));
        })(l2, s2);
        if (a2) {
          const t3 = o2 / (2 * e3);
          d2 = c(Float64Array.from({ length: e3 }, ((e4, n3) => n3 * t3)), s2), _2 = l2;
        } else d2 = p(0, Math.floor(o2 / 2), e3);
        const h2 = (function(e4, t3) {
          const n3 = Float64Array.from({ length: t3.length - 1 }, ((e5, n4) => t3[n4 + 1] - t3[n4])), r3 = Array.from({ length: e4.length }, (() => new Array(t3.length)));
          for (let n4 = 0; n4 < e4.length; ++n4) {
            const o4 = r3[n4];
            for (let r4 = 0; r4 < t3.length; ++r4) o4[r4] = t3[r4] - e4[n4];
          }
          const o3 = t3.length - 2, i3 = Array.from({ length: o3 }, (() => new Array(e4.length)));
          for (let t4 = 0; t4 < e4.length; ++t4) {
            const e5 = r3[t4];
            for (let r4 = 0; r4 < o3; ++r4) {
              const o4 = -e5[r4] / n3[r4], s3 = e5[r4 + 2] / n3[r4 + 1];
              i3[r4][t4] = Math.max(0, Math.min(o4, s3));
            }
          }
          return i3;
        })(d2, _2);
        if (null !== i2 && "slaney" === i2) for (let n3 = 0; n3 < t2; ++n3) {
          const t3 = h2[n3], r3 = 2 / (_2[n3 + 2] - _2[n3]);
          for (let n4 = 0; n4 < e3; ++n4) t3[n4] *= r3;
        }
        return h2;
      }
      function _(e3, t2, n2, r2, i2) {
        if (n2 <= 0) throw new Error("reference must be greater than zero");
        if (r2 <= 0) throw new Error("min_value must be greater than zero");
        n2 = Math.max(r2, n2);
        const s2 = Math.log10(n2);
        for (let n3 = 0; n3 < e3.length; ++n3) e3[n3] = t2 * Math.log10(Math.max(r2, e3[n3]) - s2);
        if (null !== i2) {
          if (i2 <= 0) throw new Error("db_range must be greater than zero");
          const t3 = (0, o.max)(e3)[0] - i2;
          for (let n3 = 0; n3 < e3.length; ++n3) e3[n3] = Math.max(e3[n3], t3);
        }
        return e3;
      }
      function h(e3, t2, n2, r2, { fft_length: s2 = null, power: a2 = 1, center: l2 = true, pad_mode: c2 = "reflect", onesided: u2 = true, preemphasis: p2 = null, mel_filters: d2 = null, mel_floor: h2 = 1e-10, log_mel: f2 = null, reference: m = 1, min_value: g = 1e-10, db_range: b = null, remove_dc_offset: w = null, max_num_frames: x = null, do_pad: y = true, transpose: T = false } = {}) {
        const v = t2.length;
        if (null === s2 && (s2 = n2), n2 > s2) throw Error(`frame_length (${n2}) may not be larger than fft_length (${s2})`);
        if (v !== n2) throw new Error(`Length of the window (${v}) must equal frame_length (${n2})`);
        if (r2 <= 0) throw new Error("hop_length must be greater than zero");
        if (l2) {
          if ("reflect" !== c2) throw new Error(`pad_mode="${c2}" not implemented yet.`);
          const t3 = Math.floor((s2 - 1) / 2) + 1;
          e3 = (function(e4, t4, n3) {
            const r3 = new e4.constructor(e4.length + t4 + n3), o2 = e4.length - 1;
            for (let n4 = 0; n4 < e4.length; ++n4) r3[t4 + n4] = e4[n4];
            for (let n4 = 1; n4 <= t4; ++n4) r3[t4 - n4] = e4[(0, i.calculateReflectOffset)(n4, o2)];
            for (let s3 = 1; s3 <= n3; ++s3) r3[o2 + t4 + s3] = e4[(0, i.calculateReflectOffset)(o2 - s3, o2)];
            return r3;
          })(e3, t3, t3);
        }
        const k = Math.floor(1 + Math.floor((e3.length - n2) / r2)), M = u2 ? Math.floor(s2 / 2) + 1 : s2;
        let S = k, P = k;
        null !== x && (x > k ? y && (P = x) : P = S = x);
        const A = new o.FFT(s2), F = new Float64Array(s2), C = new Float64Array(A.outputBufferSize), E = new Array(S);
        for (let o2 = 0; o2 < S; ++o2) {
          const i2 = o2 * r2;
          for (let t3 = 0; t3 < n2; ++t3) F[t3] = e3[i2 + t3];
          if (w) {
            let e4 = 0;
            for (let t4 = 0; t4 < n2; ++t4) e4 += F[t4];
            const t3 = e4 / n2;
            for (let e5 = 0; e5 < n2; ++e5) F[e5] -= t3;
          }
          if (null !== p2) {
            for (let e4 = n2 - 1; e4 >= 1; --e4) F[e4] -= p2 * F[e4 - 1];
            F[0] *= 1 - p2;
          }
          for (let e4 = 0; e4 < t2.length; ++e4) F[e4] *= t2[e4];
          A.realTransform(C, F);
          const s3 = new Array(M);
          for (let e4 = 0; e4 < s3.length; ++e4) {
            const t3 = e4 << 1;
            s3[e4] = C[t3] ** 2 + C[t3 + 1] ** 2;
          }
          E[o2] = s3;
        }
        if (null !== a2 && 2 !== a2) {
          const e4 = 2 / a2;
          for (let t3 = 0; t3 < E.length; ++t3) {
            const n3 = E[t3];
            for (let t4 = 0; t4 < n3.length; ++t4) n3[t4] **= e4;
          }
        }
        const O = d2.length, I = new Float32Array(O * P), D = T ? [P, O] : [O, P];
        for (let e4 = 0; e4 < O; ++e4) {
          const t3 = d2[e4];
          for (let n3 = 0; n3 < S; ++n3) {
            const r3 = E[n3];
            let o2 = 0;
            for (let e5 = 0; e5 < M; ++e5) o2 += t3[e5] * r3[e5];
            I[T ? n3 * O + e4 : e4 * S + n3] = Math.max(h2, o2);
          }
        }
        if (null !== a2 && null !== f2) {
          const e4 = Math.min(I.length, S * O);
          switch (f2) {
            case "log":
              for (let t3 = 0; t3 < e4; ++t3) I[t3] = Math.log(I[t3]);
              break;
            case "log10":
              for (let t3 = 0; t3 < e4; ++t3) I[t3] = Math.log10(I[t3]);
              break;
            case "dB":
              if (1 === a2) !(function(e5, t3 = 1, n3 = 1e-5, r3 = null) {
                _(e5, 20, t3, n3, r3);
              })(I, m, g, b);
              else {
                if (2 !== a2) throw new Error(`Cannot use log_mel option '${f2}' with power ${a2}`);
                !(function(e5, t3 = 1, n3 = 1e-10, r3 = null) {
                  _(e5, 10, t3, n3, r3);
                })(I, m, g, b);
              }
              break;
            default:
              throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${f2}'`);
          }
        }
        return { data: I, dims: D };
      }
      function f(e3, t2, { periodic: n2 = true, frame_length: r2 = null, center: o2 = true } = {}) {
        const i2 = n2 ? e3 + 1 : e3;
        let s2;
        switch (t2) {
          case "boxcar":
            s2 = new Float64Array(i2).fill(1);
            break;
          case "hann":
          case "hann_window":
            s2 = a(i2);
            break;
          case "povey":
            s2 = a(i2).map(((e4) => Math.pow(e4, 0.85)));
            break;
          default:
            throw new Error(`Unknown window type ${t2}.`);
        }
        if (n2 && (s2 = s2.subarray(0, e3)), null === r2) return s2;
        if (e3 > r2) throw new Error(`Length of the window (${e3}) may not be larger than frame_length (${r2})`);
        return s2;
      }
    }
  ), "./src/utils/core.js": (
    /*!***************************!*\
      !*** ./src/utils/core.js ***!
      \***************************/
    (e2, t, n) => {
      function r(e3, t2) {
        e3 && e3(t2);
      }
      function o(e3) {
        return Object.fromEntries(Object.entries(e3).map((([e4, t2]) => [t2, e4])));
      }
      function i(e3) {
        return e3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      n.r(t), n.d(t, { Callable: () => s, calculateDimensions: () => u, calculateReflectOffset: () => h, dispatchCallback: () => r, escapeRegExp: () => i, exists: () => c, isIntegralNumber: () => l, isTypedArray: () => a, mergeArrays: () => d, pop: () => p, product: () => _, reverseDictionary: () => o });
      const s = class {
        constructor() {
          let e3 = function(...t2) {
            return e3._call(...t2);
          };
          return Object.setPrototypeOf(e3, new.target.prototype);
        }
        _call(...e3) {
          throw Error("Must implement _call method in subclass");
        }
      };
      function a(e3) {
        return "TypedArray" === e3?.prototype?.__proto__?.constructor?.name;
      }
      function l(e3) {
        return Number.isInteger(e3) || "bigint" == typeof e3;
      }
      function c(e3) {
        return null != e3;
      }
      function u(e3) {
        const t2 = [];
        let n2 = e3;
        for (; Array.isArray(n2); ) t2.push(n2.length), n2 = n2[0];
        return t2;
      }
      function p(e3, t2, n2 = void 0) {
        const r2 = e3[t2];
        if (void 0 !== r2) return delete e3[t2], r2;
        if (void 0 === n2) throw Error(`Key ${t2} does not exist in object.`);
        return n2;
      }
      function d(...e3) {
        return Array.prototype.concat.apply([], e3);
      }
      function _(...e3) {
        return e3.reduce(((e4, t2) => e4.flatMap(((e5) => t2.map(((t3) => [e5, t3]))))));
      }
      function h(e3, t2) {
        return Math.abs((e3 + t2) % (2 * t2) - t2);
      }
    }
  ), "./src/utils/data-structures.js": (
    /*!**************************************!*\
      !*** ./src/utils/data-structures.js ***!
      \**************************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { CharTrie: () => o, PriorityQueue: () => r, TokenLattice: () => s });
      class r {
        constructor(e3 = ((e4, t2) => e4 > t2)) {
          this._heap = [], this._comparator = e3;
        }
        get size() {
          return this._heap.length;
        }
        isEmpty() {
          return 0 === this.size;
        }
        peek() {
          return this._heap[0];
        }
        push(...e3) {
          return this.extend(e3);
        }
        extend(e3) {
          for (const t2 of e3) this._heap.push(t2), this._siftUp();
          return this.size;
        }
        pop() {
          const e3 = this.peek(), t2 = this.size - 1;
          return t2 > 0 && this._swap(0, t2), this._heap.pop(), this._siftDown(), e3;
        }
        replace(e3) {
          const t2 = this.peek();
          return this._heap[0] = e3, this._siftDown(), t2;
        }
        _parent(e3) {
          return (e3 + 1 >>> 1) - 1;
        }
        _left(e3) {
          return 1 + (e3 << 1);
        }
        _right(e3) {
          return e3 + 1 << 1;
        }
        _greater(e3, t2) {
          return this._comparator(this._heap[e3], this._heap[t2]);
        }
        _swap(e3, t2) {
          const n2 = this._heap[e3];
          this._heap[e3] = this._heap[t2], this._heap[t2] = n2;
        }
        _siftUp() {
          let e3 = this.size - 1;
          for (; e3 > 0 && this._greater(e3, this._parent(e3)); ) this._swap(e3, this._parent(e3)), e3 = this._parent(e3);
        }
        _siftDown() {
          let e3 = 0;
          for (; this._left(e3) < this.size && this._greater(this._left(e3), e3) || this._right(e3) < this.size && this._greater(this._right(e3), e3); ) {
            const t2 = this._right(e3) < this.size && this._greater(this._right(e3), this._left(e3)) ? this._right(e3) : this._left(e3);
            this._swap(e3, t2), e3 = t2;
          }
        }
      }
      class o {
        constructor() {
          this.root = i.default();
        }
        extend(e3) {
          for (let t2 of e3) this.push(t2);
        }
        push(e3) {
          let t2 = this.root;
          for (let n2 of e3) {
            let e4 = t2.children.get(n2);
            void 0 === e4 && (e4 = i.default(), t2.children.set(n2, e4)), t2 = e4;
          }
          t2.isLeaf = true;
        }
        *commonPrefixSearch(e3) {
          let t2 = this.root, n2 = "";
          for (let r2 = 0; r2 < e3.length && void 0 !== t2; ++r2) {
            const o2 = e3[r2];
            n2 += o2, t2 = t2.children.get(o2), void 0 !== t2 && t2.isLeaf && (yield n2);
          }
        }
      }
      class i {
        constructor(e3, t2) {
          this.isLeaf = e3, this.children = t2;
        }
        static default() {
          return new i(false, /* @__PURE__ */ new Map());
        }
      }
      class s {
        constructor(e3, t2, n2) {
          this.sentence = e3, this.len = e3.length, this.bosTokenId = t2, this.eosTokenId = n2, this.nodes = [], this.beginNodes = Array.from({ length: this.len + 1 }, (() => [])), this.endNodes = Array.from({ length: this.len + 1 }, (() => []));
          const r2 = new a(this.bosTokenId, 0, 0, 0, 0), o2 = new a(this.eosTokenId, 1, this.len, 0, 0);
          this.nodes.push(r2.clone()), this.nodes.push(o2.clone()), this.beginNodes[this.len].push(o2), this.endNodes[0].push(r2);
        }
        insert(e3, t2, n2, r2) {
          const o2 = this.nodes.length, i2 = new a(r2, o2, e3, t2, n2);
          this.beginNodes[e3].push(i2), this.endNodes[e3 + t2].push(i2), this.nodes.push(i2);
        }
        viterbi() {
          const e3 = this.len;
          let t2 = 0;
          for (; t2 <= e3; ) {
            if (0 == this.beginNodes[t2].length) return [];
            for (let e4 of this.beginNodes[t2]) {
              e4.prev = null;
              let n3 = 0, r3 = null;
              for (let o3 of this.endNodes[t2]) {
                const t3 = o3.backtraceScore + e4.score;
                (null === r3 || t3 > n3) && (r3 = o3.clone(), n3 = t3);
              }
              if (null === r3) return [];
              e4.prev = r3, e4.backtraceScore = n3;
            }
            ++t2;
          }
          const n2 = [], r2 = this.beginNodes[e3][0].prev;
          if (null === r2) return [];
          let o2 = r2.clone();
          for (; null !== o2.prev; ) {
            n2.push(o2.clone());
            const e4 = o2.clone();
            o2 = e4.prev.clone();
          }
          return n2.reverse(), n2;
        }
        piece(e3) {
          return this.sentence.slice(e3.pos, e3.pos + e3.length);
        }
        tokens() {
          return this.viterbi().map(((e3) => this.piece(e3)));
        }
        tokenIds() {
          return this.viterbi().map(((e3) => e3.tokenId));
        }
      }
      class a {
        constructor(e3, t2, n2, r2, o2) {
          this.tokenId = e3, this.nodeId = t2, this.pos = n2, this.length = r2, this.score = o2, this.prev = null, this.backtraceScore = 0;
        }
        clone() {
          const e3 = new a(this.tokenId, this.nodeId, this.pos, this.length, this.score);
          return e3.prev = this.prev, e3.backtraceScore = this.backtraceScore, e3;
        }
      }
    }
  ), "./src/utils/generation.js": (
    /*!*********************************!*\
      !*** ./src/utils/generation.js ***!
      \*********************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { ForceTokensLogitsProcessor: () => a, ForcedBOSTokenLogitsProcessor: () => l, ForcedEOSTokenLogitsProcessor: () => c, GenerationConfig: () => g, LogitsProcessor: () => s, LogitsProcessorList: () => i, MinLengthLogitsProcessor: () => h, MinNewTokensLengthLogitsProcessor: () => f, NoBadWordsLogitsProcessor: () => m, NoRepeatNGramLogitsProcessor: () => d, RepetitionPenaltyLogitsProcessor: () => _, Sampler: () => b, SuppressTokensAtBeginLogitsProcessor: () => u, WhisperTimeStampLogitsProcessor: () => p });
      n(
        /*! ./tensor.js */
        "./src/utils/tensor.js"
      );
      var r = n(
        /*! ./core.js */
        "./src/utils/core.js"
      ), o = n(
        /*! ./maths.js */
        "./src/utils/maths.js"
      );
      class i extends r.Callable {
        constructor() {
          super(), this.processors = [];
        }
        push(e3) {
          this.processors.push(e3);
        }
        extend(e3) {
          this.processors.push(...e3);
        }
        _call(e3, t2) {
          for (let n2 of t2) this.processors.forEach(((t3) => t3(e3, n2)));
        }
        [Symbol.iterator]() {
          return this.processors.values();
        }
      }
      class s extends r.Callable {
        _call(e3, t2) {
          throw Error("`_call` should be implemented in a subclass");
        }
      }
      class a extends s {
        constructor(e3) {
          super(), this.force_token_map = Object.fromEntries(e3 ?? []);
        }
        _call(e3, t2) {
          let n2 = this.force_token_map[e3.length];
          return (0, r.exists)(n2) && (t2.data.fill(-1 / 0), t2.data[n2] = 0), t2;
        }
      }
      class l extends s {
        constructor(e3) {
          super(), this.bos_token_id = e3;
        }
        _call(e3, t2) {
          return 1 === e3.length && (t2.data.fill(-1 / 0), t2.data[this.bos_token_id] = 0), t2;
        }
      }
      class c extends s {
        constructor(e3, t2) {
          super(), this.max_length = e3, this.forced_eos_token_id = t2;
        }
        _call(e3, t2) {
        }
      }
      class u extends s {
        constructor(e3, t2) {
          super(), this.begin_suppress_tokens = e3, this.begin_index = t2;
        }
        _call(e3, t2) {
          if (e3.length === this.begin_index) for (let e4 of this.begin_suppress_tokens) t2.data[e4] = -1 / 0;
          return t2;
        }
      }
      class p extends s {
        constructor(e3) {
          super(), this.eos_token_id = e3.eos_token_id, this.no_timestamps_token_id = e3.no_timestamps_token_id, this.timestamp_begin = this.no_timestamps_token_id + 1, this.begin_index = (e3.forced_decoder_ids || []).length + 2, e3.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id && (this.begin_index -= 1), this.max_initial_timestamp_index = e3.max_initial_timestamp_index;
        }
        _call(e3, t2) {
          const n2 = t2.data;
          if (n2[this.no_timestamps_token_id] = -1 / 0, e3.length === this.begin_index - 1) return n2.fill(-1 / 0), n2[this.timestamp_begin] = 0, t2;
          const r2 = e3.slice(this.begin_index), i2 = r2.length >= 1 && r2[r2.length - 1] >= this.timestamp_begin, s2 = r2.length < 2 || r2[r2.length - 2] >= this.timestamp_begin;
          if (i2 && (s2 ? n2.subarray(this.timestamp_begin).fill(-1 / 0) : n2.subarray(0, this.eos_token_id).fill(-1 / 0)), e3.length === this.begin_index && null !== this.max_initial_timestamp_index) {
            const e4 = this.timestamp_begin + this.max_initial_timestamp_index;
            n2.subarray(e4 + 1).fill(-1 / 0);
          }
          const a2 = (0, o.log_softmax)(n2);
          return Math.log(a2.subarray(this.timestamp_begin).map(Math.exp).reduce(((e4, t3) => e4 + t3))) > (0, o.max)(a2.subarray(0, this.timestamp_begin))[0] && n2.subarray(0, this.timestamp_begin).fill(-1 / 0), t2;
        }
      }
      class d extends s {
        constructor(e3) {
          super(), this.no_repeat_ngram_size = e3;
        }
        getNgrams(e3) {
          const t2 = e3.length, n2 = [];
          for (let r3 = 0; r3 < t2 + 1 - this.no_repeat_ngram_size; ++r3) {
            const t3 = [];
            for (let n3 = 0; n3 < this.no_repeat_ngram_size; ++n3) t3.push(e3[r3 + n3]);
            n2.push(t3);
          }
          const r2 = /* @__PURE__ */ new Map();
          for (const e4 of n2) {
            const t3 = e4.slice(0, e4.length - 1), n3 = JSON.stringify(t3), o2 = r2.get(n3) ?? [];
            o2.push(e4[e4.length - 1]), r2.set(n3, o2);
          }
          return r2;
        }
        getGeneratedNgrams(e3, t2) {
          const n2 = t2.slice(t2.length + 1 - this.no_repeat_ngram_size, t2.length);
          return e3.get(JSON.stringify(n2)) ?? [];
        }
        calcBannedNgramTokens(e3) {
          const t2 = [];
          if (e3.length + 1 < this.no_repeat_ngram_size) return t2;
          {
            const t3 = this.getNgrams(e3);
            return this.getGeneratedNgrams(t3, e3);
          }
        }
        _call(e3, t2) {
          const n2 = this.calcBannedNgramTokens(e3);
          for (const e4 of n2) t2.data[e4] = -1 / 0;
          return t2;
        }
      }
      class _ extends s {
        constructor(e3) {
          super(), this.penalty = e3;
        }
        _call(e3, t2) {
          for (const n2 of e3) t2.data[n2] < 0 ? t2.data[n2] *= this.penalty : t2.data[n2] /= this.penalty;
          return t2;
        }
      }
      class h extends s {
        constructor(e3, t2) {
          super(), this.min_length = e3, this.eos_token_id = Array.isArray(t2) ? t2 : [t2];
        }
        _call(e3, t2) {
          if (e3.length < this.min_length) for (const e4 of this.eos_token_id) t2.data[e4] = -1 / 0;
          return t2;
        }
      }
      class f extends s {
        constructor(e3, t2, n2) {
          super(), this.prompt_length_to_skip = e3, this.min_new_tokens = t2, this.eos_token_id = Array.isArray(n2) ? n2 : [n2];
        }
        _call(e3, t2) {
          if (e3.length - this.prompt_length_to_skip < this.min_new_tokens) for (const e4 of this.eos_token_id) t2.data[e4] = -1 / 0;
          return t2;
        }
      }
      class m extends s {
        constructor(e3, t2) {
          super(), this.bad_words_ids = e3, this.eos_token_id = Array.isArray(t2) ? t2 : [t2];
        }
        _call(e3, t2) {
          for (const n2 of this.bad_words_ids) {
            let r2 = true;
            for (let t3 = 1; t3 <= n2.length - 1 && n2.length < e3.length; ++t3) if (n2.at(-t3 - 1) !== e3.at(-t3)) {
              r2 = false;
              break;
            }
            r2 && (t2.data[n2.at(-1)] = -1 / 0);
          }
          return t2;
        }
      }
      const g = class {
        constructor(e3 = {}) {
          this.max_length = e3.max_length ?? 20, this.max_new_tokens = e3.max_new_tokens ?? null, this.min_length = e3.min_length ?? 0, this.min_new_tokens = e3.min_new_tokens ?? null, this.early_stopping = e3.early_stopping ?? false, this.max_time = e3.max_time ?? null, this.do_sample = e3.do_sample ?? false, this.num_beams = e3.num_beams ?? 1, this.num_beam_groups = e3.num_beam_groups ?? 1, this.penalty_alpha = e3.penalty_alpha ?? null, this.use_cache = e3.use_cache ?? true, this.temperature = e3.temperature ?? 1, this.top_k = e3.top_k ?? 50, this.top_p = e3.top_p ?? 1, this.typical_p = e3.typical_p ?? 1, this.epsilon_cutoff = e3.epsilon_cutoff ?? 0, this.eta_cutoff = e3.eta_cutoff ?? 0, this.diversity_penalty = e3.diversity_penalty ?? 0, this.repetition_penalty = e3.repetition_penalty ?? 1, this.encoder_repetition_penalty = e3.encoder_repetition_penalty ?? 1, this.length_penalty = e3.length_penalty ?? 1, this.no_repeat_ngram_size = e3.no_repeat_ngram_size ?? 0, this.bad_words_ids = e3.bad_words_ids ?? null, this.force_words_ids = e3.force_words_ids ?? null, this.renormalize_logits = e3.renormalize_logits ?? false, this.constraints = e3.constraints ?? null, this.forced_bos_token_id = e3.forced_bos_token_id ?? null, this.forced_eos_token_id = e3.forced_eos_token_id ?? null, this.remove_invalid_values = e3.remove_invalid_values ?? false, this.exponential_decay_length_penalty = e3.exponential_decay_length_penalty ?? null, this.suppress_tokens = e3.suppress_tokens ?? null, this.begin_suppress_tokens = e3.begin_suppress_tokens ?? null, this.forced_decoder_ids = e3.forced_decoder_ids ?? null, this.num_return_sequences = e3.num_return_sequences ?? 1, this.output_attentions = e3.output_attentions ?? false, this.output_hidden_states = e3.output_hidden_states ?? false, this.output_scores = e3.output_scores ?? false, this.return_dict_in_generate = e3.return_dict_in_generate ?? false, this.pad_token_id = e3.pad_token_id ?? null, this.bos_token_id = e3.bos_token_id ?? null, this.eos_token_id = e3.eos_token_id ?? null, this.encoder_no_repeat_ngram_size = e3.encoder_no_repeat_ngram_size ?? 0, this.decoder_start_token_id = e3.decoder_start_token_id ?? null, this.generation_kwargs = e3.generation_kwargs ?? {};
        }
      };
      class b extends r.Callable {
        constructor(e3) {
          super(), this.generation_config = e3;
        }
        _call(e3, t2 = -1) {
          return this.sample(e3, t2);
        }
        sample(e3, t2) {
          throw Error("sample should be implemented in subclasses.");
        }
        getLogits(e3, t2) {
          let n2 = e3.dims.at(-1), r2 = e3.data;
          if (-1 === t2) r2 = r2.slice(-n2);
          else {
            let e4 = t2 * n2;
            r2 = r2.slice(e4, e4 + n2);
          }
          return this.generation_config.temperature > 0 && (r2 = r2.map(((e4) => e4 / this.generation_config.temperature))), r2;
        }
        randomSelect(e3) {
          let t2 = e3.reduce(((e4, t3) => e4 + t3), 0), n2 = Math.random() * t2;
          for (let t3 = 0; t3 < e3.length; ++t3) if (n2 -= e3[t3], n2 <= 0) return t3;
          return 0;
        }
        static getSampler(e3) {
          if (e3.do_sample) return new x(e3);
          if (e3.num_beams > 1) return new y(e3);
          if (e3.num_return_sequences > 1) throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e3.num_return_sequences}.`);
          return new w(e3);
        }
      }
      class w extends b {
        sample(e3, t2 = -1) {
          let n2 = this.getLogits(e3, t2);
          return [[(0, o.max)(n2)[1], 0]];
        }
      }
      class x extends b {
        sample(e3, t2 = -1) {
          let n2 = e3.dims.at(-1);
          this.generation_config.top_k > 0 && (n2 = Math.min(this.generation_config.top_k, n2));
          const r2 = this.getLogits(e3, t2), i2 = (0, o.getTopItems)(r2, n2), s2 = (0, o.softmax)(i2.map(((e4) => e4[1])));
          return Array.from({ length: this.generation_config.num_beams }, (() => {
            const e4 = this.randomSelect(s2);
            return [i2[e4][0], Math.log(s2[e4])];
          }));
        }
      }
      class y extends b {
        sample(e3, t2 = -1) {
          let n2 = e3.dims.at(-1);
          this.generation_config.top_k > 0 && (n2 = Math.min(this.generation_config.top_k, n2));
          const r2 = this.getLogits(e3, t2), i2 = (0, o.getTopItems)(r2, n2), s2 = (0, o.softmax)(i2.map(((e4) => e4[1])));
          return Array.from({ length: this.generation_config.num_beams }, ((e4, t3) => [i2[t3][0], Math.log(s2[t3])]));
        }
      }
    }
  ), "./src/utils/hub.js": (
    /*!**************************!*\
      !*** ./src/utils/hub.js ***!
      \**************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { getFile: () => u, getModelFile: () => _, getModelJSON: () => h });
      var r = n(
        /*! fs */
        "?7a2c"
      ), o = n(
        /*! path */
        "?a42a"
      ), i = n(
        /*! stream/web */
        "?e65c"
      ), s = n(
        /*! ../env.js */
        "./src/env.js"
      ), a = n(
        /*! ./core.js */
        "./src/utils/core.js"
      );
      globalThis.ReadableStream || (globalThis.ReadableStream = i.ReadableStream);
      class l {
        _CONTENT_TYPE_MAP = { txt: "text/plain", html: "text/html", css: "text/css", js: "text/javascript", json: "application/json", png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg", gif: "image/gif" };
        constructor(e3) {
          if (this.filePath = e3, this.headers = new Headers(), this.exists = r.existsSync(e3), this.exists) {
            this.status = 200, this.statusText = "OK";
            let t2 = r.statSync(e3);
            this.headers.set("content-length", t2.size.toString()), this.updateContentType();
            let n2 = this;
            this.body = new ReadableStream({ start(e4) {
              n2.arrayBuffer().then(((t3) => {
                e4.enqueue(new Uint8Array(t3)), e4.close();
              }));
            } });
          } else this.status = 404, this.statusText = "Not Found", this.body = null;
        }
        updateContentType() {
          const e3 = this.filePath.toString().split(".").pop().toLowerCase();
          this.headers.set("content-type", this._CONTENT_TYPE_MAP[e3] ?? "application/octet-stream");
        }
        clone() {
          let e3 = new l(this.filePath);
          return e3.exists = this.exists, e3.status = this.status, e3.statusText = this.statusText, e3.headers = new Headers(this.headers), e3;
        }
        async arrayBuffer() {
          return (await r.promises.readFile(this.filePath)).buffer;
        }
        async blob() {
          const e3 = await r.promises.readFile(this.filePath);
          return new Blob([e3], { type: this.headers.get("content-type") });
        }
        async text() {
          return await r.promises.readFile(this.filePath, "utf8");
        }
        async json() {
          return JSON.parse(await this.text());
        }
      }
      function c(e3, t2 = null) {
        let n2;
        try {
          n2 = new URL(e3);
        } catch (e4) {
          return false;
        }
        return !(t2 && !t2.includes(n2.hostname)) && ("http:" === n2.protocol || "https:" === n2.protocol);
      }
      async function u(e3) {
        if (s.env.useFS && !c(e3)) return new l(e3);
        if ("undefined" != typeof process && "node" === process?.release?.name) {
          const t2 = !!process.env?.TESTING_REMOTELY, n2 = s.env.version, r2 = new Headers();
          r2.set("User-Agent", `transformers.js/${n2}; is_ci/${t2};`);
          if (c(e3, ["huggingface.co", "hf.co"])) {
            const e4 = process.env?.HF_TOKEN ?? process.env?.HF_ACCESS_TOKEN;
            e4 && r2.set("Authorization", `Bearer ${e4}`);
          }
          return fetch(e3, { headers: r2 });
        }
        return fetch(e3);
      }
      const p = { 400: "Bad request error occurred while trying to load file", 401: "Unauthorized access to file", 403: "Forbidden access to file", 404: "Could not locate file", 408: "Request timeout error occurred while trying to load file", 500: "Internal server error error occurred while trying to load file", 502: "Bad gateway error occurred while trying to load file", 503: "Service unavailable error occurred while trying to load file", 504: "Gateway timeout error occurred while trying to load file" };
      class d {
        constructor(e3) {
          this.path = e3;
        }
        async match(e3) {
          let t2 = o.join(this.path, e3), n2 = new l(t2);
          return n2.exists ? n2 : void 0;
        }
        async put(e3, t2) {
          const n2 = Buffer.from(await t2.arrayBuffer());
          let i2 = o.join(this.path, e3);
          try {
            await r.promises.mkdir(o.dirname(i2), { recursive: true }), await r.promises.writeFile(i2, n2);
          } catch (e4) {
            console.warn("An error occurred while writing the file to cache:", e4);
          }
        }
      }
      async function _(e3, t2, n2 = true, r2 = {}) {
        if (!s.env.allowLocalModels) {
          if (r2.local_files_only) throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");
          if (!s.env.allowRemoteModels) throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.");
        }
        let o2;
        if ((0, a.dispatchCallback)(r2.progress_callback, { status: "initiate", name: e3, file: t2 }), !o2 && s.env.useBrowserCache) {
          if ("undefined" == typeof caches) throw Error("Browser cache is not available in this environment.");
          try {
            o2 = await caches.open("transformers-cache");
          } catch (e4) {
            console.warn("An error occurred while opening the browser cache:", e4);
          }
        }
        if (!o2 && s.env.useFSCache && (o2 = new d(r2.cache_dir ?? s.env.cacheDir)), !o2 && s.env.useCustomCache) {
          if (!s.env.customCache) throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");
          if (!s.env.customCache.match || !s.env.customCache.put) throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");
          o2 = s.env.customCache;
        }
        const i2 = r2.revision ?? "main";
        let l2, _2, h2 = f(e3, t2), m = f(s.env.localModelPath, h2), g = f(s.env.remoteHost, s.env.remotePathTemplate.replaceAll("{model}", e3).replaceAll("{revision}", encodeURIComponent(i2)), t2), b = "main" === i2 ? h2 : f(e3, i2, t2), w = o2 instanceof d ? b : g, x = false;
        o2 && (_2 = await (async function(e4, ...t3) {
          for (let n3 of t3) try {
            let t4 = await e4.match(n3);
            if (t4) return t4;
          } catch (e5) {
            continue;
          }
        })(o2, m, w));
        const y = void 0 !== _2;
        if (void 0 === _2) {
          if (s.env.allowLocalModels) {
            if (c(h2)) {
              if (r2.local_files_only) throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${h2}.`);
              if (!s.env.allowRemoteModels) throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${h2}.`);
            } else try {
              _2 = await u(m), l2 = m;
            } catch (e4) {
              console.warn(`Unable to load from local path "${m}": "${e4}"`);
            }
          }
          if (void 0 === _2 || 404 === _2.status) {
            if (r2.local_files_only || !s.env.allowRemoteModels) {
              if (n2) throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${m}".`);
              return null;
            }
            if (_2 = await u(g), 200 !== _2.status) return (function(e4, t3, n3) {
              if (!n3) return null;
              const r3 = p[e4] ?? `Error (${e4}) occurred while trying to load file`;
              throw Error(`${r3}: "${t3}".`);
            })(_2.status, g, n2);
            l2 = w;
          }
          x = o2 && "undefined" != typeof Response && _2 instanceof Response && 200 === _2.status;
        }
        (0, a.dispatchCallback)(r2.progress_callback, { status: "download", name: e3, file: t2 });
        const T = { status: "progress", name: e3, file: t2 };
        let v;
        return r2.progress_callback ? y && "undefined" != typeof navigator && /firefox/i.test(navigator.userAgent) ? (v = new Uint8Array(await _2.arrayBuffer()), (0, a.dispatchCallback)(r2.progress_callback, { ...T, progress: 100, loaded: v.length, total: v.length })) : v = await (async function(e4, t3) {
          const n3 = e4.headers.get("Content-Length");
          null === n3 && console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");
          let r3 = parseInt(n3 ?? "0"), o3 = new Uint8Array(r3), i3 = 0;
          const s2 = e4.body.getReader();
          async function a2() {
            const { done: e5, value: n4 } = await s2.read();
            if (e5) return;
            let l3 = i3 + n4.length;
            if (l3 > r3) {
              r3 = l3;
              let e6 = new Uint8Array(r3);
              e6.set(o3), o3 = e6;
            }
            o3.set(n4, i3), i3 = l3;
            return t3({ progress: i3 / r3 * 100, loaded: i3, total: r3 }), a2();
          }
          return await a2(), o3;
        })(_2, ((e4) => {
          (0, a.dispatchCallback)(r2.progress_callback, { ...T, ...e4 });
        })) : v = new Uint8Array(await _2.arrayBuffer()), x && l2 && void 0 === await o2.match(l2) && await o2.put(l2, new Response(v, { headers: _2.headers })).catch(((e4) => {
          console.warn(`Unable to add response to browser cache: ${e4}.`);
        })), (0, a.dispatchCallback)(r2.progress_callback, { status: "done", name: e3, file: t2 }), v;
      }
      async function h(e3, t2, n2 = true, r2 = {}) {
        let o2 = await _(e3, t2, n2, r2);
        if (null === o2) return {};
        let i2 = new TextDecoder("utf-8").decode(o2);
        return JSON.parse(i2);
      }
      function f(...e3) {
        return (e3 = e3.map(((t2, n2) => (n2 && (t2 = t2.replace(new RegExp("^/"), "")), n2 !== e3.length - 1 && (t2 = t2.replace(new RegExp("/$"), "")), t2)))).join("/");
      }
    }
  ), "./src/utils/image.js": (
    /*!****************************!*\
      !*** ./src/utils/image.js ***!
      \****************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { RawImage: () => h });
      var r = n(
        /*! ./hub.js */
        "./src/utils/hub.js"
      ), o = n(
        /*! ../env.js */
        "./src/env.js"
      ), i = n(
        /*! ./tensor.js */
        "./src/utils/tensor.js"
      ), s = n(
        /*! sharp */
        "?2b25"
      );
      const a = "undefined" != typeof self, l = a && "DedicatedWorkerGlobalScope" === self.constructor.name;
      let c, u, p;
      if (a) c = (e3, t2) => {
        if (!self.OffscreenCanvas) throw new Error("OffscreenCanvas not supported by this browser.");
        return new self.OffscreenCanvas(e3, t2);
      }, p = self.createImageBitmap, u = self.ImageData;
      else {
        if (!s) throw new Error("Unable to load image processing library.");
        p = async (e3) => {
          const t2 = (await e3.metadata()).channels;
          let { data: n2, info: r2 } = await e3.raw().toBuffer({ resolveWithObject: true });
          const o2 = new h(new Uint8ClampedArray(n2), r2.width, r2.height, r2.channels);
          return void 0 !== t2 && t2 !== r2.channels && o2.convert(t2), o2;
        };
      }
      const d = { 0: "nearest", 1: "lanczos", 2: "bilinear", 3: "bicubic", 4: "box", 5: "hamming" }, _ = /* @__PURE__ */ new Map([["png", "image/png"], ["jpg", "image/jpeg"], ["jpeg", "image/jpeg"], ["gif", "image/gif"]]);
      class h {
        constructor(e3, t2, n2, r2) {
          this.data = e3, this.width = t2, this.height = n2, this.channels = r2;
        }
        get size() {
          return [this.width, this.height];
        }
        static async read(e3) {
          if (e3 instanceof h) return e3;
          if ("string" == typeof e3 || e3 instanceof URL) return await this.fromURL(e3);
          throw new Error("Unsupported input type: " + typeof e3);
        }
        static async fromURL(e3) {
          let t2 = await (0, r.getFile)(e3);
          if (200 !== t2.status) throw new Error(`Unable to read image from "${e3}" (${t2.status} ${t2.statusText})`);
          let n2 = await t2.blob();
          return this.fromBlob(n2);
        }
        static async fromBlob(e3) {
          if (a) {
            let t2 = await p(e3);
            const n2 = c(t2.width, t2.height).getContext("2d");
            return n2.drawImage(t2, 0, 0), new this(n2.getImageData(0, 0, t2.width, t2.height).data, t2.width, t2.height, 4);
          }
          {
            let t2 = s(await e3.arrayBuffer());
            return await p(t2);
          }
        }
        static fromTensor(e3, t2 = "CHW") {
          if (3 !== e3.dims.length) throw new Error(`Tensor should have 3 dimensions, but has ${e3.dims.length} dimensions.`);
          if ("CHW" === t2) e3 = e3.transpose(1, 2, 0);
          else if ("HWC" !== t2) throw new Error(`Unsupported channel format: ${t2}`);
          if (!(e3.data instanceof Uint8ClampedArray || e3.data instanceof Uint8Array)) throw new Error(`Unsupported tensor type: ${e3.type}`);
          switch (e3.dims[2]) {
            case 1:
            case 2:
            case 3:
            case 4:
              return new h(e3.data, e3.dims[1], e3.dims[0], e3.dims[2]);
            default:
              throw new Error(`Unsupported number of channels: ${e3.dims[2]}`);
          }
        }
        grayscale() {
          if (1 === this.channels) return this;
          let e3 = new Uint8ClampedArray(this.width * this.height * 1);
          switch (this.channels) {
            case 3:
            case 4:
              for (let t2 = 0, n2 = 0; t2 < this.data.length; t2 += this.channels) {
                const r2 = this.data[t2], o2 = this.data[t2 + 1], i2 = this.data[t2 + 2];
                e3[n2++] = Math.round(0.2989 * r2 + 0.587 * o2 + 0.114 * i2);
              }
              break;
            default:
              throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
          }
          return this._update(e3, this.width, this.height, 1);
        }
        rgb() {
          if (3 === this.channels) return this;
          let e3 = new Uint8ClampedArray(this.width * this.height * 3);
          switch (this.channels) {
            case 1:
              for (let t2 = 0, n2 = 0; t2 < this.data.length; ++t2) e3[n2++] = this.data[t2], e3[n2++] = this.data[t2], e3[n2++] = this.data[t2];
              break;
            case 4:
              for (let t2 = 0, n2 = 0; t2 < this.data.length; t2 += 4) e3[n2++] = this.data[t2], e3[n2++] = this.data[t2 + 1], e3[n2++] = this.data[t2 + 2];
              break;
            default:
              throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
          }
          return this._update(e3, this.width, this.height, 3);
        }
        rgba() {
          if (4 === this.channels) return this;
          let e3 = new Uint8ClampedArray(this.width * this.height * 4);
          switch (this.channels) {
            case 1:
              for (let t2 = 0, n2 = 0; t2 < this.data.length; ++t2) e3[n2++] = this.data[t2], e3[n2++] = this.data[t2], e3[n2++] = this.data[t2], e3[n2++] = 255;
              break;
            case 3:
              for (let t2 = 0, n2 = 0; t2 < this.data.length; t2 += 3) e3[n2++] = this.data[t2], e3[n2++] = this.data[t2 + 1], e3[n2++] = this.data[t2 + 2], e3[n2++] = 255;
              break;
            default:
              throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
          }
          return this._update(e3, this.width, this.height, 4);
        }
        async resize(e3, t2, { resample: n2 = 2 } = {}) {
          let r2 = d[n2] ?? n2;
          if (a) {
            let n3 = this.channels, r3 = this.toCanvas();
            const o2 = c(e3, t2).getContext("2d");
            return o2.drawImage(r3, 0, 0, e3, t2), new h(o2.getImageData(0, 0, e3, t2).data, e3, t2, 4).convert(n3);
          }
          {
            let n3 = this.toSharp();
            switch (r2) {
              case "box":
              case "hamming":
                "box" !== r2 && "hamming" !== r2 || (console.warn(`Resampling method ${r2} is not yet supported. Using bilinear instead.`), r2 = "bilinear");
              case "nearest":
              case "bilinear":
              case "bicubic":
                n3 = n3.affine([e3 / this.width, 0, 0, t2 / this.height], { interpolator: r2 });
                break;
              case "lanczos":
                n3 = n3.resize({ width: e3, height: t2, fit: "fill", kernel: "lanczos3" });
                break;
              default:
                throw new Error(`Resampling method ${r2} is not supported.`);
            }
            return await p(n3);
          }
        }
        async pad([e3, t2, n2, r2]) {
          if (e3 = Math.max(e3, 0), t2 = Math.max(t2, 0), n2 = Math.max(n2, 0), r2 = Math.max(r2, 0), 0 === e3 && 0 === t2 && 0 === n2 && 0 === r2) return this;
          if (a) {
            let o2 = this.channels, i2 = this.toCanvas(), s2 = this.width + e3 + t2, a2 = this.height + n2 + r2;
            const l2 = c(s2, a2).getContext("2d");
            return l2.drawImage(i2, 0, 0, this.width, this.height, e3, n2, s2, a2), new h(l2.getImageData(0, 0, s2, a2).data, s2, a2, 4).convert(o2);
          }
          {
            let o2 = this.toSharp().extend({ left: e3, right: t2, top: n2, bottom: r2 });
            return await p(o2);
          }
        }
        async crop([e3, t2, n2, r2]) {
          if (e3 = Math.max(e3, 0), t2 = Math.max(t2, 0), n2 = Math.min(n2, this.width - 1), r2 = Math.min(r2, this.height - 1), 0 === e3 && 0 === t2 && n2 === this.width - 1 && r2 === this.height - 1) return this;
          const o2 = n2 - e3 + 1, i2 = r2 - t2 + 1;
          if (a) {
            const n3 = this.channels, r3 = this.toCanvas(), s2 = c(o2, i2).getContext("2d");
            s2.drawImage(r3, e3, t2, o2, i2, 0, 0, o2, i2);
            return new h(s2.getImageData(0, 0, o2, i2).data, o2, i2, 4).convert(n3);
          }
          {
            const n3 = this.toSharp().extract({ left: e3, top: t2, width: o2, height: i2 });
            return await p(n3);
          }
        }
        async center_crop(e3, t2) {
          if (this.width === e3 && this.height === t2) return this;
          let n2 = (this.width - e3) / 2, r2 = (this.height - t2) / 2;
          if (a) {
            let o2 = this.channels, i2 = this.toCanvas();
            const s2 = c(e3, t2).getContext("2d");
            let a2 = 0, l2 = 0, u2 = 0, p2 = 0;
            return n2 >= 0 ? a2 = n2 : u2 = -n2, r2 >= 0 ? l2 = r2 : p2 = -r2, s2.drawImage(i2, a2, l2, e3, t2, u2, p2, e3, t2), new h(s2.getImageData(0, 0, e3, t2).data, e3, t2, 4).convert(o2);
          }
          {
            let o2 = this.toSharp();
            if (n2 >= 0 && r2 >= 0) o2 = o2.extract({ left: Math.floor(n2), top: Math.floor(r2), width: e3, height: t2 });
            else if (n2 <= 0 && r2 <= 0) {
              let i2 = Math.floor(-r2), s2 = Math.floor(-n2);
              o2 = o2.extend({ top: i2, left: s2, right: e3 - this.width - s2, bottom: t2 - this.height - i2 });
            } else {
              let i2 = [0, 0], s2 = 0;
              r2 < 0 ? (i2[0] = Math.floor(-r2), i2[1] = t2 - this.height - i2[0]) : s2 = Math.floor(r2);
              let a2 = [0, 0], l2 = 0;
              n2 < 0 ? (a2[0] = Math.floor(-n2), a2[1] = e3 - this.width - a2[0]) : l2 = Math.floor(n2), o2 = o2.extend({ top: i2[0], bottom: i2[1], left: a2[0], right: a2[1] }).extract({ left: l2, top: s2, width: e3, height: t2 });
            }
            return await p(o2);
          }
        }
        async toBlob(e3 = "image/png", t2 = 1) {
          if (!a) throw new Error("toBlob() is only supported in browser environments.");
          const n2 = this.toCanvas();
          return await n2.convertToBlob({ type: e3, quality: t2 });
        }
        toTensor(e3 = "CHW") {
          let t2 = new i.Tensor("uint8", new Uint8Array(this.data), [this.height, this.width, this.channels]);
          if ("HWC" === e3) ;
          else {
            if ("CHW" !== e3) throw new Error(`Unsupported channel format: ${e3}`);
            t2 = t2.permute(2, 0, 1);
          }
          return t2;
        }
        toCanvas() {
          if (!a) throw new Error("toCanvas() is only supported in browser environments.");
          let e3 = this.clone().rgba(), t2 = c(e3.width, e3.height), n2 = new u(e3.data, e3.width, e3.height);
          return t2.getContext("2d").putImageData(n2, 0, 0), t2;
        }
        _update(e3, t2, n2, r2 = null) {
          return this.data = e3, this.width = t2, this.height = n2, null !== r2 && (this.channels = r2), this;
        }
        clone() {
          return new h(this.data.slice(), this.width, this.height, this.channels);
        }
        convert(e3) {
          if (this.channels === e3) return this;
          switch (e3) {
            case 1:
              this.grayscale();
              break;
            case 3:
              this.rgb();
              break;
            case 4:
              this.rgba();
              break;
            default:
              throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
          }
          return this;
        }
        async save(e3) {
          if (!a) {
            if (o.env.useFS) {
              const t2 = this.toSharp();
              return await t2.toFile(e3);
            }
            throw new Error("Unable to save the image because filesystem is disabled in this environment.");
          }
          {
            if (l) throw new Error("Unable to save an image from a Web Worker.");
            const t2 = e3.split(".").pop().toLowerCase(), n2 = _.get(t2) ?? "image/png", r2 = await this.toBlob(n2), o2 = URL.createObjectURL(r2), i2 = document.createElement("a");
            i2.href = o2, i2.download = e3, i2.click(), i2.remove();
          }
        }
        toSharp() {
          if (a) throw new Error("toSharp() is only supported in server-side environments.");
          return s(this.data, { raw: { width: this.width, height: this.height, channels: this.channels } });
        }
      }
    }
  ), "./src/utils/maths.js": (
    /*!****************************!*\
      !*** ./src/utils/maths.js ***!
      \****************************/
    (e2, t, n) => {
      function r(e3, [t2, n2, r2], [o2, i2], s2 = "bilinear", a2 = false) {
        const l2 = i2 / r2, c2 = o2 / n2, u2 = new e3.constructor(o2 * i2 * t2), p2 = n2 * r2, d2 = o2 * i2;
        for (let s3 = 0; s3 < o2; ++s3) for (let o3 = 0; o3 < i2; ++o3) {
          const a3 = s3 * i2 + o3, _2 = (o3 + 0.5) / l2 - 0.5, h2 = (s3 + 0.5) / c2 - 0.5;
          let f2 = Math.floor(_2), m2 = Math.floor(h2);
          const g2 = Math.min(f2 + 1, r2 - 1), b2 = Math.min(m2 + 1, n2 - 1);
          f2 = Math.max(f2, 0), m2 = Math.max(m2, 0);
          const w2 = _2 - f2, x = h2 - m2, y = (1 - w2) * (1 - x), T = w2 * (1 - x), v = (1 - w2) * x, k = w2 * x, M = m2 * r2, S = b2 * r2, P = M + f2, A = M + g2, F = S + f2, C = S + g2;
          for (let n3 = 0; n3 < t2; ++n3) {
            const t3 = n3 * p2;
            u2[n3 * d2 + a3] = y * e3[t3 + P] + T * e3[t3 + A] + v * e3[t3 + F] + k * e3[t3 + C];
          }
        }
        return u2;
      }
      function o(e3, t2, n2) {
        const r2 = new Array(n2.length), o2 = new Array(n2.length);
        for (let e4 = n2.length - 1, i3 = 1; e4 >= 0; --e4) o2[e4] = i3, r2[e4] = t2[n2[e4]], i3 *= r2[e4];
        const i2 = n2.map(((e4, t3) => o2[n2.indexOf(t3)])), s2 = new e3.constructor(e3.length);
        for (let n3 = 0; n3 < e3.length; ++n3) {
          let r3 = 0;
          for (let e4 = t2.length - 1, o3 = n3; e4 >= 0; --e4) r3 += o3 % t2[e4] * i2[e4], o3 = Math.floor(o3 / t2[e4]);
          s2[r3] = e3[n3];
        }
        return [s2, r2];
      }
      function i(e3) {
        const t2 = d(e3)[0], n2 = e3.map(((e4) => Math.exp(e4 - t2))), r2 = n2.reduce(((e4, t3) => e4 + t3), 0);
        return n2.map(((e4) => e4 / r2));
      }
      function s(e3) {
        return i(e3).map(((e4) => Math.log(e4)));
      }
      function a(e3, t2) {
        let n2 = 0;
        for (let r2 = 0; r2 < e3.length; ++r2) n2 += e3[r2] * t2[r2];
        return n2;
      }
      function l(e3, t2 = 0) {
        return e3 = Array.from(e3).map(((e4, t3) => [t3, e4])).sort(((e4, t3) => t3[1] - e4[1])), null !== t2 && t2 > 0 && (e3 = e3.slice(0, t2)), e3;
      }
      function c(e3, t2) {
        return a(e3, t2) / (u(e3) * u(t2));
      }
      function u(e3) {
        return Math.sqrt(e3.reduce(((e4, t2) => e4 + t2 * t2), 0));
      }
      function p(e3) {
        if (0 === e3.length) throw Error("Array must not be empty");
        let t2 = e3[0], n2 = 0;
        for (let r2 = 1; r2 < e3.length; ++r2) e3[r2] < t2 && (t2 = e3[r2], n2 = r2);
        return [t2, n2];
      }
      function d(e3) {
        if (0 === e3.length) throw Error("Array must not be empty");
        let t2 = e3[0], n2 = 0;
        for (let r2 = 1; r2 < e3.length; ++r2) e3[r2] > t2 && (t2 = e3[r2], n2 = r2);
        return [Number(t2), n2];
      }
      function _(e3) {
        return e3 > 0 && 0 == (e3 & e3 - 1);
      }
      n.r(t), n.d(t, { FFT: () => m, bankers_round: () => w, cos_sim: () => c, dot: () => a, getTopItems: () => l, interpolate_data: () => r, log_softmax: () => s, magnitude: () => u, max: () => d, medianFilter: () => g, min: () => p, permute_data: () => o, round: () => b, softmax: () => i });
      class h {
        constructor(e3) {
          if (this.size = 0 | e3, this.size <= 1 || !_(this.size)) throw new Error("FFT size must be a power of two larger than 1");
          this._csize = e3 << 1, this.table = new Float64Array(2 * this.size);
          for (let e4 = 0; e4 < this.table.length; e4 += 2) {
            const t3 = Math.PI * e4 / this.size;
            this.table[e4] = Math.cos(t3), this.table[e4 + 1] = -Math.sin(t3);
          }
          let t2 = 0;
          for (let e4 = 1; this.size > e4; e4 <<= 1) ++t2;
          this._width = t2 % 2 == 0 ? t2 - 1 : t2, this._bitrev = new Int32Array(1 << this._width);
          for (let e4 = 0; e4 < this._bitrev.length; ++e4) {
            this._bitrev[e4] = 0;
            for (let t3 = 0; t3 < this._width; t3 += 2) {
              const n2 = this._width - t3 - 2;
              this._bitrev[e4] |= (e4 >>> t3 & 3) << n2;
            }
          }
        }
        createComplexArray() {
          return new Float64Array(this._csize);
        }
        fromComplexArray(e3, t2) {
          const n2 = t2 || new Array(e3.length >>> 1);
          for (let t3 = 0; t3 < e3.length; t3 += 2) n2[t3 >>> 1] = e3[t3];
          return n2;
        }
        toComplexArray(e3, t2) {
          const n2 = t2 || this.createComplexArray();
          for (let t3 = 0; t3 < n2.length; t3 += 2) n2[t3] = e3[t3 >>> 1], n2[t3 + 1] = 0;
          return n2;
        }
        completeSpectrum(e3) {
          const t2 = this._csize, n2 = t2 >>> 1;
          for (let r2 = 2; r2 < n2; r2 += 2) e3[t2 - r2] = e3[r2], e3[t2 - r2 + 1] = -e3[r2 + 1];
        }
        transform(e3, t2) {
          if (e3 === t2) throw new Error("Input and output buffers must be different");
          this._transform4(e3, t2, 1);
        }
        realTransform(e3, t2) {
          if (e3 === t2) throw new Error("Input and output buffers must be different");
          this._realTransform4(e3, t2, 1);
        }
        inverseTransform(e3, t2) {
          if (e3 === t2) throw new Error("Input and output buffers must be different");
          this._transform4(e3, t2, -1);
          for (let t3 = 0; t3 < e3.length; ++t3) e3[t3] /= this.size;
        }
        _transform4(e3, t2, n2) {
          const r2 = this._csize;
          let o2, i2, s2 = 1 << this._width, a2 = r2 / s2 << 1;
          const l2 = this._bitrev;
          if (4 === a2) for (o2 = 0, i2 = 0; o2 < r2; o2 += a2, ++i2) {
            const n3 = l2[i2];
            this._singleTransform2(t2, e3, o2, n3, s2);
          }
          else for (o2 = 0, i2 = 0; o2 < r2; o2 += a2, ++i2) {
            const r3 = l2[i2];
            this._singleTransform4(t2, e3, o2, r3, s2, n2);
          }
          for (s2 >>= 2; s2 >= 2; s2 >>= 2) {
            a2 = r2 / s2 << 1;
            const t3 = a2 >>> 2;
            for (o2 = 0; o2 < r2; o2 += a2) {
              const r3 = o2 + t3 - 1;
              for (let i3 = o2, a3 = 0; i3 < r3; i3 += 2, a3 += s2) {
                const r4 = i3, o3 = r4 + t3, s3 = o3 + t3, l3 = s3 + t3, c2 = e3[r4], u2 = e3[r4 + 1], p2 = e3[o3], d2 = e3[o3 + 1], _2 = e3[s3], h2 = e3[s3 + 1], f2 = e3[l3], m2 = e3[l3 + 1], g2 = this.table[a3], b2 = n2 * this.table[a3 + 1], w2 = p2 * g2 - d2 * b2, x = p2 * b2 + d2 * g2, y = this.table[2 * a3], T = n2 * this.table[2 * a3 + 1], v = _2 * y - h2 * T, k = _2 * T + h2 * y, M = this.table[3 * a3], S = n2 * this.table[3 * a3 + 1], P = f2 * M - m2 * S, A = f2 * S + m2 * M, F = c2 + v, C = u2 + k, E = c2 - v, O = u2 - k, I = w2 + P, D = x + A, L = n2 * (w2 - P), $ = n2 * (x - A);
                e3[r4] = F + I, e3[r4 + 1] = C + D, e3[o3] = E + $, e3[o3 + 1] = O - L, e3[s3] = F - I, e3[s3 + 1] = C - D, e3[l3] = E - $, e3[l3 + 1] = O + L;
              }
            }
          }
        }
        _singleTransform2(e3, t2, n2, r2, o2) {
          const i2 = e3[r2], s2 = e3[r2 + 1], a2 = e3[r2 + o2], l2 = e3[r2 + o2 + 1];
          t2[n2] = i2 + a2, t2[n2 + 1] = s2 + l2, t2[n2 + 2] = i2 - a2, t2[n2 + 3] = s2 - l2;
        }
        _singleTransform4(e3, t2, n2, r2, o2, i2) {
          const s2 = 2 * o2, a2 = 3 * o2, l2 = e3[r2], c2 = e3[r2 + 1], u2 = e3[r2 + o2], p2 = e3[r2 + o2 + 1], d2 = e3[r2 + s2], _2 = e3[r2 + s2 + 1], h2 = e3[r2 + a2], f2 = e3[r2 + a2 + 1], m2 = l2 + d2, g2 = c2 + _2, b2 = l2 - d2, w2 = c2 - _2, x = u2 + h2, y = p2 + f2, T = i2 * (u2 - h2), v = i2 * (p2 - f2);
          t2[n2] = m2 + x, t2[n2 + 1] = g2 + y, t2[n2 + 2] = b2 + v, t2[n2 + 3] = w2 - T, t2[n2 + 4] = m2 - x, t2[n2 + 5] = g2 - y, t2[n2 + 6] = b2 - v, t2[n2 + 7] = w2 + T;
        }
        _realTransform4(e3, t2, n2) {
          const r2 = this._csize;
          let o2, i2, s2 = 1 << this._width, a2 = r2 / s2 << 1;
          const l2 = this._bitrev;
          if (4 === a2) for (o2 = 0, i2 = 0; o2 < r2; o2 += a2, ++i2) {
            const n3 = l2[i2];
            this._singleRealTransform2(t2, e3, o2, n3 >>> 1, s2 >>> 1);
          }
          else for (o2 = 0, i2 = 0; o2 < r2; o2 += a2, ++i2) {
            const r3 = l2[i2];
            this._singleRealTransform4(t2, e3, o2, r3 >>> 1, s2 >>> 1, n2);
          }
          for (s2 >>= 2; s2 >= 2; s2 >>= 2) {
            a2 = r2 / s2 << 1;
            const t3 = a2 >>> 2;
            for (o2 = 0; o2 < r2; o2 += a2) {
              const r3 = o2 + t3 - 1;
              for (let i3 = o2, a3 = 0; i3 < r3; i3 += 2, a3 += s2) {
                const r4 = i3, o3 = r4 + t3, s3 = o3 + t3, l3 = s3 + t3, c2 = e3[r4], u2 = e3[r4 + 1], p2 = e3[o3], d2 = e3[o3 + 1], _2 = e3[s3], h2 = e3[s3 + 1], f2 = e3[l3], m2 = e3[l3 + 1], g2 = this.table[a3], b2 = n2 * this.table[a3 + 1], w2 = p2 * g2 - d2 * b2, x = p2 * b2 + d2 * g2, y = this.table[2 * a3], T = n2 * this.table[2 * a3 + 1], v = _2 * y - h2 * T, k = _2 * T + h2 * y, M = this.table[3 * a3], S = n2 * this.table[3 * a3 + 1], P = f2 * M - m2 * S, A = f2 * S + m2 * M, F = c2 + v, C = u2 + k, E = c2 - v, O = u2 - k, I = w2 + P, D = x + A, L = n2 * (w2 - P), $ = n2 * (x - A);
                e3[r4] = F + I, e3[r4 + 1] = C + D, e3[o3] = E + $, e3[o3 + 1] = O - L, e3[s3] = F - I, e3[s3 + 1] = C - D, e3[l3] = E - $, e3[l3 + 1] = O + L;
              }
            }
          }
        }
        _singleRealTransform2(e3, t2, n2, r2, o2) {
          const i2 = e3[r2], s2 = e3[r2 + o2];
          t2[n2] = i2 + s2, t2[n2 + 1] = 0, t2[n2 + 2] = i2 - s2, t2[n2 + 3] = 0;
        }
        _singleRealTransform4(e3, t2, n2, r2, o2, i2) {
          const s2 = 2 * o2, a2 = 3 * o2, l2 = e3[r2], c2 = e3[r2 + o2], u2 = e3[r2 + s2], p2 = e3[r2 + a2], d2 = l2 + u2, _2 = l2 - u2, h2 = c2 + p2, f2 = i2 * (c2 - p2);
          t2[n2] = d2 + h2, t2[n2 + 1] = 0, t2[n2 + 2] = _2, t2[n2 + 3] = -f2, t2[n2 + 4] = d2 - h2, t2[n2 + 5] = 0, t2[n2 + 6] = _2, t2[n2 + 7] = f2;
        }
      }
      class f {
        constructor(e3) {
          const t2 = 2 * (e3 - 1), n2 = 2 * (2 * e3 - 1), r2 = 2 ** Math.ceil(Math.log2(n2));
          this.bufferSize = r2, this._a = t2;
          const o2 = new Float64Array(n2), i2 = new Float64Array(r2);
          this._chirpBuffer = new Float64Array(r2), this._buffer1 = new Float64Array(r2), this._buffer2 = new Float64Array(r2), this._outBuffer1 = new Float64Array(r2), this._outBuffer2 = new Float64Array(r2);
          const s2 = -2 * Math.PI / e3, a2 = Math.cos(s2), l2 = Math.sin(s2);
          for (let t3 = 0; t3 < n2 >> 1; ++t3) {
            const n3 = (t3 + 1 - e3) ** 2 / 2, r3 = Math.sqrt(a2 ** 2 + l2 ** 2) ** n3, s3 = n3 * Math.atan2(l2, a2), c2 = 2 * t3;
            o2[c2] = r3 * Math.cos(s3), o2[c2 + 1] = r3 * Math.sin(s3), i2[c2] = o2[c2], i2[c2 + 1] = -o2[c2 + 1];
          }
          this._slicedChirpBuffer = o2.subarray(t2, n2), this._f = new h(r2 >> 1), this._f.transform(this._chirpBuffer, i2);
        }
        _transform(e3, t2, n2) {
          const r2 = this._buffer1, o2 = this._buffer2, i2 = this._outBuffer1, s2 = this._outBuffer2, a2 = this._chirpBuffer, l2 = this._slicedChirpBuffer, c2 = this._a;
          if (n2) for (let e4 = 0; e4 < l2.length; e4 += 2) {
            const n3 = e4 + 1, o3 = t2[e4 >> 1];
            r2[e4] = o3 * l2[e4], r2[n3] = o3 * l2[n3];
          }
          else for (let e4 = 0; e4 < l2.length; e4 += 2) {
            const n3 = e4 + 1;
            r2[e4] = t2[e4] * l2[e4] - t2[n3] * l2[n3], r2[n3] = t2[e4] * l2[n3] + t2[n3] * l2[e4];
          }
          this._f.transform(i2, r2);
          for (let e4 = 0; e4 < a2.length; e4 += 2) {
            const t3 = e4 + 1;
            o2[e4] = i2[e4] * a2[e4] - i2[t3] * a2[t3], o2[t3] = i2[e4] * a2[t3] + i2[t3] * a2[e4];
          }
          this._f.inverseTransform(s2, o2);
          for (let t3 = 0; t3 < s2.length; t3 += 2) {
            const n3 = s2[t3 + c2], r3 = s2[t3 + c2 + 1], o3 = l2[t3], i3 = l2[t3 + 1];
            e3[t3] = n3 * o3 - r3 * i3, e3[t3 + 1] = n3 * i3 + r3 * o3;
          }
        }
        transform(e3, t2) {
          this._transform(e3, t2, false);
        }
        realTransform(e3, t2) {
          this._transform(e3, t2, true);
        }
      }
      class m {
        constructor(e3) {
          this.fft_length = e3, this.isPowerOfTwo = _(e3), this.isPowerOfTwo ? (this.fft = new h(e3), this.outputBufferSize = 2 * e3) : (this.fft = new f(e3), this.outputBufferSize = this.fft.bufferSize);
        }
        realTransform(e3, t2) {
          this.fft.realTransform(e3, t2);
        }
        transform(e3, t2) {
          this.fft.transform(e3, t2);
        }
      }
      function g(e3, t2) {
        if (t2 % 2 == 0 || t2 <= 0) throw new Error("Window size must be a positive odd number");
        const n2 = new e3.constructor(e3.length), r2 = new e3.constructor(t2), o2 = Math.floor(t2 / 2);
        for (let t3 = 0; t3 < e3.length; ++t3) {
          let i2 = 0;
          for (let n3 = -o2; n3 <= o2; ++n3) {
            let o3 = t3 + n3;
            o3 < 0 ? o3 = Math.abs(o3) : o3 >= e3.length && (o3 = 2 * (e3.length - 1) - o3), r2[i2++] = e3[o3];
          }
          r2.sort(), n2[t3] = r2[o2];
        }
        return n2;
      }
      function b(e3, t2) {
        const n2 = Math.pow(10, t2);
        return Math.round(e3 * n2) / n2;
      }
      function w(e3) {
        const t2 = Math.round(e3);
        return Math.abs(e3) % 1 == 0.5 ? t2 % 2 == 0 ? t2 : t2 - 1 : t2;
      }
    }
  ), "./src/utils/tensor.js": (
    /*!*****************************!*\
      !*** ./src/utils/tensor.js ***!
      \*****************************/
    (e2, t, n) => {
      n.r(t), n.d(t, { Tensor: () => a, cat: () => f, dynamicTimeWarping: () => w, interpolate: () => c, layer_norm: () => p, mean: () => b, mean_pooling: () => u, ones: () => x, ones_like: () => y, permute: () => l, quantize_embeddings: () => T, stack: () => m, std_mean: () => g });
      var r = n(
        /*! ../backends/onnx.js */
        "./src/backends/onnx.js"
      ), o = n(
        /*! ./maths.js */
        "./src/utils/maths.js"
      );
      const i = Object.freeze({ float32: Float32Array, float64: Float64Array, string: Array, int8: Int8Array, uint8: Uint8Array, int16: Int16Array, uint16: Uint16Array, int32: Int32Array, uint32: Uint32Array, int64: BigInt64Array, uint64: BigUint64Array, bool: Uint8Array }), s = r.ONNX.Tensor;
      class a {
        dims;
        type;
        data;
        size;
        constructor(...e3) {
          return e3[0] instanceof s ? Object.assign(this, e3[0]) : Object.assign(this, new s(e3[0], e3[1], e3[2])), new Proxy(this, { get: (e4, t2) => {
            if ("string" == typeof t2) {
              let n2 = Number(t2);
              if (Number.isInteger(n2)) return e4._getitem(n2);
            }
            return e4[t2];
          }, set: (e4, t2, n2) => e4[t2] = n2 });
        }
        *[Symbol.iterator]() {
          const [e3, ...t2] = this.dims;
          if (t2.length > 0) {
            const n2 = t2.reduce(((e4, t3) => e4 * t3));
            for (let r2 = 0; r2 < e3; ++r2) yield this._subarray(r2, n2, t2);
          } else yield* this.data;
        }
        _getitem(e3) {
          const [t2, ...n2] = this.dims;
          if (e3 = h(e3, t2), n2.length > 0) {
            const t3 = n2.reduce(((e4, t4) => e4 * t4));
            return this._subarray(e3, t3, n2);
          }
          return new a(this.type, [this.data[e3]], n2);
        }
        indexOf(e3) {
          for (let t2 = 0; t2 < this.data.length; ++t2) if (this.data[t2] == e3) return t2;
          return -1;
        }
        _subarray(e3, t2, n2) {
          const r2 = e3 * t2, o2 = (e3 + 1) * t2, i2 = "subarray" in this.data ? this.data.subarray(r2, o2) : this.data.slice(r2, o2);
          return new a(this.type, i2, n2);
        }
        item() {
          if (1 !== this.data.length) throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);
          return this.data[0];
        }
        tolist() {
          return (function(e3, t2) {
            const n2 = e3.length, r2 = t2.reduce(((e4, t3) => e4 * t3));
            if (n2 !== r2) throw Error(`cannot reshape array of size ${n2} into shape (${t2})`);
            let o2 = e3;
            for (let e4 = t2.length - 1; e4 >= 0; e4--) o2 = o2.reduce(((n3, r3) => {
              let o3 = n3[n3.length - 1];
              return o3.length < t2[e4] ? o3.push(r3) : n3.push([r3]), n3;
            }), [[]]);
            return o2[0];
          })(this.data, this.dims);
        }
        sigmoid() {
          return this.clone().sigmoid_();
        }
        sigmoid_() {
          for (let e3 = 0; e3 < this.data.length; ++e3) this.data[e3] = 1 / (1 + Math.exp(-this.data[e3]));
          return this;
        }
        mul(e3) {
          return this.clone().mul_(e3);
        }
        mul_(e3) {
          for (let t2 = 0; t2 < this.data.length; ++t2) this.data[t2] *= e3;
          return this;
        }
        add(e3) {
          return this.clone().add_(e3);
        }
        add_(e3) {
          for (let t2 = 0; t2 < this.data.length; ++t2) this.data[t2] += e3;
          return this;
        }
        clone() {
          return new a(this.type, this.data.slice(), this.dims.slice());
        }
        slice(...e3) {
          let t2 = [], n2 = [];
          for (let r3 = 0; r3 < this.dims.length; ++r3) {
            let o3 = e3[r3];
            if (null == o3) n2.push([0, this.dims[r3]]), t2.push(this.dims[r3]);
            else if ("number" == typeof o3) o3 = h(o3, this.dims[r3], r3), n2.push([o3, o3 + 1]);
            else {
              if (!Array.isArray(o3) || 2 !== o3.length) throw new Error(`Invalid slice: ${o3}`);
              {
                if (o3[0] > o3[1]) throw new Error(`Invalid slice: ${o3}`);
                let e4 = [Math.max(o3[0], 0), Math.min(o3[1], this.dims[r3])];
                n2.push(e4), t2.push(e4[1] - e4[0]);
              }
            }
          }
          let r2 = n2.map((([e4, t3]) => t3 - e4)), o2 = r2.reduce(((e4, t3) => e4 * t3)), i2 = new this.data.constructor(o2);
          const s2 = this.stride();
          for (let e4 = 0; e4 < o2; ++e4) {
            let t3 = 0;
            for (let o3 = r2.length - 1, i3 = e4; o3 >= 0; --o3) {
              const e5 = r2[o3];
              t3 += (i3 % e5 + n2[o3][0]) * s2[o3], i3 = Math.floor(i3 / e5);
            }
            i2[e4] = this.data[t3];
          }
          return new a(this.type, i2, t2);
        }
        permute(...e3) {
          return l(this, e3);
        }
        transpose(...e3) {
          return this.permute(...e3);
        }
        sum(e3 = null, t2 = false) {
          return this.norm(1, e3, t2);
        }
        norm(e3 = "fro", t2 = null, n2 = false) {
          if ("fro" === e3) e3 = 2;
          else if ("string" == typeof e3) throw Error(`Unsupported norm: ${e3}`);
          if (null === t2) {
            let t3 = this.data.reduce(((t4, n3) => t4 + n3 ** e3), 0) ** (1 / e3);
            return new a(this.type, [t3], []);
          }
          t2 = h(t2, this.dims.length);
          const r2 = this.dims.slice();
          r2[t2] = 1;
          const o2 = new this.data.constructor(this.data.length / this.dims[t2]);
          for (let n3 = 0; n3 < this.data.length; ++n3) {
            let i2 = 0;
            for (let e4 = this.dims.length - 1, o3 = n3, s2 = 1; e4 >= 0; --e4) {
              const n4 = this.dims[e4];
              if (e4 !== t2) {
                i2 += o3 % n4 * s2, s2 *= r2[e4];
              }
              o3 = Math.floor(o3 / n4);
            }
            o2[i2] += this.data[n3] ** e3;
          }
          if (1 !== e3) for (let t3 = 0; t3 < o2.length; ++t3) o2[t3] = o2[t3] ** (1 / e3);
          return n2 || r2.splice(t2, 1), new a(this.type, o2, r2);
        }
        normalize_(e3 = 2, t2 = 1) {
          t2 = h(t2, this.dims.length);
          const n2 = this.norm(e3, t2, true);
          for (let e4 = 0; e4 < this.data.length; ++e4) {
            let r2 = 0;
            for (let n3 = this.dims.length - 1, o2 = e4, i2 = 1; n3 >= 0; --n3) {
              const e5 = this.dims[n3];
              if (n3 !== t2) {
                r2 += o2 % e5 * i2, i2 *= this.dims[n3];
              }
              o2 = Math.floor(o2 / e5);
            }
            this.data[e4] /= n2.data[r2];
          }
          return this;
        }
        normalize(e3 = 2, t2 = 1) {
          return this.clone().normalize_(e3, t2);
        }
        stride() {
          return (function(e3) {
            const t2 = new Array(e3.length);
            for (let n2 = e3.length - 1, r2 = 1; n2 >= 0; --n2) t2[n2] = r2, r2 *= e3[n2];
            return t2;
          })(this.dims);
        }
        squeeze(e3 = null) {
          return new a(this.type, this.data, d(this.dims, e3));
        }
        squeeze_(e3 = null) {
          return this.dims = d(this.dims, e3), this;
        }
        unsqueeze(e3 = null) {
          return new a(this.type, this.data, _(this.dims, e3));
        }
        unsqueeze_(e3 = null) {
          return this.dims = _(this.dims, e3), this;
        }
        flatten_(e3 = 0, t2 = -1) {
          t2 = (t2 + this.dims.length) % this.dims.length;
          let n2 = this.dims.slice(0, e3), r2 = this.dims.slice(e3, t2 + 1), o2 = this.dims.slice(t2 + 1);
          return this.dims = [...n2, r2.reduce(((e4, t3) => e4 * t3), 1), ...o2], this;
        }
        flatten(e3 = 0, t2 = -1) {
          return this.clone().flatten_(e3, t2);
        }
        view(...e3) {
          let t2 = -1;
          for (let n2 = 0; n2 < e3.length; ++n2) if (-1 === e3[n2]) {
            if (-1 !== t2) throw new Error("Only one dimension can be inferred");
            t2 = n2;
          }
          if (-1 !== t2) {
            const n2 = e3.reduce(((e4, n3, r2) => r2 !== t2 ? e4 * n3 : e4), 1);
            e3[t2] = this.data.length / n2;
          }
          return new a(this.type, this.data, e3);
        }
        neg_() {
          for (let e3 = 0; e3 < this.data.length; ++e3) this.data[e3] = -this.data[e3];
          return this;
        }
        neg() {
          return this.clone().neg_();
        }
        clamp_(e3, t2) {
          for (let n2 = 0; n2 < this.data.length; ++n2) this.data[n2] = Math.min(Math.max(this.data[n2], e3), t2);
          return this;
        }
        clamp(e3, t2) {
          return this.clone().clamp_(e3, t2);
        }
        round_() {
          for (let e3 = 0; e3 < this.data.length; ++e3) this.data[e3] = Math.round(this.data[e3]);
          return this;
        }
        round() {
          return this.clone().round_();
        }
        to(e3) {
          if (this.type === e3) return this;
          if (!i.hasOwnProperty(e3)) throw new Error(`Unsupported type: ${e3}`);
          return new a(e3, i[e3].from(this.data), this.dims);
        }
      }
      function l(e3, t2) {
        const [n2, r2] = (0, o.permute_data)(e3.data, e3.dims, t2);
        return new a(e3.type, n2, r2);
      }
      function c(e3, [t2, n2], r2 = "bilinear", i2 = false) {
        const s2 = e3.dims.at(-3) ?? 1, l2 = e3.dims.at(-2), c2 = e3.dims.at(-1);
        let u2 = (0, o.interpolate_data)(e3.data, [s2, l2, c2], [t2, n2], r2, i2);
        return new a(e3.type, u2, [s2, t2, n2]);
      }
      function u(e3, t2) {
        let n2 = [e3.dims[0], e3.dims[2]], r2 = new e3.data.constructor(n2[0] * n2[1]), [o2, i2, s2] = e3.dims, l2 = 0;
        for (let n3 = 0; n3 < o2; ++n3) {
          let o3 = n3 * s2 * i2;
          for (let a2 = 0; a2 < s2; ++a2) {
            let c2 = 0, u2 = 0, p2 = n3 * i2, d2 = o3 + a2;
            for (let n4 = 0; n4 < i2; ++n4) {
              let r3 = Number(t2.data[p2 + n4]);
              u2 += r3, c2 += e3.data[d2 + n4 * s2] * r3;
            }
            let _2 = c2 / u2;
            r2[l2++] = _2;
          }
        }
        return new a(e3.type, r2, n2);
      }
      function p(e3, t2, { eps: n2 = 1e-5 } = {}) {
        if (2 !== e3.dims.length) throw new Error("`layer_norm` currently only supports 2D input.");
        const [r2, o2] = e3.dims;
        if (1 !== t2.length && t2[0] !== o2) throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");
        const [i2, s2] = g(e3, 1, 0, true), l2 = new e3.data.constructor(e3.data.length);
        for (let t3 = 0; t3 < r2; ++t3) {
          const r3 = t3 * o2;
          for (let a2 = 0; a2 < o2; ++a2) {
            const o3 = r3 + a2;
            l2[o3] = (e3.data[o3] - s2.data[t3]) / (i2.data[t3] + n2);
          }
        }
        return new a(e3.type, l2, e3.dims);
      }
      function d(e3, t2) {
        return e3 = e3.slice(), null === t2 ? e3 = e3.filter(((e4) => 1 !== e4)) : "number" == typeof t2 ? 1 === e3[t2] && e3.splice(t2, 1) : Array.isArray(t2) && (e3 = e3.filter(((e4, n2) => 1 !== e4 || !t2.includes(n2)))), e3;
      }
      function _(e3, t2) {
        return t2 = h(t2, e3.length + 1), (e3 = e3.slice()).splice(t2, 0, 1), e3;
      }
      function h(e3, t2, n2 = null) {
        if (e3 < -t2 || e3 >= t2) throw new Error(`IndexError: index ${e3} is out of bounds for dimension${null === n2 ? "" : " " + n2} with size ${t2}`);
        return e3 < 0 && (e3 = (e3 % t2 + t2) % t2), e3;
      }
      function f(e3, t2 = 0) {
        t2 = h(t2, e3[0].dims.length);
        const n2 = e3[0].dims.slice();
        n2[t2] = e3.reduce(((e4, n3) => e4 + n3.dims[t2]), 0);
        const r2 = n2.reduce(((e4, t3) => e4 * t3), 1), o2 = new e3[0].data.constructor(r2), i2 = e3[0].type;
        if (0 === t2) {
          let t3 = 0;
          for (let n3 of e3) o2.set(n3.data, t3), t3 += n3.data.length;
        } else {
          let r3 = 0;
          for (let i3 = 0; i3 < e3.length; ++i3) {
            let s2 = e3[i3];
            for (let e4 = 0; e4 < s2.data.length; ++e4) {
              let i4 = 0;
              for (let o3 = s2.dims.length - 1, a2 = e4, l2 = 1; o3 >= 0; --o3) {
                const e5 = s2.dims[o3];
                let c2 = a2 % e5;
                o3 === t2 && (c2 += r3), i4 += c2 * l2, l2 *= n2[o3], a2 = Math.floor(a2 / e5);
              }
              o2[i4] = s2.data[e4];
            }
            r3 += s2.dims[t2];
          }
        }
        return new a(i2, o2, n2);
      }
      function m(e3, t2 = 0) {
        return f(e3.map(((e4) => e4.unsqueeze(t2))), t2);
      }
      function g(e3, t2 = null, n2 = 1, r2 = false) {
        if (null === t2) {
          const t3 = e3.data.reduce(((e4, t4) => e4 + t4), 0) / e3.data.length, r3 = Math.sqrt(e3.data.reduce(((e4, n3) => e4 + (n3 - t3) ** 2), 0) / (e3.data.length - n2)), o3 = new a(e3.type, [t3], []);
          return [new a(e3.type, [r3], []), o3];
        }
        const o2 = b(e3, t2 = h(t2, e3.dims.length), r2), i2 = e3.dims.slice();
        i2[t2] = 1;
        const s2 = new e3.data.constructor(e3.data.length / e3.dims[t2]);
        for (let n3 = 0; n3 < e3.data.length; ++n3) {
          let r3 = 0;
          for (let o3 = e3.dims.length - 1, s3 = n3, a2 = 1; o3 >= 0; --o3) {
            const n4 = e3.dims[o3];
            if (o3 !== t2) {
              r3 += s3 % n4 * a2, a2 *= i2[o3];
            }
            s3 = Math.floor(s3 / n4);
          }
          s2[r3] += (e3.data[n3] - o2.data[r3]) ** 2;
        }
        for (let r3 = 0; r3 < s2.length; ++r3) s2[r3] = Math.sqrt(s2[r3] / (e3.dims[t2] - n2));
        r2 || i2.splice(t2, 1);
        return [new a(e3.type, s2, i2), o2];
      }
      function b(e3, t2 = null, n2 = false) {
        if (null === t2) {
          let t3 = e3.data.reduce(((e4, t4) => e4 + t4), 0);
          return new a(e3.type, [t3 / e3.data.length], []);
        }
        t2 = h(t2, e3.dims.length);
        const r2 = e3.dims.slice();
        r2[t2] = 1;
        const o2 = new e3.data.constructor(e3.data.length / e3.dims[t2]);
        for (let n3 = 0; n3 < e3.data.length; ++n3) {
          let i2 = 0;
          for (let o3 = e3.dims.length - 1, s2 = n3, a2 = 1; o3 >= 0; --o3) {
            const n4 = e3.dims[o3];
            if (o3 !== t2) {
              i2 += s2 % n4 * a2, a2 *= r2[o3];
            }
            s2 = Math.floor(s2 / n4);
          }
          o2[i2] += e3.data[n3];
        }
        if (1 !== e3.dims[t2]) for (let n3 = 0; n3 < o2.length; ++n3) o2[n3] = o2[n3] / e3.dims[t2];
        return n2 || r2.splice(t2, 1), new a(e3.type, o2, r2);
      }
      function w(e3) {
        const [t2, n2] = e3.dims, r2 = [t2 + 1, n2 + 1], o2 = new a("float32", new Float32Array(r2[0] * r2[1]).fill(1 / 0), r2), i2 = new a("float32", new Float32Array(r2[0] * r2[1]).fill(-1), r2);
        o2[0].data[0] = 0;
        for (let r3 = 1; r3 < n2 + 1; ++r3) for (let n3 = 1; n3 < t2 + 1; ++n3) {
          const t3 = o2[n3 - 1][r3 - 1].item(), s3 = o2[n3 - 1][r3].item(), a2 = o2[n3][r3 - 1].item();
          let l3, c3;
          t3 < s3 && t3 < a2 ? (l3 = t3, c3 = 0) : s3 < t3 && s3 < a2 ? (l3 = s3, c3 = 1) : (l3 = a2, c3 = 2), o2[n3].data[r3] = e3[n3 - 1][r3 - 1].item() + l3, i2[n3].data[r3] = c3;
        }
        let s2 = t2, l2 = n2;
        i2.data.fill(2, 0, r2[1]);
        for (let e4 = 0; e4 < r2[0]; ++e4) i2[e4].data[0] = 1;
        let c2 = [], u2 = [];
        for (; s2 > 0 || l2 > 0; ) {
          c2.push(s2 - 1), u2.push(l2 - 1);
          switch (i2[s2][l2].item()) {
            case 0:
              --s2, --l2;
              break;
            case 1:
              --s2;
              break;
            case 2:
              --l2;
              break;
            default:
              throw new Error(`Internal error in dynamic time warping. Unexpected trace[${s2}, ${l2}]. Please file a bug report.`);
          }
        }
        return c2.reverse(), u2.reverse(), [c2, u2];
      }
      function x(e3) {
        const t2 = e3.reduce(((e4, t3) => e4 * t3), 1);
        return new a("int64", new BigInt64Array(t2).fill(1n), e3);
      }
      function y(e3) {
        return x(e3.dims);
      }
      function T(e3, t2) {
        if (2 !== e3.dims.length) throw new Error("The tensor must have 2 dimensions");
        if (e3.dims.at(-1) % 8 != 0) throw new Error("The last dimension of the tensor must be a multiple of 8");
        if (!["binary", "ubinary"].includes(t2)) throw new Error("The precision must be either 'binary' or 'ubinary'");
        const n2 = "binary" === t2, r2 = n2 ? "int8" : "uint8", o2 = n2 ? Int8Array : Uint8Array, i2 = e3.data, s2 = new o2(i2.length / 8);
        for (let e4 = 0; e4 < i2.length; ++e4) {
          const t3 = i2[e4] > 0 ? 1 : 0, r3 = Math.floor(e4 / 8), o3 = e4 % 8;
          s2[r3] |= t3 << 7 - o3, n2 && 0 === o3 && (s2[r3] -= 128);
        }
        return new a(r2, s2, [e3.dims[0], e3.dims[1] / 8]);
      }
    }
  ) };
  var __webpack_module_cache__ = {};
  var leafPrototypes;
  var getProto;
  function __webpack_require__(e2) {
    var t = __webpack_module_cache__[e2];
    if (void 0 !== t) return t.exports;
    var n = __webpack_module_cache__[e2] = { exports: {} };
    return __webpack_modules__[e2](n, n.exports, __webpack_require__), n.exports;
  }
  getProto = Object.getPrototypeOf ? (e2) => Object.getPrototypeOf(e2) : (e2) => e2.__proto__, __webpack_require__.t = function(e2, t) {
    if (1 & t && (e2 = this(e2)), 8 & t) return e2;
    if ("object" == typeof e2 && e2) {
      if (4 & t && e2.__esModule) return e2;
      if (16 & t && "function" == typeof e2.then) return e2;
    }
    var n = /* @__PURE__ */ Object.create(null);
    __webpack_require__.r(n);
    var r = {};
    leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
    for (var o = 2 & t && e2; "object" == typeof o && !~leafPrototypes.indexOf(o); o = getProto(o)) Object.getOwnPropertyNames(o).forEach(((t2) => r[t2] = () => e2[t2]));
    return r.default = () => e2, __webpack_require__.d(n, r), n;
  }, __webpack_require__.d = (e2, t) => {
    for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e2, n) && Object.defineProperty(e2, n, { enumerable: true, get: t[n] });
  }, __webpack_require__.o = (e2, t) => Object.prototype.hasOwnProperty.call(e2, t), __webpack_require__.r = (e2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
  };
  var __webpack_exports__ = __webpack_require__("./src/transformers.js");
  var __webpack_exports__ASTFeatureExtractor = __webpack_exports__.ASTFeatureExtractor;
  var __webpack_exports__ASTForAudioClassification = __webpack_exports__.ASTForAudioClassification;
  var __webpack_exports__ASTModel = __webpack_exports__.ASTModel;
  var __webpack_exports__ASTPreTrainedModel = __webpack_exports__.ASTPreTrainedModel;
  var __webpack_exports__AlbertForMaskedLM = __webpack_exports__.AlbertForMaskedLM;
  var __webpack_exports__AlbertForQuestionAnswering = __webpack_exports__.AlbertForQuestionAnswering;
  var __webpack_exports__AlbertForSequenceClassification = __webpack_exports__.AlbertForSequenceClassification;
  var __webpack_exports__AlbertModel = __webpack_exports__.AlbertModel;
  var __webpack_exports__AlbertPreTrainedModel = __webpack_exports__.AlbertPreTrainedModel;
  var __webpack_exports__AlbertTokenizer = __webpack_exports__.AlbertTokenizer;
  var __webpack_exports__AudioClassificationPipeline = __webpack_exports__.AudioClassificationPipeline;
  var __webpack_exports__AutoConfig = __webpack_exports__.AutoConfig;
  var __webpack_exports__AutoModel = __webpack_exports__.AutoModel;
  var __webpack_exports__AutoModelForAudioClassification = __webpack_exports__.AutoModelForAudioClassification;
  var __webpack_exports__AutoModelForAudioFrameClassification = __webpack_exports__.AutoModelForAudioFrameClassification;
  var __webpack_exports__AutoModelForCTC = __webpack_exports__.AutoModelForCTC;
  var __webpack_exports__AutoModelForCausalLM = __webpack_exports__.AutoModelForCausalLM;
  var __webpack_exports__AutoModelForDepthEstimation = __webpack_exports__.AutoModelForDepthEstimation;
  var __webpack_exports__AutoModelForDocumentQuestionAnswering = __webpack_exports__.AutoModelForDocumentQuestionAnswering;
  var __webpack_exports__AutoModelForImageClassification = __webpack_exports__.AutoModelForImageClassification;
  var __webpack_exports__AutoModelForImageFeatureExtraction = __webpack_exports__.AutoModelForImageFeatureExtraction;
  var __webpack_exports__AutoModelForImageMatting = __webpack_exports__.AutoModelForImageMatting;
  var __webpack_exports__AutoModelForImageSegmentation = __webpack_exports__.AutoModelForImageSegmentation;
  var __webpack_exports__AutoModelForImageToImage = __webpack_exports__.AutoModelForImageToImage;
  var __webpack_exports__AutoModelForMaskGeneration = __webpack_exports__.AutoModelForMaskGeneration;
  var __webpack_exports__AutoModelForMaskedLM = __webpack_exports__.AutoModelForMaskedLM;
  var __webpack_exports__AutoModelForObjectDetection = __webpack_exports__.AutoModelForObjectDetection;
  var __webpack_exports__AutoModelForQuestionAnswering = __webpack_exports__.AutoModelForQuestionAnswering;
  var __webpack_exports__AutoModelForSemanticSegmentation = __webpack_exports__.AutoModelForSemanticSegmentation;
  var __webpack_exports__AutoModelForSeq2SeqLM = __webpack_exports__.AutoModelForSeq2SeqLM;
  var __webpack_exports__AutoModelForSequenceClassification = __webpack_exports__.AutoModelForSequenceClassification;
  var __webpack_exports__AutoModelForSpeechSeq2Seq = __webpack_exports__.AutoModelForSpeechSeq2Seq;
  var __webpack_exports__AutoModelForTextToSpectrogram = __webpack_exports__.AutoModelForTextToSpectrogram;
  var __webpack_exports__AutoModelForTextToWaveform = __webpack_exports__.AutoModelForTextToWaveform;
  var __webpack_exports__AutoModelForTokenClassification = __webpack_exports__.AutoModelForTokenClassification;
  var __webpack_exports__AutoModelForVision2Seq = __webpack_exports__.AutoModelForVision2Seq;
  var __webpack_exports__AutoModelForXVector = __webpack_exports__.AutoModelForXVector;
  var __webpack_exports__AutoModelForZeroShotObjectDetection = __webpack_exports__.AutoModelForZeroShotObjectDetection;
  var __webpack_exports__AutoProcessor = __webpack_exports__.AutoProcessor;
  var __webpack_exports__AutoTokenizer = __webpack_exports__.AutoTokenizer;
  var __webpack_exports__AutomaticSpeechRecognitionPipeline = __webpack_exports__.AutomaticSpeechRecognitionPipeline;
  var __webpack_exports__BartForConditionalGeneration = __webpack_exports__.BartForConditionalGeneration;
  var __webpack_exports__BartForSequenceClassification = __webpack_exports__.BartForSequenceClassification;
  var __webpack_exports__BartModel = __webpack_exports__.BartModel;
  var __webpack_exports__BartPretrainedModel = __webpack_exports__.BartPretrainedModel;
  var __webpack_exports__BartTokenizer = __webpack_exports__.BartTokenizer;
  var __webpack_exports__BaseModelOutput = __webpack_exports__.BaseModelOutput;
  var __webpack_exports__BeitFeatureExtractor = __webpack_exports__.BeitFeatureExtractor;
  var __webpack_exports__BeitForImageClassification = __webpack_exports__.BeitForImageClassification;
  var __webpack_exports__BeitModel = __webpack_exports__.BeitModel;
  var __webpack_exports__BeitPreTrainedModel = __webpack_exports__.BeitPreTrainedModel;
  var __webpack_exports__BertForMaskedLM = __webpack_exports__.BertForMaskedLM;
  var __webpack_exports__BertForQuestionAnswering = __webpack_exports__.BertForQuestionAnswering;
  var __webpack_exports__BertForSequenceClassification = __webpack_exports__.BertForSequenceClassification;
  var __webpack_exports__BertForTokenClassification = __webpack_exports__.BertForTokenClassification;
  var __webpack_exports__BertModel = __webpack_exports__.BertModel;
  var __webpack_exports__BertPreTrainedModel = __webpack_exports__.BertPreTrainedModel;
  var __webpack_exports__BertTokenizer = __webpack_exports__.BertTokenizer;
  var __webpack_exports__BitImageProcessor = __webpack_exports__.BitImageProcessor;
  var __webpack_exports__BlenderbotForConditionalGeneration = __webpack_exports__.BlenderbotForConditionalGeneration;
  var __webpack_exports__BlenderbotModel = __webpack_exports__.BlenderbotModel;
  var __webpack_exports__BlenderbotPreTrainedModel = __webpack_exports__.BlenderbotPreTrainedModel;
  var __webpack_exports__BlenderbotSmallForConditionalGeneration = __webpack_exports__.BlenderbotSmallForConditionalGeneration;
  var __webpack_exports__BlenderbotSmallModel = __webpack_exports__.BlenderbotSmallModel;
  var __webpack_exports__BlenderbotSmallPreTrainedModel = __webpack_exports__.BlenderbotSmallPreTrainedModel;
  var __webpack_exports__BlenderbotSmallTokenizer = __webpack_exports__.BlenderbotSmallTokenizer;
  var __webpack_exports__BlenderbotTokenizer = __webpack_exports__.BlenderbotTokenizer;
  var __webpack_exports__BloomForCausalLM = __webpack_exports__.BloomForCausalLM;
  var __webpack_exports__BloomModel = __webpack_exports__.BloomModel;
  var __webpack_exports__BloomPreTrainedModel = __webpack_exports__.BloomPreTrainedModel;
  var __webpack_exports__BloomTokenizer = __webpack_exports__.BloomTokenizer;
  var __webpack_exports__CLIPFeatureExtractor = __webpack_exports__.CLIPFeatureExtractor;
  var __webpack_exports__CLIPModel = __webpack_exports__.CLIPModel;
  var __webpack_exports__CLIPPreTrainedModel = __webpack_exports__.CLIPPreTrainedModel;
  var __webpack_exports__CLIPSegForImageSegmentation = __webpack_exports__.CLIPSegForImageSegmentation;
  var __webpack_exports__CLIPSegModel = __webpack_exports__.CLIPSegModel;
  var __webpack_exports__CLIPSegPreTrainedModel = __webpack_exports__.CLIPSegPreTrainedModel;
  var __webpack_exports__CLIPTextModelWithProjection = __webpack_exports__.CLIPTextModelWithProjection;
  var __webpack_exports__CLIPTokenizer = __webpack_exports__.CLIPTokenizer;
  var __webpack_exports__CLIPVisionModelWithProjection = __webpack_exports__.CLIPVisionModelWithProjection;
  var __webpack_exports__CamembertForMaskedLM = __webpack_exports__.CamembertForMaskedLM;
  var __webpack_exports__CamembertForQuestionAnswering = __webpack_exports__.CamembertForQuestionAnswering;
  var __webpack_exports__CamembertForSequenceClassification = __webpack_exports__.CamembertForSequenceClassification;
  var __webpack_exports__CamembertForTokenClassification = __webpack_exports__.CamembertForTokenClassification;
  var __webpack_exports__CamembertModel = __webpack_exports__.CamembertModel;
  var __webpack_exports__CamembertPreTrainedModel = __webpack_exports__.CamembertPreTrainedModel;
  var __webpack_exports__CamembertTokenizer = __webpack_exports__.CamembertTokenizer;
  var __webpack_exports__CausalLMOutput = __webpack_exports__.CausalLMOutput;
  var __webpack_exports__CausalLMOutputWithPast = __webpack_exports__.CausalLMOutputWithPast;
  var __webpack_exports__ChineseCLIPFeatureExtractor = __webpack_exports__.ChineseCLIPFeatureExtractor;
  var __webpack_exports__ChineseCLIPModel = __webpack_exports__.ChineseCLIPModel;
  var __webpack_exports__ChineseCLIPPreTrainedModel = __webpack_exports__.ChineseCLIPPreTrainedModel;
  var __webpack_exports__ClapAudioModelWithProjection = __webpack_exports__.ClapAudioModelWithProjection;
  var __webpack_exports__ClapFeatureExtractor = __webpack_exports__.ClapFeatureExtractor;
  var __webpack_exports__ClapModel = __webpack_exports__.ClapModel;
  var __webpack_exports__ClapPreTrainedModel = __webpack_exports__.ClapPreTrainedModel;
  var __webpack_exports__ClapTextModelWithProjection = __webpack_exports__.ClapTextModelWithProjection;
  var __webpack_exports__CodeGenForCausalLM = __webpack_exports__.CodeGenForCausalLM;
  var __webpack_exports__CodeGenModel = __webpack_exports__.CodeGenModel;
  var __webpack_exports__CodeGenPreTrainedModel = __webpack_exports__.CodeGenPreTrainedModel;
  var __webpack_exports__CodeGenTokenizer = __webpack_exports__.CodeGenTokenizer;
  var __webpack_exports__CodeLlamaTokenizer = __webpack_exports__.CodeLlamaTokenizer;
  var __webpack_exports__CohereTokenizer = __webpack_exports__.CohereTokenizer;
  var __webpack_exports__ConvBertForMaskedLM = __webpack_exports__.ConvBertForMaskedLM;
  var __webpack_exports__ConvBertForQuestionAnswering = __webpack_exports__.ConvBertForQuestionAnswering;
  var __webpack_exports__ConvBertForSequenceClassification = __webpack_exports__.ConvBertForSequenceClassification;
  var __webpack_exports__ConvBertForTokenClassification = __webpack_exports__.ConvBertForTokenClassification;
  var __webpack_exports__ConvBertModel = __webpack_exports__.ConvBertModel;
  var __webpack_exports__ConvBertPreTrainedModel = __webpack_exports__.ConvBertPreTrainedModel;
  var __webpack_exports__ConvBertTokenizer = __webpack_exports__.ConvBertTokenizer;
  var __webpack_exports__ConvNextFeatureExtractor = __webpack_exports__.ConvNextFeatureExtractor;
  var __webpack_exports__ConvNextForImageClassification = __webpack_exports__.ConvNextForImageClassification;
  var __webpack_exports__ConvNextImageProcessor = __webpack_exports__.ConvNextImageProcessor;
  var __webpack_exports__ConvNextModel = __webpack_exports__.ConvNextModel;
  var __webpack_exports__ConvNextPreTrainedModel = __webpack_exports__.ConvNextPreTrainedModel;
  var __webpack_exports__ConvNextV2ForImageClassification = __webpack_exports__.ConvNextV2ForImageClassification;
  var __webpack_exports__ConvNextV2Model = __webpack_exports__.ConvNextV2Model;
  var __webpack_exports__ConvNextV2PreTrainedModel = __webpack_exports__.ConvNextV2PreTrainedModel;
  var __webpack_exports__DPTFeatureExtractor = __webpack_exports__.DPTFeatureExtractor;
  var __webpack_exports__DPTForDepthEstimation = __webpack_exports__.DPTForDepthEstimation;
  var __webpack_exports__DPTImageProcessor = __webpack_exports__.DPTImageProcessor;
  var __webpack_exports__DPTModel = __webpack_exports__.DPTModel;
  var __webpack_exports__DPTPreTrainedModel = __webpack_exports__.DPTPreTrainedModel;
  var __webpack_exports__DebertaForMaskedLM = __webpack_exports__.DebertaForMaskedLM;
  var __webpack_exports__DebertaForQuestionAnswering = __webpack_exports__.DebertaForQuestionAnswering;
  var __webpack_exports__DebertaForSequenceClassification = __webpack_exports__.DebertaForSequenceClassification;
  var __webpack_exports__DebertaForTokenClassification = __webpack_exports__.DebertaForTokenClassification;
  var __webpack_exports__DebertaModel = __webpack_exports__.DebertaModel;
  var __webpack_exports__DebertaPreTrainedModel = __webpack_exports__.DebertaPreTrainedModel;
  var __webpack_exports__DebertaTokenizer = __webpack_exports__.DebertaTokenizer;
  var __webpack_exports__DebertaV2ForMaskedLM = __webpack_exports__.DebertaV2ForMaskedLM;
  var __webpack_exports__DebertaV2ForQuestionAnswering = __webpack_exports__.DebertaV2ForQuestionAnswering;
  var __webpack_exports__DebertaV2ForSequenceClassification = __webpack_exports__.DebertaV2ForSequenceClassification;
  var __webpack_exports__DebertaV2ForTokenClassification = __webpack_exports__.DebertaV2ForTokenClassification;
  var __webpack_exports__DebertaV2Model = __webpack_exports__.DebertaV2Model;
  var __webpack_exports__DebertaV2PreTrainedModel = __webpack_exports__.DebertaV2PreTrainedModel;
  var __webpack_exports__DebertaV2Tokenizer = __webpack_exports__.DebertaV2Tokenizer;
  var __webpack_exports__DeiTFeatureExtractor = __webpack_exports__.DeiTFeatureExtractor;
  var __webpack_exports__DeiTForImageClassification = __webpack_exports__.DeiTForImageClassification;
  var __webpack_exports__DeiTModel = __webpack_exports__.DeiTModel;
  var __webpack_exports__DeiTPreTrainedModel = __webpack_exports__.DeiTPreTrainedModel;
  var __webpack_exports__DepthAnythingForDepthEstimation = __webpack_exports__.DepthAnythingForDepthEstimation;
  var __webpack_exports__DepthAnythingPreTrainedModel = __webpack_exports__.DepthAnythingPreTrainedModel;
  var __webpack_exports__DepthEstimationPipeline = __webpack_exports__.DepthEstimationPipeline;
  var __webpack_exports__DetrFeatureExtractor = __webpack_exports__.DetrFeatureExtractor;
  var __webpack_exports__DetrForObjectDetection = __webpack_exports__.DetrForObjectDetection;
  var __webpack_exports__DetrForSegmentation = __webpack_exports__.DetrForSegmentation;
  var __webpack_exports__DetrModel = __webpack_exports__.DetrModel;
  var __webpack_exports__DetrObjectDetectionOutput = __webpack_exports__.DetrObjectDetectionOutput;
  var __webpack_exports__DetrPreTrainedModel = __webpack_exports__.DetrPreTrainedModel;
  var __webpack_exports__DetrSegmentationOutput = __webpack_exports__.DetrSegmentationOutput;
  var __webpack_exports__Dinov2ForImageClassification = __webpack_exports__.Dinov2ForImageClassification;
  var __webpack_exports__Dinov2Model = __webpack_exports__.Dinov2Model;
  var __webpack_exports__Dinov2PreTrainedModel = __webpack_exports__.Dinov2PreTrainedModel;
  var __webpack_exports__DistilBertForMaskedLM = __webpack_exports__.DistilBertForMaskedLM;
  var __webpack_exports__DistilBertForQuestionAnswering = __webpack_exports__.DistilBertForQuestionAnswering;
  var __webpack_exports__DistilBertForSequenceClassification = __webpack_exports__.DistilBertForSequenceClassification;
  var __webpack_exports__DistilBertForTokenClassification = __webpack_exports__.DistilBertForTokenClassification;
  var __webpack_exports__DistilBertModel = __webpack_exports__.DistilBertModel;
  var __webpack_exports__DistilBertPreTrainedModel = __webpack_exports__.DistilBertPreTrainedModel;
  var __webpack_exports__DistilBertTokenizer = __webpack_exports__.DistilBertTokenizer;
  var __webpack_exports__DocumentQuestionAnsweringPipeline = __webpack_exports__.DocumentQuestionAnsweringPipeline;
  var __webpack_exports__DonutFeatureExtractor = __webpack_exports__.DonutFeatureExtractor;
  var __webpack_exports__DonutSwinModel = __webpack_exports__.DonutSwinModel;
  var __webpack_exports__DonutSwinPreTrainedModel = __webpack_exports__.DonutSwinPreTrainedModel;
  var __webpack_exports__EfficientNetForImageClassification = __webpack_exports__.EfficientNetForImageClassification;
  var __webpack_exports__EfficientNetImageProcessor = __webpack_exports__.EfficientNetImageProcessor;
  var __webpack_exports__EfficientNetModel = __webpack_exports__.EfficientNetModel;
  var __webpack_exports__EfficientNetPreTrainedModel = __webpack_exports__.EfficientNetPreTrainedModel;
  var __webpack_exports__ElectraForMaskedLM = __webpack_exports__.ElectraForMaskedLM;
  var __webpack_exports__ElectraForQuestionAnswering = __webpack_exports__.ElectraForQuestionAnswering;
  var __webpack_exports__ElectraForSequenceClassification = __webpack_exports__.ElectraForSequenceClassification;
  var __webpack_exports__ElectraForTokenClassification = __webpack_exports__.ElectraForTokenClassification;
  var __webpack_exports__ElectraModel = __webpack_exports__.ElectraModel;
  var __webpack_exports__ElectraPreTrainedModel = __webpack_exports__.ElectraPreTrainedModel;
  var __webpack_exports__ElectraTokenizer = __webpack_exports__.ElectraTokenizer;
  var __webpack_exports__EsmForMaskedLM = __webpack_exports__.EsmForMaskedLM;
  var __webpack_exports__EsmForSequenceClassification = __webpack_exports__.EsmForSequenceClassification;
  var __webpack_exports__EsmForTokenClassification = __webpack_exports__.EsmForTokenClassification;
  var __webpack_exports__EsmModel = __webpack_exports__.EsmModel;
  var __webpack_exports__EsmPreTrainedModel = __webpack_exports__.EsmPreTrainedModel;
  var __webpack_exports__EsmTokenizer = __webpack_exports__.EsmTokenizer;
  var __webpack_exports__FFT = __webpack_exports__.FFT;
  var __webpack_exports__FalconForCausalLM = __webpack_exports__.FalconForCausalLM;
  var __webpack_exports__FalconModel = __webpack_exports__.FalconModel;
  var __webpack_exports__FalconPreTrainedModel = __webpack_exports__.FalconPreTrainedModel;
  var __webpack_exports__FalconTokenizer = __webpack_exports__.FalconTokenizer;
  var __webpack_exports__FeatureExtractionPipeline = __webpack_exports__.FeatureExtractionPipeline;
  var __webpack_exports__FeatureExtractor = __webpack_exports__.FeatureExtractor;
  var __webpack_exports__FillMaskPipeline = __webpack_exports__.FillMaskPipeline;
  var __webpack_exports__GLPNFeatureExtractor = __webpack_exports__.GLPNFeatureExtractor;
  var __webpack_exports__GLPNForDepthEstimation = __webpack_exports__.GLPNForDepthEstimation;
  var __webpack_exports__GLPNModel = __webpack_exports__.GLPNModel;
  var __webpack_exports__GLPNPreTrainedModel = __webpack_exports__.GLPNPreTrainedModel;
  var __webpack_exports__GPT2LMHeadModel = __webpack_exports__.GPT2LMHeadModel;
  var __webpack_exports__GPT2Model = __webpack_exports__.GPT2Model;
  var __webpack_exports__GPT2PreTrainedModel = __webpack_exports__.GPT2PreTrainedModel;
  var __webpack_exports__GPT2Tokenizer = __webpack_exports__.GPT2Tokenizer;
  var __webpack_exports__GPTBigCodeForCausalLM = __webpack_exports__.GPTBigCodeForCausalLM;
  var __webpack_exports__GPTBigCodeModel = __webpack_exports__.GPTBigCodeModel;
  var __webpack_exports__GPTBigCodePreTrainedModel = __webpack_exports__.GPTBigCodePreTrainedModel;
  var __webpack_exports__GPTJForCausalLM = __webpack_exports__.GPTJForCausalLM;
  var __webpack_exports__GPTJModel = __webpack_exports__.GPTJModel;
  var __webpack_exports__GPTJPreTrainedModel = __webpack_exports__.GPTJPreTrainedModel;
  var __webpack_exports__GPTNeoForCausalLM = __webpack_exports__.GPTNeoForCausalLM;
  var __webpack_exports__GPTNeoModel = __webpack_exports__.GPTNeoModel;
  var __webpack_exports__GPTNeoPreTrainedModel = __webpack_exports__.GPTNeoPreTrainedModel;
  var __webpack_exports__GPTNeoXForCausalLM = __webpack_exports__.GPTNeoXForCausalLM;
  var __webpack_exports__GPTNeoXModel = __webpack_exports__.GPTNeoXModel;
  var __webpack_exports__GPTNeoXPreTrainedModel = __webpack_exports__.GPTNeoXPreTrainedModel;
  var __webpack_exports__GPTNeoXTokenizer = __webpack_exports__.GPTNeoXTokenizer;
  var __webpack_exports__GemmaTokenizer = __webpack_exports__.GemmaTokenizer;
  var __webpack_exports__Grok1Tokenizer = __webpack_exports__.Grok1Tokenizer;
  var __webpack_exports__HerbertTokenizer = __webpack_exports__.HerbertTokenizer;
  var __webpack_exports__HubertForCTC = __webpack_exports__.HubertForCTC;
  var __webpack_exports__HubertForSequenceClassification = __webpack_exports__.HubertForSequenceClassification;
  var __webpack_exports__HubertModel = __webpack_exports__.HubertModel;
  var __webpack_exports__HubertPreTrainedModel = __webpack_exports__.HubertPreTrainedModel;
  var __webpack_exports__ImageClassificationPipeline = __webpack_exports__.ImageClassificationPipeline;
  var __webpack_exports__ImageFeatureExtractionPipeline = __webpack_exports__.ImageFeatureExtractionPipeline;
  var __webpack_exports__ImageFeatureExtractor = __webpack_exports__.ImageFeatureExtractor;
  var __webpack_exports__ImageMattingOutput = __webpack_exports__.ImageMattingOutput;
  var __webpack_exports__ImageSegmentationPipeline = __webpack_exports__.ImageSegmentationPipeline;
  var __webpack_exports__ImageToImagePipeline = __webpack_exports__.ImageToImagePipeline;
  var __webpack_exports__ImageToTextPipeline = __webpack_exports__.ImageToTextPipeline;
  var __webpack_exports__LlamaForCausalLM = __webpack_exports__.LlamaForCausalLM;
  var __webpack_exports__LlamaModel = __webpack_exports__.LlamaModel;
  var __webpack_exports__LlamaPreTrainedModel = __webpack_exports__.LlamaPreTrainedModel;
  var __webpack_exports__LlamaTokenizer = __webpack_exports__.LlamaTokenizer;
  var __webpack_exports__LongT5ForConditionalGeneration = __webpack_exports__.LongT5ForConditionalGeneration;
  var __webpack_exports__LongT5Model = __webpack_exports__.LongT5Model;
  var __webpack_exports__LongT5PreTrainedModel = __webpack_exports__.LongT5PreTrainedModel;
  var __webpack_exports__M2M100ForConditionalGeneration = __webpack_exports__.M2M100ForConditionalGeneration;
  var __webpack_exports__M2M100Model = __webpack_exports__.M2M100Model;
  var __webpack_exports__M2M100PreTrainedModel = __webpack_exports__.M2M100PreTrainedModel;
  var __webpack_exports__M2M100Tokenizer = __webpack_exports__.M2M100Tokenizer;
  var __webpack_exports__MBart50Tokenizer = __webpack_exports__.MBart50Tokenizer;
  var __webpack_exports__MBartForCausalLM = __webpack_exports__.MBartForCausalLM;
  var __webpack_exports__MBartForConditionalGeneration = __webpack_exports__.MBartForConditionalGeneration;
  var __webpack_exports__MBartForSequenceClassification = __webpack_exports__.MBartForSequenceClassification;
  var __webpack_exports__MBartModel = __webpack_exports__.MBartModel;
  var __webpack_exports__MBartPreTrainedModel = __webpack_exports__.MBartPreTrainedModel;
  var __webpack_exports__MBartTokenizer = __webpack_exports__.MBartTokenizer;
  var __webpack_exports__MPNetForMaskedLM = __webpack_exports__.MPNetForMaskedLM;
  var __webpack_exports__MPNetForQuestionAnswering = __webpack_exports__.MPNetForQuestionAnswering;
  var __webpack_exports__MPNetForSequenceClassification = __webpack_exports__.MPNetForSequenceClassification;
  var __webpack_exports__MPNetForTokenClassification = __webpack_exports__.MPNetForTokenClassification;
  var __webpack_exports__MPNetModel = __webpack_exports__.MPNetModel;
  var __webpack_exports__MPNetPreTrainedModel = __webpack_exports__.MPNetPreTrainedModel;
  var __webpack_exports__MPNetTokenizer = __webpack_exports__.MPNetTokenizer;
  var __webpack_exports__MT5ForConditionalGeneration = __webpack_exports__.MT5ForConditionalGeneration;
  var __webpack_exports__MT5Model = __webpack_exports__.MT5Model;
  var __webpack_exports__MT5PreTrainedModel = __webpack_exports__.MT5PreTrainedModel;
  var __webpack_exports__MarianMTModel = __webpack_exports__.MarianMTModel;
  var __webpack_exports__MarianModel = __webpack_exports__.MarianModel;
  var __webpack_exports__MarianPreTrainedModel = __webpack_exports__.MarianPreTrainedModel;
  var __webpack_exports__MarianTokenizer = __webpack_exports__.MarianTokenizer;
  var __webpack_exports__MaskedLMOutput = __webpack_exports__.MaskedLMOutput;
  var __webpack_exports__MistralForCausalLM = __webpack_exports__.MistralForCausalLM;
  var __webpack_exports__MistralModel = __webpack_exports__.MistralModel;
  var __webpack_exports__MistralPreTrainedModel = __webpack_exports__.MistralPreTrainedModel;
  var __webpack_exports__MobileBertForMaskedLM = __webpack_exports__.MobileBertForMaskedLM;
  var __webpack_exports__MobileBertForQuestionAnswering = __webpack_exports__.MobileBertForQuestionAnswering;
  var __webpack_exports__MobileBertForSequenceClassification = __webpack_exports__.MobileBertForSequenceClassification;
  var __webpack_exports__MobileBertModel = __webpack_exports__.MobileBertModel;
  var __webpack_exports__MobileBertPreTrainedModel = __webpack_exports__.MobileBertPreTrainedModel;
  var __webpack_exports__MobileBertTokenizer = __webpack_exports__.MobileBertTokenizer;
  var __webpack_exports__MobileViTFeatureExtractor = __webpack_exports__.MobileViTFeatureExtractor;
  var __webpack_exports__MobileViTForImageClassification = __webpack_exports__.MobileViTForImageClassification;
  var __webpack_exports__MobileViTModel = __webpack_exports__.MobileViTModel;
  var __webpack_exports__MobileViTPreTrainedModel = __webpack_exports__.MobileViTPreTrainedModel;
  var __webpack_exports__ModelOutput = __webpack_exports__.ModelOutput;
  var __webpack_exports__MptForCausalLM = __webpack_exports__.MptForCausalLM;
  var __webpack_exports__MptModel = __webpack_exports__.MptModel;
  var __webpack_exports__MptPreTrainedModel = __webpack_exports__.MptPreTrainedModel;
  var __webpack_exports__NllbTokenizer = __webpack_exports__.NllbTokenizer;
  var __webpack_exports__NomicBertModel = __webpack_exports__.NomicBertModel;
  var __webpack_exports__NomicBertPreTrainedModel = __webpack_exports__.NomicBertPreTrainedModel;
  var __webpack_exports__NougatImageProcessor = __webpack_exports__.NougatImageProcessor;
  var __webpack_exports__NougatTokenizer = __webpack_exports__.NougatTokenizer;
  var __webpack_exports__OPTForCausalLM = __webpack_exports__.OPTForCausalLM;
  var __webpack_exports__OPTModel = __webpack_exports__.OPTModel;
  var __webpack_exports__OPTPreTrainedModel = __webpack_exports__.OPTPreTrainedModel;
  var __webpack_exports__ObjectDetectionPipeline = __webpack_exports__.ObjectDetectionPipeline;
  var __webpack_exports__OwlViTFeatureExtractor = __webpack_exports__.OwlViTFeatureExtractor;
  var __webpack_exports__OwlViTForObjectDetection = __webpack_exports__.OwlViTForObjectDetection;
  var __webpack_exports__OwlViTModel = __webpack_exports__.OwlViTModel;
  var __webpack_exports__OwlViTPreTrainedModel = __webpack_exports__.OwlViTPreTrainedModel;
  var __webpack_exports__OwlViTProcessor = __webpack_exports__.OwlViTProcessor;
  var __webpack_exports__Owlv2ForObjectDetection = __webpack_exports__.Owlv2ForObjectDetection;
  var __webpack_exports__Owlv2ImageProcessor = __webpack_exports__.Owlv2ImageProcessor;
  var __webpack_exports__Owlv2Model = __webpack_exports__.Owlv2Model;
  var __webpack_exports__Owlv2PreTrainedModel = __webpack_exports__.Owlv2PreTrainedModel;
  var __webpack_exports__PhiForCausalLM = __webpack_exports__.PhiForCausalLM;
  var __webpack_exports__PhiModel = __webpack_exports__.PhiModel;
  var __webpack_exports__PhiPreTrainedModel = __webpack_exports__.PhiPreTrainedModel;
  var __webpack_exports__Pipeline = __webpack_exports__.Pipeline;
  var __webpack_exports__PreTrainedModel = __webpack_exports__.PreTrainedModel;
  var __webpack_exports__PreTrainedTokenizer = __webpack_exports__.PreTrainedTokenizer;
  var __webpack_exports__PretrainedConfig = __webpack_exports__.PretrainedConfig;
  var __webpack_exports__PretrainedMixin = __webpack_exports__.PretrainedMixin;
  var __webpack_exports__Processor = __webpack_exports__.Processor;
  var __webpack_exports__QuestionAnsweringModelOutput = __webpack_exports__.QuestionAnsweringModelOutput;
  var __webpack_exports__QuestionAnsweringPipeline = __webpack_exports__.QuestionAnsweringPipeline;
  var __webpack_exports__Qwen2ForCausalLM = __webpack_exports__.Qwen2ForCausalLM;
  var __webpack_exports__Qwen2Model = __webpack_exports__.Qwen2Model;
  var __webpack_exports__Qwen2PreTrainedModel = __webpack_exports__.Qwen2PreTrainedModel;
  var __webpack_exports__Qwen2Tokenizer = __webpack_exports__.Qwen2Tokenizer;
  var __webpack_exports__RawImage = __webpack_exports__.RawImage;
  var __webpack_exports__ResNetForImageClassification = __webpack_exports__.ResNetForImageClassification;
  var __webpack_exports__ResNetModel = __webpack_exports__.ResNetModel;
  var __webpack_exports__ResNetPreTrainedModel = __webpack_exports__.ResNetPreTrainedModel;
  var __webpack_exports__RoFormerForMaskedLM = __webpack_exports__.RoFormerForMaskedLM;
  var __webpack_exports__RoFormerForQuestionAnswering = __webpack_exports__.RoFormerForQuestionAnswering;
  var __webpack_exports__RoFormerForSequenceClassification = __webpack_exports__.RoFormerForSequenceClassification;
  var __webpack_exports__RoFormerForTokenClassification = __webpack_exports__.RoFormerForTokenClassification;
  var __webpack_exports__RoFormerModel = __webpack_exports__.RoFormerModel;
  var __webpack_exports__RoFormerPreTrainedModel = __webpack_exports__.RoFormerPreTrainedModel;
  var __webpack_exports__RoFormerTokenizer = __webpack_exports__.RoFormerTokenizer;
  var __webpack_exports__RobertaForMaskedLM = __webpack_exports__.RobertaForMaskedLM;
  var __webpack_exports__RobertaForQuestionAnswering = __webpack_exports__.RobertaForQuestionAnswering;
  var __webpack_exports__RobertaForSequenceClassification = __webpack_exports__.RobertaForSequenceClassification;
  var __webpack_exports__RobertaForTokenClassification = __webpack_exports__.RobertaForTokenClassification;
  var __webpack_exports__RobertaModel = __webpack_exports__.RobertaModel;
  var __webpack_exports__RobertaPreTrainedModel = __webpack_exports__.RobertaPreTrainedModel;
  var __webpack_exports__RobertaTokenizer = __webpack_exports__.RobertaTokenizer;
  var __webpack_exports__SamImageProcessor = __webpack_exports__.SamImageProcessor;
  var __webpack_exports__SamImageSegmentationOutput = __webpack_exports__.SamImageSegmentationOutput;
  var __webpack_exports__SamModel = __webpack_exports__.SamModel;
  var __webpack_exports__SamPreTrainedModel = __webpack_exports__.SamPreTrainedModel;
  var __webpack_exports__SamProcessor = __webpack_exports__.SamProcessor;
  var __webpack_exports__SeamlessM4TFeatureExtractor = __webpack_exports__.SeamlessM4TFeatureExtractor;
  var __webpack_exports__SegformerFeatureExtractor = __webpack_exports__.SegformerFeatureExtractor;
  var __webpack_exports__SegformerForImageClassification = __webpack_exports__.SegformerForImageClassification;
  var __webpack_exports__SegformerForSemanticSegmentation = __webpack_exports__.SegformerForSemanticSegmentation;
  var __webpack_exports__SegformerModel = __webpack_exports__.SegformerModel;
  var __webpack_exports__SegformerPreTrainedModel = __webpack_exports__.SegformerPreTrainedModel;
  var __webpack_exports__Seq2SeqLMOutput = __webpack_exports__.Seq2SeqLMOutput;
  var __webpack_exports__SequenceClassifierOutput = __webpack_exports__.SequenceClassifierOutput;
  var __webpack_exports__SiglipImageProcessor = __webpack_exports__.SiglipImageProcessor;
  var __webpack_exports__SiglipModel = __webpack_exports__.SiglipModel;
  var __webpack_exports__SiglipPreTrainedModel = __webpack_exports__.SiglipPreTrainedModel;
  var __webpack_exports__SiglipTextModel = __webpack_exports__.SiglipTextModel;
  var __webpack_exports__SiglipTokenizer = __webpack_exports__.SiglipTokenizer;
  var __webpack_exports__SiglipVisionModel = __webpack_exports__.SiglipVisionModel;
  var __webpack_exports__SpeechT5FeatureExtractor = __webpack_exports__.SpeechT5FeatureExtractor;
  var __webpack_exports__SpeechT5ForSpeechToText = __webpack_exports__.SpeechT5ForSpeechToText;
  var __webpack_exports__SpeechT5ForTextToSpeech = __webpack_exports__.SpeechT5ForTextToSpeech;
  var __webpack_exports__SpeechT5HifiGan = __webpack_exports__.SpeechT5HifiGan;
  var __webpack_exports__SpeechT5Model = __webpack_exports__.SpeechT5Model;
  var __webpack_exports__SpeechT5PreTrainedModel = __webpack_exports__.SpeechT5PreTrainedModel;
  var __webpack_exports__SpeechT5Processor = __webpack_exports__.SpeechT5Processor;
  var __webpack_exports__SpeechT5Tokenizer = __webpack_exports__.SpeechT5Tokenizer;
  var __webpack_exports__SqueezeBertForMaskedLM = __webpack_exports__.SqueezeBertForMaskedLM;
  var __webpack_exports__SqueezeBertForQuestionAnswering = __webpack_exports__.SqueezeBertForQuestionAnswering;
  var __webpack_exports__SqueezeBertForSequenceClassification = __webpack_exports__.SqueezeBertForSequenceClassification;
  var __webpack_exports__SqueezeBertModel = __webpack_exports__.SqueezeBertModel;
  var __webpack_exports__SqueezeBertPreTrainedModel = __webpack_exports__.SqueezeBertPreTrainedModel;
  var __webpack_exports__SqueezeBertTokenizer = __webpack_exports__.SqueezeBertTokenizer;
  var __webpack_exports__StableLmForCausalLM = __webpack_exports__.StableLmForCausalLM;
  var __webpack_exports__StableLmModel = __webpack_exports__.StableLmModel;
  var __webpack_exports__StableLmPreTrainedModel = __webpack_exports__.StableLmPreTrainedModel;
  var __webpack_exports__Starcoder2ForCausalLM = __webpack_exports__.Starcoder2ForCausalLM;
  var __webpack_exports__Starcoder2Model = __webpack_exports__.Starcoder2Model;
  var __webpack_exports__Starcoder2PreTrainedModel = __webpack_exports__.Starcoder2PreTrainedModel;
  var __webpack_exports__SummarizationPipeline = __webpack_exports__.SummarizationPipeline;
  var __webpack_exports__Swin2SRForImageSuperResolution = __webpack_exports__.Swin2SRForImageSuperResolution;
  var __webpack_exports__Swin2SRImageProcessor = __webpack_exports__.Swin2SRImageProcessor;
  var __webpack_exports__Swin2SRModel = __webpack_exports__.Swin2SRModel;
  var __webpack_exports__Swin2SRPreTrainedModel = __webpack_exports__.Swin2SRPreTrainedModel;
  var __webpack_exports__SwinForImageClassification = __webpack_exports__.SwinForImageClassification;
  var __webpack_exports__SwinModel = __webpack_exports__.SwinModel;
  var __webpack_exports__SwinPreTrainedModel = __webpack_exports__.SwinPreTrainedModel;
  var __webpack_exports__T5ForConditionalGeneration = __webpack_exports__.T5ForConditionalGeneration;
  var __webpack_exports__T5Model = __webpack_exports__.T5Model;
  var __webpack_exports__T5PreTrainedModel = __webpack_exports__.T5PreTrainedModel;
  var __webpack_exports__T5Tokenizer = __webpack_exports__.T5Tokenizer;
  var __webpack_exports__TableTransformerForObjectDetection = __webpack_exports__.TableTransformerForObjectDetection;
  var __webpack_exports__TableTransformerModel = __webpack_exports__.TableTransformerModel;
  var __webpack_exports__TableTransformerObjectDetectionOutput = __webpack_exports__.TableTransformerObjectDetectionOutput;
  var __webpack_exports__TableTransformerPreTrainedModel = __webpack_exports__.TableTransformerPreTrainedModel;
  var __webpack_exports__Tensor = __webpack_exports__.Tensor;
  var __webpack_exports__Text2TextGenerationPipeline = __webpack_exports__.Text2TextGenerationPipeline;
  var __webpack_exports__TextClassificationPipeline = __webpack_exports__.TextClassificationPipeline;
  var __webpack_exports__TextGenerationPipeline = __webpack_exports__.TextGenerationPipeline;
  var __webpack_exports__TextToAudioPipeline = __webpack_exports__.TextToAudioPipeline;
  var __webpack_exports__TokenClassificationPipeline = __webpack_exports__.TokenClassificationPipeline;
  var __webpack_exports__TokenClassifierOutput = __webpack_exports__.TokenClassifierOutput;
  var __webpack_exports__TokenizerModel = __webpack_exports__.TokenizerModel;
  var __webpack_exports__TrOCRForCausalLM = __webpack_exports__.TrOCRForCausalLM;
  var __webpack_exports__TrOCRPreTrainedModel = __webpack_exports__.TrOCRPreTrainedModel;
  var __webpack_exports__TranslationPipeline = __webpack_exports__.TranslationPipeline;
  var __webpack_exports__UniSpeechForCTC = __webpack_exports__.UniSpeechForCTC;
  var __webpack_exports__UniSpeechForSequenceClassification = __webpack_exports__.UniSpeechForSequenceClassification;
  var __webpack_exports__UniSpeechModel = __webpack_exports__.UniSpeechModel;
  var __webpack_exports__UniSpeechPreTrainedModel = __webpack_exports__.UniSpeechPreTrainedModel;
  var __webpack_exports__UniSpeechSatForAudioFrameClassification = __webpack_exports__.UniSpeechSatForAudioFrameClassification;
  var __webpack_exports__UniSpeechSatForCTC = __webpack_exports__.UniSpeechSatForCTC;
  var __webpack_exports__UniSpeechSatForSequenceClassification = __webpack_exports__.UniSpeechSatForSequenceClassification;
  var __webpack_exports__UniSpeechSatModel = __webpack_exports__.UniSpeechSatModel;
  var __webpack_exports__UniSpeechSatPreTrainedModel = __webpack_exports__.UniSpeechSatPreTrainedModel;
  var __webpack_exports__ViTFeatureExtractor = __webpack_exports__.ViTFeatureExtractor;
  var __webpack_exports__ViTForImageClassification = __webpack_exports__.ViTForImageClassification;
  var __webpack_exports__ViTImageProcessor = __webpack_exports__.ViTImageProcessor;
  var __webpack_exports__ViTModel = __webpack_exports__.ViTModel;
  var __webpack_exports__ViTPreTrainedModel = __webpack_exports__.ViTPreTrainedModel;
  var __webpack_exports__VisionEncoderDecoderModel = __webpack_exports__.VisionEncoderDecoderModel;
  var __webpack_exports__VitMatteForImageMatting = __webpack_exports__.VitMatteForImageMatting;
  var __webpack_exports__VitMatteImageProcessor = __webpack_exports__.VitMatteImageProcessor;
  var __webpack_exports__VitMattePreTrainedModel = __webpack_exports__.VitMattePreTrainedModel;
  var __webpack_exports__VitsModel = __webpack_exports__.VitsModel;
  var __webpack_exports__VitsModelOutput = __webpack_exports__.VitsModelOutput;
  var __webpack_exports__VitsPreTrainedModel = __webpack_exports__.VitsPreTrainedModel;
  var __webpack_exports__VitsTokenizer = __webpack_exports__.VitsTokenizer;
  var __webpack_exports__Wav2Vec2BertForCTC = __webpack_exports__.Wav2Vec2BertForCTC;
  var __webpack_exports__Wav2Vec2BertForSequenceClassification = __webpack_exports__.Wav2Vec2BertForSequenceClassification;
  var __webpack_exports__Wav2Vec2BertModel = __webpack_exports__.Wav2Vec2BertModel;
  var __webpack_exports__Wav2Vec2BertPreTrainedModel = __webpack_exports__.Wav2Vec2BertPreTrainedModel;
  var __webpack_exports__Wav2Vec2CTCTokenizer = __webpack_exports__.Wav2Vec2CTCTokenizer;
  var __webpack_exports__Wav2Vec2FeatureExtractor = __webpack_exports__.Wav2Vec2FeatureExtractor;
  var __webpack_exports__Wav2Vec2ForAudioFrameClassification = __webpack_exports__.Wav2Vec2ForAudioFrameClassification;
  var __webpack_exports__Wav2Vec2ForCTC = __webpack_exports__.Wav2Vec2ForCTC;
  var __webpack_exports__Wav2Vec2ForSequenceClassification = __webpack_exports__.Wav2Vec2ForSequenceClassification;
  var __webpack_exports__Wav2Vec2Model = __webpack_exports__.Wav2Vec2Model;
  var __webpack_exports__Wav2Vec2PreTrainedModel = __webpack_exports__.Wav2Vec2PreTrainedModel;
  var __webpack_exports__Wav2Vec2ProcessorWithLM = __webpack_exports__.Wav2Vec2ProcessorWithLM;
  var __webpack_exports__WavLMForAudioFrameClassification = __webpack_exports__.WavLMForAudioFrameClassification;
  var __webpack_exports__WavLMForCTC = __webpack_exports__.WavLMForCTC;
  var __webpack_exports__WavLMForSequenceClassification = __webpack_exports__.WavLMForSequenceClassification;
  var __webpack_exports__WavLMForXVector = __webpack_exports__.WavLMForXVector;
  var __webpack_exports__WavLMModel = __webpack_exports__.WavLMModel;
  var __webpack_exports__WavLMPreTrainedModel = __webpack_exports__.WavLMPreTrainedModel;
  var __webpack_exports__WhisperFeatureExtractor = __webpack_exports__.WhisperFeatureExtractor;
  var __webpack_exports__WhisperForConditionalGeneration = __webpack_exports__.WhisperForConditionalGeneration;
  var __webpack_exports__WhisperModel = __webpack_exports__.WhisperModel;
  var __webpack_exports__WhisperPreTrainedModel = __webpack_exports__.WhisperPreTrainedModel;
  var __webpack_exports__WhisperProcessor = __webpack_exports__.WhisperProcessor;
  var __webpack_exports__WhisperTokenizer = __webpack_exports__.WhisperTokenizer;
  var __webpack_exports__XLMForQuestionAnswering = __webpack_exports__.XLMForQuestionAnswering;
  var __webpack_exports__XLMForSequenceClassification = __webpack_exports__.XLMForSequenceClassification;
  var __webpack_exports__XLMForTokenClassification = __webpack_exports__.XLMForTokenClassification;
  var __webpack_exports__XLMModel = __webpack_exports__.XLMModel;
  var __webpack_exports__XLMPreTrainedModel = __webpack_exports__.XLMPreTrainedModel;
  var __webpack_exports__XLMRobertaForMaskedLM = __webpack_exports__.XLMRobertaForMaskedLM;
  var __webpack_exports__XLMRobertaForQuestionAnswering = __webpack_exports__.XLMRobertaForQuestionAnswering;
  var __webpack_exports__XLMRobertaForSequenceClassification = __webpack_exports__.XLMRobertaForSequenceClassification;
  var __webpack_exports__XLMRobertaForTokenClassification = __webpack_exports__.XLMRobertaForTokenClassification;
  var __webpack_exports__XLMRobertaModel = __webpack_exports__.XLMRobertaModel;
  var __webpack_exports__XLMRobertaPreTrainedModel = __webpack_exports__.XLMRobertaPreTrainedModel;
  var __webpack_exports__XLMRobertaTokenizer = __webpack_exports__.XLMRobertaTokenizer;
  var __webpack_exports__XLMTokenizer = __webpack_exports__.XLMTokenizer;
  var __webpack_exports__XLMWithLMHeadModel = __webpack_exports__.XLMWithLMHeadModel;
  var __webpack_exports__XVectorOutput = __webpack_exports__.XVectorOutput;
  var __webpack_exports__YolosFeatureExtractor = __webpack_exports__.YolosFeatureExtractor;
  var __webpack_exports__YolosForObjectDetection = __webpack_exports__.YolosForObjectDetection;
  var __webpack_exports__YolosModel = __webpack_exports__.YolosModel;
  var __webpack_exports__YolosObjectDetectionOutput = __webpack_exports__.YolosObjectDetectionOutput;
  var __webpack_exports__YolosPreTrainedModel = __webpack_exports__.YolosPreTrainedModel;
  var __webpack_exports__ZeroShotAudioClassificationPipeline = __webpack_exports__.ZeroShotAudioClassificationPipeline;
  var __webpack_exports__ZeroShotClassificationPipeline = __webpack_exports__.ZeroShotClassificationPipeline;
  var __webpack_exports__ZeroShotImageClassificationPipeline = __webpack_exports__.ZeroShotImageClassificationPipeline;
  var __webpack_exports__ZeroShotObjectDetectionPipeline = __webpack_exports__.ZeroShotObjectDetectionPipeline;
  var __webpack_exports__bankers_round = __webpack_exports__.bankers_round;
  var __webpack_exports__cat = __webpack_exports__.cat;
  var __webpack_exports__cos_sim = __webpack_exports__.cos_sim;
  var __webpack_exports__dot = __webpack_exports__.dot;
  var __webpack_exports__dynamicTimeWarping = __webpack_exports__.dynamicTimeWarping;
  var __webpack_exports__env = __webpack_exports__.env;
  var __webpack_exports__getTopItems = __webpack_exports__.getTopItems;
  var __webpack_exports__hanning = __webpack_exports__.hanning;
  var __webpack_exports__interpolate = __webpack_exports__.interpolate;
  var __webpack_exports__interpolate_data = __webpack_exports__.interpolate_data;
  var __webpack_exports__layer_norm = __webpack_exports__.layer_norm;
  var __webpack_exports__log_softmax = __webpack_exports__.log_softmax;
  var __webpack_exports__magnitude = __webpack_exports__.magnitude;
  var __webpack_exports__max = __webpack_exports__.max;
  var __webpack_exports__mean = __webpack_exports__.mean;
  var __webpack_exports__mean_pooling = __webpack_exports__.mean_pooling;
  var __webpack_exports__medianFilter = __webpack_exports__.medianFilter;
  var __webpack_exports__mel_filter_bank = __webpack_exports__.mel_filter_bank;
  var __webpack_exports__min = __webpack_exports__.min;
  var __webpack_exports__ones = __webpack_exports__.ones;
  var __webpack_exports__ones_like = __webpack_exports__.ones_like;
  var __webpack_exports__permute = __webpack_exports__.permute;
  var __webpack_exports__permute_data = __webpack_exports__.permute_data;
  var __webpack_exports__pipeline = __webpack_exports__.pipeline;
  var __webpack_exports__quantize_embeddings = __webpack_exports__.quantize_embeddings;
  var __webpack_exports__read_audio = __webpack_exports__.read_audio;
  var __webpack_exports__round = __webpack_exports__.round;
  var __webpack_exports__softmax = __webpack_exports__.softmax;
  var __webpack_exports__spectrogram = __webpack_exports__.spectrogram;
  var __webpack_exports__stack = __webpack_exports__.stack;
  var __webpack_exports__std_mean = __webpack_exports__.std_mean;
  var __webpack_exports__window_function = __webpack_exports__.window_function;
  return __toCommonJS(transformers_min_exports);
})();
